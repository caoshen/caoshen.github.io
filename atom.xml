<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caoshen</title>
  
  <subtitle>caoshen 的博客</subtitle>
  <link href="https://www.okclouder.cn/atom.xml" rel="self"/>
  
  <link href="https://www.okclouder.cn/"/>
  <updated>2020-12-31T15:48:00.081Z</updated>
  <id>https://www.okclouder.cn/</id>
  
  <author>
    <name>caoshen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年终总结</title>
    <link href="https://www.okclouder.cn/2020/12/31/summary-2020/"/>
    <id>https://www.okclouder.cn/2020/12/31/summary-2020/</id>
    <published>2020-12-31T14:38:51.000Z</published>
    <updated>2020-12-31T15:48:00.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年终总结"><a href="#2020年终总结" class="headerlink" title="2020年终总结"></a>2020年终总结</h1><p>2020年很快就过去了。去年的这个时候还在鹦鹉洲长江大桥散步。一月份疫情爆发，到最后过年的时候武汉封城，直到五月份才真正能够外出。下半年过得很快，虽然看上去很忙碌，但实际没有沉淀。就这样慢慢到了十二月，一年过去了。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>年初的时候换了工作。本来打算年前入职，因为项目交接和离职证明拖到了年后。过年的时候疫情爆发，在年后的第二周办理了云入职，之后远程办公到五月。</p><p>工作内容由之前的手机系统应用 APP 开发转为 SDK 开发，主要是在 Android 蓝牙 API 的基础上封装定制，满足业务方的需求。项目规模比之前小，基本上单人承担整个 Android SDK 的开发和维护工作。由于 SDK 实际只给内部的 APP 使用，版本的更新迭代也比之前少得多。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>这一年开始尝试使用 kotlin 开发。一些简单的能够快速上手的代码基本能用 kotlin 完成。</p><p>开始了解 Gradle 的使用方法，比如编写 Gradle 插件完成 ASM 代码插桩。</p><p>重拾 Leetcode。通过 40 道算法题，总共完成 188 道。 </p><p>使用新的主题更新了博客网站。今年写了 43 篇博客，其中下半年 9 篇，明显偷懒了。而且文章内容上没有连贯性，不成体系。</p><p>总的来说技术上没有太大的进步，也没有什么亮点。今年也没有完成每年面试一次的计划。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>微信读书读过 11 本书。《文明的冲突》《曾国藩传》《干法》等。但是看完的就 2 本书。</p><p>年初制定的每天阅读三个”半小时“计划没有完成。最多只有早上在公司的时候读半小时。</p><h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>由于疫情原因，上半年一直在家办公。但是有跟着一些运动 APP 每天锻炼。今年总共运动 7500 分钟。平均下来每天 20 分钟左右。体重基本保持一个稳定的数值。但是血脂超标，每天的作息不够规律。基本上都在晚上12点左右入睡。</p><h2 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h2><p>虽然一月份疫情爆发，但是这一年的基金和股票涨幅比之前都要好。年初卖掉小米买入京东。结果京东涨了 120%，小米涨了 260%，年末又买了一些小米。股票在这一年中的行情不好预估，只能买入然后坚定看好，长期持有。基金今年收益 69%，超过预期。基金和股票没有本金支持，投入较少，但是回报率可以。</p><h2 id="新的目标"><a href="#新的目标" class="headerlink" title="新的目标"></a>新的目标</h2><ol><li>每天运动半小时。</li><li>三个”半小时“计划，把书架没看完的书全部看完。</li><li>每周写一篇博客，减少无意义的记录，增加自身理解。总阅读量达到10万。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2020年终总结&quot;&gt;&lt;a href=&quot;#2020年终总结&quot; class=&quot;headerlink&quot; title=&quot;2020年终总结&quot;&gt;&lt;/a&gt;2020年终总结&lt;/h1&gt;&lt;p&gt;2020年很快就过去了。去年的这个时候还在鹦鹉洲长江大桥散步。一月份疫情爆发，到最后过年的时</summary>
      
    
    
    
    
    <category term="年终总结" scheme="https://www.okclouder.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Android Jetpack 之使用 Room 操作数据库</title>
    <link href="https://www.okclouder.cn/2020/12/10/android-room-with-a-view/"/>
    <id>https://www.okclouder.cn/2020/12/10/android-room-with-a-view/</id>
    <published>2020-12-10T11:22:00.000Z</published>
    <updated>2020-12-16T13:49:02.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Jetpack-之使用-Room-操作数据库"><a href="#Android-Jetpack-之使用-Room-操作数据库" class="headerlink" title="Android Jetpack 之使用 Room 操作数据库"></a>Android Jetpack 之使用 Room 操作数据库</h1><p>Room 是 Android Jetpack 中用来处理数据库的框架，它可以用来替代原有的 SQLiteOpenHelper，简化数据库操作。</p><p>Android Room with a View 是一个 Google Codelab 用来展示 Jetpack Room 用法的 app。它可以输入一个单词并自动刷新显示数据库中的所有单词。通过 Android Room with a View 这个项目可以熟悉 Android Jetpack 的 LiveData、ViewModel、Room 的用法。</p><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p>Room 需要先新建一个 abstract 的 RoomDatabase 类，它继承自 RoomDatabase。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRoomDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @Database 注解表明使用 RoomDatabase 构造数据库。</p><p>@Database 注解有 2 个 方法：</p><ul><li>entities 表示数据库中有哪些表。通常用一个数据类表示表结构，比如 Word::class。</li><li>version 表示当前数据库的版本号。数据库升级时会用到版本号。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Word::class], version = 1)</span></span><br></pre></td></tr></table></figure><p>WordRoomDatabase 类有一个抽象方法，用来返回 Dao 类，比如 WordDao。WordDao 定义了数据的增删改查接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRoomDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">wordDao</span><span class="params">()</span></span>: WordDao</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDatabase 方法使用单例模式构造 WordRoomDatabase 的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRoomDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>, scope: <span class="type">CoroutineScope</span>)</span></span>: WordRoomDatabase &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> instance = Room.databaseBuilder(</span><br><span class="line">                        context.applicationContext,</span><br><span class="line">                        WordRoomDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">                        <span class="string">&quot;word_database&quot;</span></span><br><span class="line">                )</span><br><span class="line">                        <span class="comment">// when migrate database, wipes and rebuilds database</span></span><br><span class="line">                        .fallbackToDestructiveMigration()</span><br><span class="line">                        .addCallback(WordDatabaseCallback(scope))</span><br><span class="line">                        .build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>getDatabase 使用 Room.databaseBuilder 构造 database。databaseBuilder 可以传入一个 Callback，它可以在数据库的生命周期执行回调，比如 database 的 onCreate 执行数据库的初始化操作，插入几条数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDatabaseCallback</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope) : RoomDatabase.Callback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(db)</span><br><span class="line">        <span class="comment">// init database content</span></span><br><span class="line">        INSTANCE?.let &#123; database -&gt;</span><br><span class="line">            scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                populateDatabase(database.wordDao())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 WordRoomDatabase 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Word::class], version = 1)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRoomDatabase</span> : <span class="type">RoomDatabase</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">wordDao</span><span class="params">()</span></span>: WordDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: WordRoomDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>, scope: <span class="type">CoroutineScope</span>)</span></span>: WordRoomDatabase &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> instance = Room.databaseBuilder(</span><br><span class="line">                        context.applicationContext,</span><br><span class="line">                        WordRoomDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">                        <span class="string">&quot;word_database&quot;</span></span><br><span class="line">                )</span><br><span class="line">                        <span class="comment">// when migrate database, wipes and rebuilds database</span></span><br><span class="line">                        .fallbackToDestructiveMigration()</span><br><span class="line">                        .addCallback(WordDatabaseCallback(scope))</span><br><span class="line">                        .build()</span><br><span class="line">                INSTANCE = instance</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WordDatabaseCallback</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> scope: CoroutineScope) : RoomDatabase.Callback() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.onCreate(db)</span><br><span class="line">                <span class="comment">// init database content</span></span><br><span class="line">                INSTANCE?.let &#123; database -&gt;</span><br><span class="line">                    scope.launch(Dispatchers.IO) &#123;</span><br><span class="line">                        populateDatabase(database.wordDao())</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">populateDatabase</span><span class="params">(wordDao: <span class="type">WordDao</span>)</span></span> &#123;</span><br><span class="line">            wordDao.deleteAll()</span><br><span class="line">            <span class="keyword">var</span> word = Word(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            wordDao.insert(word)</span><br><span class="line">            word = Word(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">            wordDao.insert(word)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LiveData-与-Flow"><a href="#LiveData-与-Flow" class="headerlink" title="LiveData 与 Flow"></a>LiveData 与 Flow</h2><p>LiveData 将数据转换为可以被观察的数据。当数据发生变化时，LiveData 会将变化传递给 LiveData 定义的观察者。</p><p>wordViewModel.allWords 是一个 LiveData，当 words 发生变化时通知 adapter 刷新 recyclerview。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        wordViewModel.allWords.observe(<span class="keyword">this</span>) &#123; words -&gt;</span><br><span class="line">            words.let &#123;</span><br><span class="line">                adapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repository.allWords 是 wordDao 定义的 Flow 流，它以 Flow <a href="https://www.kotlincn.net/docs/reference/coroutines/flow.html">异步流</a>的形式返回 Word 列表。</p><p>asLiveData 方法将 Flow 转换为 LiveData。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: WordRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allWords: LiveData&lt;List&lt;Word&gt;&gt; = repository.allWords.asLiveData()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordRepository</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> wordDao: WordDao) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allWords: Flow&lt;List&lt;Word&gt;&gt; = wordDao.getAlphabetizeWords()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lifecycle-livedata-ktx 依赖库的 FlowLiveData.kt 文件定义了 asLiveData 扩展函数。它可以将 Flow 转换为 LiveData。当数据库发生变化时，Flow 可以实时更新，从而通知 LiveData 刷新界面。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">asLiveData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    timeoutInMs: <span class="type">Long</span> = DEFAULT_TIMEOUT</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: LiveData&lt;T&gt; = liveData(context, timeoutInMs) &#123;</span><br><span class="line">    collect &#123;</span><br><span class="line">        emit(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 Flow 的构造过程定义在 room-ktx 依赖库的 CoroutinesRoom 类的 createFlow，它给数据库加上了观察者（observer）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutinesRoom</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">createFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            db: <span class="type">RoomDatabase</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            inTransaction: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            tableNames: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">            callable: <span class="type">Callable</span>&lt;<span class="type">R</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>: Flow&lt;<span class="meta">@JvmSuppressWildcards</span> R&gt; = flow &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WordDao 数据访问接口在查询时返回 Flow。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WordDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Flow notify</span></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;SELECT * FROM word_table ORDER BY word ASC&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAlphabetizeWords</span><span class="params">()</span></span>: Flow&lt;List&lt;Word&gt;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ignore 如果有冲突就不插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(word: <span class="type">Word</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="meta-string">&quot;DELETE FROM word_table&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteAll</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 WordViewModel 保存 LiveData。外部 Activity 通过 WordViewModel 操作数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordViewModel</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> repository: WordRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allWords: LiveData&lt;List&lt;Word&gt;&gt; = repository.allWords.asLiveData()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.com/codelabs/android-room-with-a-view-kotlin">Codelab : Android Room with A View - Kotlin</a></p><p><a href="https://github.com/googlecodelabs/android-room-with-a-view">googlecodelabs/android-room-with-a-view</a></p><p><a href="https://developer.android.com/kotlin/flow?hl=zh-cn">Kotlin 数据流</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-Jetpack-之使用-Room-操作数据库&quot;&gt;&lt;a href=&quot;#Android-Jetpack-之使用-Room-操作数据库&quot; class=&quot;headerlink&quot; title=&quot;Android Jetpack 之使用 Room 操作数据库&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="Jetpack" scheme="https://www.okclouder.cn/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android AOP 框架 Lancet 应用与解析</title>
    <link href="https://www.okclouder.cn/2020/12/08/lancet-analysis/"/>
    <id>https://www.okclouder.cn/2020/12/08/lancet-analysis/</id>
    <published>2020-12-08T13:12:00.000Z</published>
    <updated>2020-12-08T15:46:39.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-AOP-框架-Lancet-应用与解析"><a href="#Android-AOP-框架-Lancet-应用与解析" class="headerlink" title="Android AOP 框架 Lancet 应用与解析"></a>Android AOP 框架 Lancet 应用与解析</h1><p>Lancet 是一个轻量级 Android AOP 框架。它可以用来替换某个方法的代码实现，或者在方法执行前后插入代码。</p><h2 id="Lancet-应用举例"><a href="#Lancet-应用举例" class="headerlink" title="Lancet 应用举例"></a>Lancet 应用举例</h2><p>待修改的 MainActivity 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// onCreatelancet</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设需要在 MainActivity 的每一个 Log 日志之前都加上 “lancet” 后缀，可以使用 Lancet 的 @Proxy 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Proxy(&quot;i&quot;)</span></span><br><span class="line">    <span class="meta">@TargetClass(&quot;android.util.Log&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">anyName</span><span class="params">(String tag, String msg)</span></span>&#123;</span><br><span class="line">        msg = msg + <span class="string">&quot;lancet&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Origin.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: onCreatelancet</span><br></pre></td></tr></table></figure><p>假设需要在 MainActivity 的 onStop 方法执行之前打印日志到标准输出，可以使用 Lancet 的 @Insert 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TargetClass(value = &quot;androidx.appcompat.app.AppCompatActivity&quot;, scope = Scope.LEAF)</span></span><br><span class="line">    <span class="meta">@Insert(value = &quot;onStop&quot;, mayCreateSuper = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello onStop&quot;</span>);</span><br><span class="line">        Origin.callVoid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 MainActivity 触发 onStop 时，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out: hello onStop</span><br></pre></td></tr></table></figure><h2 id="Lancet-注入"><a href="#Lancet-注入" class="headerlink" title="Lancet 注入"></a>Lancet 注入</h2><p>使用 jadx-gui 工具反编译 apk，可以看出 MainActivity 注入了一个 _lancet 子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_lancet</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">_lancet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Proxy(&quot;i&quot;)</span></span><br><span class="line">        <span class="meta">@TargetClass(&quot;android.util.Log&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cn_okclouder_lancet_use_HookClass_anyName</span><span class="params">(String str, String str2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Log.i(str, str2 + <span class="string">&quot;lancet&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@TargetClass(scope = Scope.LEAF, value = &quot;androidx.appcompat.app.AppCompatActivity&quot;)</span></span><br><span class="line">        <span class="meta">@Insert(mayCreateSuper = true, value = &quot;onStop&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cn_okclouder_lancet_use_HookClass_onStop</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello onStop&quot;</span>);</span><br><span class="line">            mainActivity.onStop$___twin___();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: private */</span></span><br><span class="line">    <span class="comment">/* access modifiers changed from: public */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> onStop$___twin___() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.appcompat.app.AppCompatActivity, androidx.fragment.app.FragmentActivity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _lancet.cn_okclouder_lancet_use_HookClass_onStop(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// androidx.core.app.ComponentActivity, androidx.appcompat.app.AppCompatActivity, androidx.fragment.app.FragmentActivity</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        _lancet.cn_okclouder_lancet_use_HookClass_anyName(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_lancet 子类按照 HookClass 中定义的 anyName 和 onStop 方法生成了 2 个静态方法。</p><p>anyName 方法直接调用了 Log.i，只是改变了方法的第二个参数，即 message 参数，为 message 参数加上了 “lancet” 后缀。</p><p>onStop 方法首先输出 HookClass 中定义的 system.out，然后调用 MainActivity onStop 方法的 twin 方法。twin 方法是 MainActivity 默认的 onStop 方法。因为 @Insert 注解会改变原有的 onStop，直接在 _lancet 子类的 onStop 方法无法调用 MainActivity 的 super.onStop()，调用 MainActivity 的 onStop 会导致循环调用，因此使用了 twin 方法间接调用默认 onStop。</p><p>在 MainActivity 原有的调用 Log.i 和 onStop 方法的地方使用 _lancet 子类的静态方法替换，从而实现了 HookClass 定义的代码替换。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-AOP-框架-Lancet-应用与解析&quot;&gt;&lt;a href=&quot;#Android-AOP-框架-Lancet-应用与解析&quot; class=&quot;headerlink&quot; title=&quot;Android AOP 框架 Lancet 应用与解析&quot;&gt;&lt;/a&gt;Andro</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="Gradle" scheme="https://www.okclouder.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle Android Transform API 编译修改 class</title>
    <link href="https://www.okclouder.cn/2020/11/03/gradle-transform-api/"/>
    <id>https://www.okclouder.cn/2020/11/03/gradle-transform-api/</id>
    <published>2020-11-03T02:07:21.000Z</published>
    <updated>2020-12-08T15:46:39.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle-Android-Transform-API-编译修改-class"><a href="#Gradle-Android-Transform-API-编译修改-class" class="headerlink" title="Gradle Android Transform API 编译修改 class"></a>Gradle Android Transform API 编译修改 class</h1><h2 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h2><p>Android 的 Gradle 插件一般用作 Android 工程的编译构建流程。以 Android app 模块的 build.gradle 为例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br></pre></td></tr></table></figure><p>‘com.android.application’ 插件是 Android Gradle Plugin(AGP) 提供的用作 app 编译的插件。</p><p>Android library 模块也提供了类似的插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br></pre></td></tr></table></figure><p>‘com.android.library’ 插件是 Android Gradle Plugin(AGP) 提供的用作 library 编译的插件。</p><p>要使用这些插件，必须先在根目录下的 build.gradle 添加编译依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:4.0.2&#x27;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不清楚如何编写一个 Gradle 插件，可以先看 <a href="https://blog.csdn.net/caoshen2014/article/details/102528973">Gradle 插件基础</a>，了解如何写一个 Gradle 插件，并且应用到 Android 项目。</p><h2 id="Transform-API"><a href="#Transform-API" class="headerlink" title="Transform API"></a>Transform API</h2><p>通常我们编写 Gradle 插件是为了对原有编译流程做修改，或者修改项目源码中某种类型的类实现做统一的编译期修改。</p><p>例如路由自动注册、项目无痕埋点、全局性能监控等使用场景。如果手动对代码的每一处都做修改，不仅工作量大，而且容易遗漏出错。当项目规模增大，涉及的开发人员变多，还会出现信息不同步、修改不一致等问题。</p><p>要修改原有编译流程，一般就会在自定义的 Gradle 插件中注册 Transform API。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPlugin</span>: <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(target: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        target.extensions.findByType(AppExtension::<span class="keyword">class</span>.java)?.run &#123;</span><br><span class="line">            registerTransform(AutoRegisterTransform(target))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transform 是 Android build api 的一部分，它主要用来处理编译的中间过程。每一个 Transform 对应一个 Gradle task，一个 Transform 的输出会变为下一个 Transform 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.build.api.transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Transform that processes intermediary build artifacts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For each added transform, a new task is created. The action of adding a transform takes</span></span><br><span class="line"><span class="comment"> * care of handling dependencies between the tasks. This is done based on what the transform</span></span><br><span class="line"><span class="comment"> * processes. The output of the transform becomes consumable by other transforms and these</span></span><br><span class="line"><span class="comment"> * tasks get automatically linked together.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;MethodMayBeStatic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写自定义的 Transfrom 时，一般需要重写 getName、getInputTypes、getScopes、isIncremental、transform 5 个方法。</p><h3 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h3><p>getName() 用来指明 Transform 的名称。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String = <span class="string">&quot;AutoRegisterTransform&quot;</span></span><br></pre></td></tr></table></figure><h3 id="getInputTypes"><a href="#getInputTypes" class="headerlink" title="getInputTypes"></a>getInputTypes</h3><p>getInputTypes() 用来指明 Transform 的输入类型。常用的输入类型可以是 Classes 、Resources。 Classes 是 Jar 文件或者目录里面的 class 字节码。 Resources 是标准的 Java 资源文件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入文件的类型</span></span><br><span class="line"><span class="comment"> * 可供我们去处理的有两种类型, 分别是编译后的java代码, 以及资源文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getInputTypes</span><span class="params">()</span></span>: MutableSet&lt;QualifiedContent.ContentType&gt; = TransformManager.CONTENT_CLASS</span><br></pre></td></tr></table></figure><p>TransformManager 的 getTaskNamePrefix 用来生成 transform task 的前缀。Task 的名称与输入的 InputTypes 以及 Transform 名称相关。</p><p>如果 Transform 的名称是 DemoTransform，那么编译过程新增的 task 就有 transformClassesWithDemoTransformForDebug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getTaskNamePrefix</span><span class="params">(<span class="meta">@NonNull</span> Transform transform)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;transform&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sb.append(</span><br><span class="line">            transform</span><br><span class="line">                    .getInputTypes()</span><br><span class="line">                    .stream()</span><br><span class="line">                    .map(</span><br><span class="line">                            inputType -&gt;</span><br><span class="line">                                    CaseFormat.UPPER_UNDERSCORE.to(</span><br><span class="line">                                            CaseFormat.UPPER_CAMEL, inputType.name()))</span><br><span class="line">                    .sorted() <span class="comment">// Keep the order stable.</span></span><br><span class="line">                    .collect(Collectors.joining(<span class="string">&quot;And&quot;</span>)));</span><br><span class="line">    sb.append(<span class="string">&quot;With&quot;</span>);</span><br><span class="line">    StringHelper.appendCapitalized(sb, transform.getName());</span><br><span class="line">    sb.append(<span class="string">&quot;For&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getScopes"><a href="#getScopes" class="headerlink" title="getScopes"></a>getScopes</h3><p>getScopes 用来指明 Transform 作用的范围。常用 Transform 的范围有 SCOPE_FULL_PROJECT。SCOPE_FULL_PROJECT 是 PROJECT、SUB_PROJECTS、EXTERNAL_LIBRARIES 的集合，分别表示当前模块，依赖的子模块、外部依赖。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定作用范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getScopes</span><span class="params">()</span></span>: MutableSet&lt;<span class="keyword">in</span> QualifiedContent.Scope&gt; = TransformManager.SCOPE_FULL_PROJECT</span><br></pre></td></tr></table></figure><h3 id="isIncremental"><a href="#isIncremental" class="headerlink" title="isIncremental"></a>isIncremental</h3><p>isIncremental() 用来指明是否开启增量编译。开启增量编译后，只会处理发生变更的文件，加快编译速度。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持增量</span></span><br><span class="line"><span class="comment"> * 如果支持增量执行, 则变化输入内容可能包含 修改/删除/添加 文件的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isIncremental</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>transform(transformInvocation: TransformInvocation) 用来指明编译的具体动作。如果 transform 什么都不做，那么生成的 APK 里面是没有 dex 文件的。因此至少需要将 Transform 的输入复制到输出目录。同时可以遍历扫描每一个 class 文件，针对某一类文件做特殊处理，这种操作就是字节码插桩。</p><p>因为 Transform 的基础操作比如文件的复制、删除等都是通用操作，可以提取一个通用的 BaseTransform，并且添加基础操作到 transform 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTransform</span> : <span class="type">Transform</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * transform的执行主函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(transformInvocation: <span class="type">TransformInvocation</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> outputProvider = transformInvocation.outputProvider</span><br><span class="line">        println(<span class="string">&quot;有没有增量编译<span class="subst">$&#123;transformInvocation.isIncremental&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (input <span class="keyword">in</span> transformInvocation.inputs) &#123;</span><br><span class="line">            with(input) &#123;</span><br><span class="line">                <span class="comment">// 输入源为jar</span></span><br><span class="line">                jarInputs.forEach &#123; jarInput -&gt;</span><br><span class="line">                    <span class="keyword">val</span> inputJar = jarInput.file</span><br><span class="line">                    <span class="keyword">val</span> outputJar = outputProvider.getContentLocation(</span><br><span class="line">                        jarInput.name,</span><br><span class="line">                        jarInput.contentTypes,</span><br><span class="line">                        jarInput.scopes,</span><br><span class="line">                        Format.JAR</span><br><span class="line">                    )</span><br><span class="line">                    <span class="keyword">if</span> (transformInvocation.isIncremental) &#123;</span><br><span class="line">                        <span class="keyword">when</span> (jarInput.status) &#123;</span><br><span class="line">                            NOTCHANGED -&gt; &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ADDED, CHANGED -&gt; transformJar(inputJar, outputJar)</span><br><span class="line">                            REMOVED -&gt; FileUtils.delete(outputJar)</span><br><span class="line">                            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        transformJar(inputJar, outputJar)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输入源为文件夹</span></span><br><span class="line">                directoryInputs.forEach &#123; di -&gt;</span><br><span class="line">                    <span class="keyword">val</span> inputDir = di.file</span><br><span class="line">                    <span class="keyword">val</span> outputDir = outputProvider.getContentLocation(</span><br><span class="line">                        di.name,</span><br><span class="line">                        di.contentTypes,</span><br><span class="line">                        di.scopes,</span><br><span class="line">                        Format.DIRECTORY</span><br><span class="line">                    )</span><br><span class="line">                    <span class="keyword">if</span> (transformInvocation.isIncremental) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (entry <span class="keyword">in</span> di.changedFiles.entries) &#123;</span><br><span class="line">                            <span class="keyword">val</span> inputFile = entry.key</span><br><span class="line">                            <span class="keyword">when</span> (entry.value) &#123;</span><br><span class="line">                                NOTCHANGED -&gt; &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                                ADDED, CHANGED -&gt; &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (!inputFile.isDirectory &amp;&amp; inputFile.name.endsWith(</span><br><span class="line">                                            SdkConstants.DOT_CLASS</span><br><span class="line">                                        )</span><br><span class="line">                                    ) &#123;</span><br><span class="line">                                        <span class="keyword">val</span> <span class="keyword">out</span> = toOutputFile(outputDir, inputDir, inputFile)</span><br><span class="line">                                        transformFile(inputFile, <span class="keyword">out</span>)</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                REMOVED -&gt; &#123;</span><br><span class="line">                                    <span class="keyword">val</span> outputFile = toOutputFile(outputDir, inputDir, inputFile)</span><br><span class="line">                                    FileUtils.deleteIfExists(outputFile)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        FileUtils.getAllFiles(inputDir)</span><br><span class="line">                            .filter &#123;</span><br><span class="line">                                <span class="literal">true</span> == it?.name?.endsWith(SdkConstants.DOT_CLASS)</span><br><span class="line">                            &#125;.forEach &#123; fileIn -&gt;</span><br><span class="line">                                <span class="keyword">val</span> <span class="keyword">out</span> = toOutputFile(outputDir, inputDir, fileIn)</span><br><span class="line">                                transformFile(fileIn, <span class="keyword">out</span>)</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ASM-修改字节码"><a href="#ASM-修改字节码" class="headerlink" title="ASM 修改字节码"></a>ASM 修改字节码</h2><p>修改字节码的方式有很多种，这里介绍使用 <a href="https://asm.ow2.io/">ASM</a> 修改字节码的方式。相比其他方式，ASM 修改效率很高。</p><p>在 build.gradle 引入 ASM 依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.ow2.asm:asm:6.0&#x27;</span></span><br></pre></td></tr></table></figure><p>因为字节码的可读性较低，如果不熟悉 ASM API 和字节码的生成方式，可以先用 Java 编写想要转换的代码，然后使用一个 IDEA 插件 <a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline">ASM Bytecode Outline</a>，转换 Java 代码到 ASM 代码。</p><p>以如下 Java 代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getAllRoutes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 ASM Bytecode Outline 插件转换的 ASMified 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">&quot;getAllRoutes&quot;</span>, <span class="string">&quot;()Ljava/util/List;&quot;</span>, <span class="string">&quot;()Ljava/util/List&lt;Ljava/lang/String;&gt;;&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    mv.visitCode();</span><br><span class="line">    Label l0 = <span class="keyword">new</span> Label();</span><br><span class="line">    mv.visitLabel(l0);</span><br><span class="line">    mv.visitLineNumber(<span class="number">10</span>, l0);</span><br><span class="line">    mv.visitTypeInsn(NEW, <span class="string">&quot;java/util/ArrayList&quot;</span>);</span><br><span class="line">    mv.visitInsn(DUP);</span><br><span class="line">    mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/util/ArrayList&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br><span class="line">    Label l1 = <span class="keyword">new</span> Label();</span><br><span class="line">    mv.visitLabel(l1);</span><br><span class="line">    mv.visitLineNumber(<span class="number">11</span>, l1);</span><br><span class="line">    mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">    mv.visitInsn(ARETURN);</span><br><span class="line">    Label l2 = <span class="keyword">new</span> Label();</span><br><span class="line">    mv.visitLabel(l2);</span><br><span class="line">    mv.visitLocalVariable(<span class="string">&quot;list&quot;</span>, <span class="string">&quot;Ljava/util/List;&quot;</span>, <span class="string">&quot;Ljava/util/List&lt;Ljava/lang/String;&gt;;&quot;</span>, l1, l2, <span class="number">0</span>);</span><br><span class="line">    mv.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    mv.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要生成 Java 代码对应的 .class 字节码时，使用 ClassWriter 写入 ASMified 得到的代码，最后将 ClassWriter 转换成字节数组，并作为输入流写入文件即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改注册类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">modifyRegisterByte</span><span class="params">(ins: <span class="type">InputStream</span>)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> cw = ClassWriter(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> cr = ClassReader(ins)</span><br><span class="line">    <span class="keyword">val</span> cn = ClassNode()</span><br><span class="line">    cr.accept(cn, <span class="number">0</span>)</span><br><span class="line">    cn.methods.removeIf &#123; it.name == <span class="string">&quot;getAllRoutes&quot;</span> &amp;&amp; <span class="string">&quot;()Ljava/util/List;&quot;</span> == it.desc &#125;</span><br><span class="line">    <span class="keyword">val</span> mv = cn.visitMethod(</span><br><span class="line">        ACC_PUBLIC + ACC_STATIC,</span><br><span class="line">        <span class="string">&quot;getAllRoutes&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/util/List;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/util/List&lt;Ljava/lang/String;&gt;;&quot;</span>,</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    )</span><br><span class="line">    with(mv) &#123;</span><br><span class="line">        <span class="keyword">val</span> labels = arrayListOf&lt;Label&gt;()</span><br><span class="line">        visitCode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> label = Label()</span><br><span class="line">        visitLabel(label)</span><br><span class="line">        visitTypeInsn(NEW, <span class="string">&quot;java/util/ArrayList&quot;</span>)</span><br><span class="line">        visitInsn(DUP)</span><br><span class="line">        visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/util/ArrayList&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        visitVarInsn(ASTORE, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    cn.accept(cw)</span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改目标 class 文件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">modifyTargetClass</span><span class="params">(it: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果找到的目标文件是 .class 文件（对 ModuleRegister 来说，它是 .class 文件）</span></span><br><span class="line">    <span class="keyword">if</span> (it.name.endsWith(SdkConstants.DOT_CLASS)) &#123;</span><br><span class="line">        <span class="keyword">val</span> rewrite = modifyRegisterByte((it.inputStream()))</span><br><span class="line">        FileOutputStream(it).write(rewrite)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-文件读写"><a href="#class-文件读写" class="headerlink" title="class 文件读写"></a>class 文件读写</h2><p>对 Transform API 而言，修改字节码有两种类型：</p><ol><li>直接修改文件夹的 .class 文件。对应 Transform 的 directoryInputs</li><li>修改 .jar 文件里面的 .class 文件。对应 Transform 的 jarInputs</li></ol><h3 id="修改文件夹的-class-字节码"><a href="#修改文件夹的-class-字节码" class="headerlink" title="修改文件夹的 .class 字节码"></a>修改文件夹的 .class 字节码</h3><p>如果修改 .class 文件，可以使用 FileInputStream 和 FileOutputStream。首先读取文件，然后将 ASM 转换的 ByteArray 写入到文件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRegisterTransform</span></span>(<span class="keyword">val</span> p: Project): DemoTransform() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">modifyTargetClass</span><span class="params">(it: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到的目标文件是 .class 文件</span></span><br><span class="line">        <span class="keyword">if</span> (it.name.endsWith(SdkConstants.DOT_CLASS)) &#123;</span><br><span class="line">            <span class="keyword">val</span> rewrite = modifyRegisterByte((it.inputStream()))</span><br><span class="line">            FileOutputStream(it).write(rewrite)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.name.endsWith(SdkConstants.DOT_JAR)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到的目标文件是 .jar 文件。dependencies &#123;&#125;、依赖的 android library 类型 module、</span></span><br><span class="line">            <span class="comment">// 每个 module 的 R 文件打包成的 jar，都属于 .jar 文件</span></span><br><span class="line">            ...   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-Jar-文件的-class-字节码"><a href="#修改-Jar-文件的-class-字节码" class="headerlink" title="修改 Jar 文件的 .class 字节码"></a>修改 Jar 文件的 .class 字节码</h3><p>如果修改的是 .jar 文件里面的 .class 文件。需要遍历 .jar 文件的每一个 JarEntry，如果发现目标的 .class 文件，就使用 putNextEntry 修改它的内容。</p><p>dealJarFile 用来处理 jar 文件。将参数的 JarFile 作为输出文件，将 JarFile 重命名为 bakJarFile 作为输入文件，遍历 bakJarFile 的每一个 JarEntry。如果发现 JarEntry 的名称和需要替换的类名相同，就使用 ASM 修改它的字节码，然后加以一个新的 JarEntry。否则将原有的 JarEntry 复制到 JarFile。</p><p>为了修改 JarEntry，可以提取一个 addZipEntry 方法。当需要修改字节码时，将 ASM 转换得到的 ByteArray 转换成 ByteArrayInputStream 作为 InputStream 输入；当不需要修改字节码，只复制 JarEntry 时，将 bakJarFile.getInputStream(jarEntry) 作为 InputStream 输入。</p><p>目标文件是 Jar 文件，而且发现 JarEntry 的名称和需要替换的类名相同：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoRegisterTransform</span></span>(<span class="keyword">val</span> p: Project): DemoTransform() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">modifyTargetClass</span><span class="params">(it: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到的目标文件是 .class 文件</span></span><br><span class="line">        <span class="keyword">if</span> (it.name.endsWith(SdkConstants.DOT_CLASS)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.name.endsWith(SdkConstants.DOT_JAR)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到的目标文件是 .jar 文件。dependencies &#123;&#125;、依赖的 android library 类型 module、</span></span><br><span class="line">            <span class="comment">// 每个 module 的 R 文件打包成的 jar，都属于 .jar 文件</span></span><br><span class="line">            ScanHelper.dealJarFile(it) &#123; jarEntry, jos, jarFile -&gt;</span><br><span class="line">                <span class="keyword">val</span> isRegisterClass = jarEntry.name == ScanConstants.AUTOREGISTER</span><br><span class="line">                <span class="keyword">if</span> (isRegisterClass) &#123;</span><br><span class="line">                    println(<span class="string">&quot;modifyTargetClass: isRegisterClass:<span class="subst">$&#123;isRegisterClass&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">val</span> inputStream = jarFile.getInputStream(jarEntry)</span><br><span class="line">                    <span class="keyword">val</span> byteArray = modifyRegisterByte(inputStream)</span><br><span class="line"><span class="comment">//                    jos.putNextEntry(JarEntry(jarEntry.name))</span></span><br><span class="line"><span class="comment">//                    jos.write(byteArray)</span></span><br><span class="line">                    ScanHelper.addZipEntry(jos, JarEntry(jarEntry.name), ByteArrayInputStream(</span><br><span class="line">                        byteArray</span><br><span class="line">                    ))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;NOT register class:<span class="subst">$&#123;jarEntry.name&#125;</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                isRegisterClass</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标文件是 Jar 文件，而且发现 JarEntry 的名称和需要替换的类名不同：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ScanHelper &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dealJarFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        jarFile: <span class="type">File</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        callback: (<span class="type">jarEntry</span>: <span class="type">JarEntry</span>, <span class="type">jos</span>: <span class="type">JarOutputStream</span>, <span class="type">jarFile</span>: <span class="type">JarFile</span>) -&gt; <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> jarAbsolutePath = jarFile.absolutePath</span><br><span class="line">        <span class="keyword">val</span> bakFilePath = jarAbsolutePath.substring(<span class="number">0</span>, jarAbsolutePath.length - <span class="number">4</span>) + <span class="string">&quot;-&quot;</span> +</span><br><span class="line">                System.currentTimeMillis() + SdkConstants.DOT_JAR</span><br><span class="line">        println(<span class="string">&quot;jar absolute path: <span class="subst">$&#123;jarAbsolutePath&#125;</span>, bak file path:<span class="subst">$&#123;bakFilePath&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> bakFile = File(bakFilePath)</span><br><span class="line">        <span class="comment">// JarFile 不是 File 的子类，需要将原始 JarFile(build/javac)，重命名为带时间戳的新 jar。</span></span><br><span class="line">        <span class="comment">// 原有的 jarFile 在磁盘上不再存在</span></span><br><span class="line">        jarFile.renameTo(bakFile)</span><br><span class="line">        <span class="comment">// 获取备份的jar</span></span><br><span class="line">        <span class="keyword">val</span> bakJarFile = JarFile(bakFilePath)</span><br><span class="line">        <span class="keyword">val</span> jos = JarOutputStream(FileOutputStream(jarFile))</span><br><span class="line">        <span class="keyword">for</span> (jarEntry <span class="keyword">in</span> bakJarFile.entries()) &#123;</span><br><span class="line">            println(<span class="string">&quot;name:<span class="subst">$&#123;jarEntry.name&#125;</span>, size:<span class="subst">$&#123;jarEntry.size&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// 只有找到了目标 class 的情况下才在 callback 方法添加 ZipEntry</span></span><br><span class="line">            <span class="comment">// 否则在这里的 JarOutputStream 添加 ZipEntry</span></span><br><span class="line">            <span class="keyword">if</span> (!callback(jarEntry, jos, bakJarFile)) &#123;</span><br><span class="line">                println(<span class="string">&quot;putNextEntry:<span class="subst">$&#123;jarEntry.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> inputStream = bakJarFile.getInputStream(jarEntry)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> newZipEntry = ZipEntry(jarEntry.name)</span><br><span class="line"></span><br><span class="line">                addZipEntry(jos, newZipEntry, inputStream)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        with(jos) &#123;</span><br><span class="line">            flush()</span><br><span class="line">            finish()</span><br><span class="line">            close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 jarFile</span></span><br><span class="line">        bakJarFile.close()</span><br><span class="line">        <span class="comment">// 删除备份文件</span></span><br><span class="line">        bakFile.delete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addZipEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        jos: <span class="type">JarOutputStream</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        zipEntry: <span class="type">ZipEntry</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        inputStream: <span class="type">InputStream</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        jos.putNextEntry(zipEntry)</span><br><span class="line">        <span class="keyword">val</span> buffer = ByteArray(<span class="number">16384</span>)</span><br><span class="line">        <span class="keyword">var</span> length: <span class="built_in">Int</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            length = inputStream.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (length == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            jos.write(buffer, <span class="number">0</span>, length)</span><br><span class="line">            jos.flush()</span><br><span class="line">        &#125; <span class="keyword">while</span> (length != -<span class="number">1</span>);</span><br><span class="line">        inputStream.close()</span><br><span class="line">        jos.closeEntry()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.wanandroid.com/wenda/show/15215">每日一问 | 玩转 Gradle，可不能不熟悉 Transform，那么，我要开始问了。</a></p><p><a href="https://yutiantina.github.io/2019/04/24/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3TransformApi/">深入了解TransformApi</a></p><p><a href="https://github.com/YuTianTina/TransformDemo">TransformDemo</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter-ASM">Chapter-ASM</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Gradle-Android-Transform-API-编译修改-class&quot;&gt;&lt;a href=&quot;#Gradle-Android-Transform-API-编译修改-class&quot; class=&quot;headerlink&quot; title=&quot;Gradle Android</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="Gradle" scheme="https://www.okclouder.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Gradle 版本参数优化</title>
    <link href="https://www.okclouder.cn/2020/10/28/android-gradle-version-optimization/"/>
    <id>https://www.okclouder.cn/2020/10/28/android-gradle-version-optimization/</id>
    <published>2020-10-28T05:02:33.000Z</published>
    <updated>2020-12-08T15:46:39.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Gradle-版本参数优化"><a href="#Android-Gradle-版本参数优化" class="headerlink" title="Android Gradle 版本参数优化"></a>Android Gradle 版本参数优化</h1><p>在 Gradle 项目结构中，每一个 Module 都对应一个 build.gradle。有时每个 Module 都会需要配置相同的版本号或者相同的版本依赖。为了解决相同参数重复配置的问题，可以在项目的根目录下增加一个公用的配置文件 common_config.gradle，在公用配置文件提供 Android app 模块、Android library 模块、java library 模块的公用配置。</p><h2 id="common-config-gradle"><a href="#common-config-gradle" class="headerlink" title="common_config.gradle"></a>common_config.gradle</h2><p>每一个模块的 build.gradle 都对应一个 project 对象，可以将 project 传递给 common_config 定义的 setAppDefaultConfig 闭包，从而实现参数配置。common_config.gradle 可以根据具体情况修改，如果项目不使用 kotlin，可以在 common_config 去掉 kotlin 依赖。</p><p>common_config.gradle 如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>.ext &#123;</span><br><span class="line"></span><br><span class="line">    versions = [</span><br><span class="line">            <span class="string">&quot;compileSdkVersion&quot;</span>: <span class="number">29</span>,</span><br><span class="line">            <span class="string">&quot;buildToolsVersion&quot;</span>: <span class="string">&quot;29.0.3&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;minSdkVersion&quot;</span>    : <span class="number">19</span>,</span><br><span class="line">            <span class="string">&quot;targetSdkVersion&quot;</span> : <span class="number">29</span>,</span><br><span class="line">            <span class="string">&quot;versionCode&quot;</span>      : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;versionName&quot;</span>      : <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;junit&quot;</span>: <span class="string">&quot;4.13&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;kotlin&quot;</span>: <span class="string">&quot;1.3.72&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependencieLibs = [</span><br><span class="line">            <span class="string">&quot;appcompat&quot;</span>         : <span class="string">&quot;androidx.appcompat:appcompat:1.1.0&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// kotlin</span></span><br><span class="line">            <span class="string">&quot;kotlin-stdlib-jdk7&quot;</span>: <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$&#123;versions[&quot;</span>kotlin<span class="string">&quot;]&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;kotlin-reflect&quot;</span>    : <span class="string">&quot;org.jetbrains.kotlin:kotlin-reflect:$&#123;versions[&quot;</span>kotlin<span class="string">&quot;]&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// test</span></span><br><span class="line">            <span class="string">&quot;junit&quot;</span>             : <span class="string">&quot;junit:junit:$&#123;versions[&quot;</span>junit<span class="string">&quot;]&#125;&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    setAppDefaultConfig = &#123; extension -&gt;</span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">        extension.<span class="keyword">description</span> <span class="string">&#x27;app&#x27;</span></span><br><span class="line"></span><br><span class="line">        setAndroidConfig extension.android</span><br><span class="line"></span><br><span class="line">        setDependencies extension.<span class="keyword">dependencies</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setLibDefaultConfig = &#123; extension -&gt;</span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">        extension.<span class="keyword">description</span> <span class="string">&#x27;lib&#x27;</span></span><br><span class="line"></span><br><span class="line">        setAndroidConfig extension.android</span><br><span class="line"></span><br><span class="line">        setDependencies extension.<span class="keyword">dependencies</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setJavaLibDefaultConfig = &#123; extension -&gt;</span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line">        extension.apply plugin: <span class="string">&#x27;kotlin&#x27;</span></span><br><span class="line">        extension.<span class="keyword">description</span> <span class="string">&#x27;javalib&#x27;</span></span><br><span class="line"></span><br><span class="line">        setDependencies extension.<span class="keyword">dependencies</span></span><br><span class="line"></span><br><span class="line">        extension.<span class="keyword">sourceCompatibility</span> = JavaVersion.VERSION_1_8</span><br><span class="line">        extension.<span class="keyword">targetCompatibility</span> = JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setAndroidConfig = &#123; extension -&gt;</span><br><span class="line">        extension.compileSdkVersion versions[<span class="string">&#x27;compileSdkVersion&#x27;</span>]</span><br><span class="line">        extension.buildToolsVersion versions[<span class="string">&#x27;buildToolsVersion&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        extension.defaultConfig &#123;</span><br><span class="line">            minSdkVersion versions[<span class="string">&#x27;minSdkVersion&#x27;</span>]</span><br><span class="line">            targetSdkVersion versions[<span class="string">&#x27;targetSdkVersion&#x27;</span>]</span><br><span class="line">            versionCode versions[<span class="string">&#x27;versionCode&#x27;</span>]</span><br><span class="line">            versionName versions[<span class="string">&#x27;versionName&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        extension.compileOptions &#123;</span><br><span class="line">            <span class="keyword">targetCompatibility</span> = JavaVersion.VERSION_1_8</span><br><span class="line">            <span class="keyword">sourceCompatibility</span> = JavaVersion.VERSION_1_8</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        extension.kotlinOptions &#123;</span><br><span class="line">            jvmTarget = JavaVersion.VERSION_1_8</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setDependencies = &#123; extension -&gt;</span><br><span class="line">        extension.implementation <span class="keyword">fileTree</span>(<span class="keyword">include</span>: [<span class="string">&#x27;*.jar&#x27;</span>], dir: <span class="string">&#x27;libs&#x27;</span>)</span><br><span class="line">        extension.implementation dependencieLibs[<span class="string">&#x27;kotlin-stdlib-jdk7&#x27;</span>]</span><br><span class="line">        extension.implementation dependencieLibs[<span class="string">&#x27;appcompat&#x27;</span>]</span><br><span class="line">        extension.testImplementation dependencieLibs[<span class="string">&#x27;junit&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><h3 id="versions"><a href="#versions" class="headerlink" title="versions"></a>versions</h3><p>版本号定义</p><h3 id="dependencieLibs"><a href="#dependencieLibs" class="headerlink" title="dependencieLibs"></a>dependencieLibs</h3><p>所有模块都用到的公有依赖</p><h3 id="setAppDefaultConfig"><a href="#setAppDefaultConfig" class="headerlink" title="setAppDefaultConfig"></a>setAppDefaultConfig</h3><p>Android application 模块的配置闭包</p><h3 id="setLibDefaultConfig"><a href="#setLibDefaultConfig" class="headerlink" title="setLibDefaultConfig"></a>setLibDefaultConfig</h3><p>Android library 模块的配置闭包</p><h3 id="setJavaLibDefaultConfig"><a href="#setJavaLibDefaultConfig" class="headerlink" title="setJavaLibDefaultConfig"></a>setJavaLibDefaultConfig</h3><p>Java library 模块的配置闭包</p><h3 id="setAndroidConfig"><a href="#setAndroidConfig" class="headerlink" title="setAndroidConfig"></a>setAndroidConfig</h3><p>android 的 配置闭包，也就是 build.gradle 的 android {} 配置</p><h3 id="setDependencies"><a href="#setDependencies" class="headerlink" title="setDependencies"></a>setDependencies</h3><p>依赖的配置闭包，也就是 dependencies {} 配置</p><h2 id="专有配置"><a href="#专有配置" class="headerlink" title="专有配置"></a>专有配置</h2><p>如果某个模块除了公有配置之外，还有它自己所需的依赖，可以在 setAppDefaultConfig 之后添加专有的 dependencies {} 依赖。</p><p>app 模块的 build.gradle 如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">&quot;$&#123;rootProject.rootDir&#125;/common_config.gradle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>.ext.setAppDefaultConfig <span class="keyword">project</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-Gradle-版本参数优化&quot;&gt;&lt;a href=&quot;#Android-Gradle-版本参数优化&quot; class=&quot;headerlink&quot; title=&quot;Android Gradle 版本参数优化&quot;&gt;&lt;/a&gt;Android Gradle 版本参数优化&lt;/</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="Gradle" scheme="https://www.okclouder.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Proguard 混淆</title>
    <link href="https://www.okclouder.cn/2020/09/07/android-proguard/"/>
    <id>https://www.okclouder.cn/2020/09/07/android-proguard/</id>
    <published>2020-09-07T11:46:23.000Z</published>
    <updated>2020-12-08T15:46:39.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Proguard-混淆"><a href="#Android-Proguard-混淆" class="headerlink" title="Android Proguard 混淆"></a>Android Proguard 混淆</h1><p>Android 项目可以在 build.gradle 开启 proguard 代码混淆。</p><h2 id="开启混淆的好处"><a href="#开启混淆的好处" class="headerlink" title="开启混淆的好处"></a>开启混淆的好处</h2><ol><li>降低代码的可读性，缩短类和成员的名称，使反编译后的代码不容易被其他人阅读或破解。比如 APP \ SDK 对外发布正式版本时，通常需要做代码混淆。</li><li>代码压缩。开启混淆后，项目中没有被任何地方执行到的代码会被 Proguard 优化，减少 APP\SDK 包体积。</li><li>资源压缩。开启混淆后，项目中没有被使用的图片、字符串、布局等资源会从项目中移出，减少 APP\SDK 包体积。</li></ol><h2 id="如何开启混淆"><a href="#如何开启混淆" class="headerlink" title="如何开启混淆"></a>如何开启混淆</h2><p>Android 项目可以在模块的 build.gradle 文件配置开启混淆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        minifyEnabled false</span><br><span class="line">        shrinkResources false</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>minifyEnabled true 表示开启混淆。shrinkResources 表示资源压缩。</p><p>需要注意的是 Library 项目无法使用 shrinkResources。shrinkResources 只能用于 APK 资源压缩。这可能是因为工具无法判断 Library 中的资源是否会被其他模块使用到，所以只有在构建整个 APK 的时候才能知道哪些资源是无用资源，才可以启用资源压缩。</p><h2 id="编写-Proguard-混淆规则"><a href="#编写-Proguard-混淆规则" class="headerlink" title="编写 Proguard 混淆规则"></a>编写 Proguard 混淆规则</h2><p>混淆规则有 2 部分组成，Android SDK 自带的默认规则 proguard-android.txt 和项目自定义的 proguard-rules.pro。</p><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><p>项目自定义的 proguard-rules.pro。</p><p>不混淆四大组件和 Application，在 AndroidManifest.xml 注册的组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Application</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br></pre></td></tr></table></figure><p>不混淆 ww 目录下的所有类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class xx.yy.zz.ww.* &#123;*;&#125;</span><br></pre></td></tr></table></figure><p>不混淆 ww 目录下的所有子目录和类，循环子目录下的所有内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class xx.yy.zz.ww.** &#123;*;&#125;</span><br></pre></td></tr></table></figure><p>不混淆 AA 类的名称，但是混淆 AA 类的成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class xx.yy.zz.ww.AA</span><br></pre></td></tr></table></figure><p>不混淆 AA 类的名称和成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep public class xx.yy.zz.ww.AA &#123;*;&#125;</span><br></pre></td></tr></table></figure><p>不混淆 AA 类的某个 public 方法，可能被反射调用或者被 Native 代码回调的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep class xx.yy.zz.ww.AA &#123;</span><br><span class="line">    public void callbackByNavtiveMethodXXXX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不混淆 Serializable 子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers class * implements java.io.Serializable &#123;</span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">    public &lt;fields&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><p>系统默认的 proguard-android.txt，位于 $ANDROID_HOME\tools\proguard\proguard-android.txt。在 Android Gradle Plugin (AGP)2.2 以上版本会使用编译期间生成的 proguard-android.txt，比如 build\intermediates\proguard-files\proguard-android.txt-3.3.2，而不是 SDK 里面的 proguard-android.txt。</p><p>proguard-android.txt-3.3.2 的规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"># This is a configuration file for ProGuard.</span><br><span class="line"># http:&#x2F;&#x2F;proguard.sourceforge.net&#x2F;index.html#manual&#x2F;usage.html</span><br><span class="line">#</span><br><span class="line"># Starting with version 2.2 of the Android plugin for Gradle, this file is distributed together with</span><br><span class="line"># the plugin and unpacked at build-time. The files in $ANDROID_HOME are no longer maintained and</span><br><span class="line"># will be ignored by new version of the Android plugin for Gradle.</span><br><span class="line"></span><br><span class="line"># Optimization is turned off by default. Dex does not like code run</span><br><span class="line"># through the ProGuard optimize steps (and performs some</span><br><span class="line"># of these optimizations on its own).</span><br><span class="line"># Note that if you want to enable optimization, you cannot just</span><br><span class="line"># include optimization flags in your own project configuration file;</span><br><span class="line"># instead you will need to point to the</span><br><span class="line"># &quot;proguard-android-optimize.txt&quot; file instead of this one from your</span><br><span class="line"># project.properties file.</span><br><span class="line"># 不启用优化</span><br><span class="line">-dontoptimize</span><br><span class="line"># 混淆时不使用大小写混写的类名</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"># 不跳过库中非 public 的类</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"># 打印处理日志</span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line"># Preserve some attributes that may be required for reflection.</span><br><span class="line"># 保留注解、泛型、内部类、封闭方法</span><br><span class="line">-keepattributes *Annotation*,Signature,InnerClasses,EnclosingMethod</span><br><span class="line"># 不混淆指定的类</span><br><span class="line">-keep public class com.google.vending.licensing.ILicensingService</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br><span class="line">-keep public class com.google.android.vending.licensing.ILicensingService</span><br><span class="line"># 不打印潜在的错误或者疏漏的注释</span><br><span class="line">-dontnote com.android.vending.licensing.ILicensingService</span><br><span class="line">-dontnote com.google.vending.licensing.ILicensingService</span><br><span class="line">-dontnote com.google.android.vending.licensing.ILicensingService</span><br><span class="line"></span><br><span class="line"># For native methods, see http:&#x2F;&#x2F;proguard.sourceforge.net&#x2F;manual&#x2F;examples.html#native</span><br><span class="line"># 不混淆 Native 方法</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Keep setters in Views so that animations can still work.</span><br><span class="line"># 不混淆 View 子类的 set 和 get 方法</span><br><span class="line">-keepclassmembers public class * extends android.view.View &#123;</span><br><span class="line">    void set*(***);</span><br><span class="line">    *** get*();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># We want to keep methods in Activity that could be used in the XML attribute onClick.</span><br><span class="line"># 不混淆 Activity 子类的参数为 View 的 public 方法</span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">    public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># For enumeration classes, see http:&#x2F;&#x2F;proguard.sourceforge.net&#x2F;manual&#x2F;examples.html#enumerations</span><br><span class="line"># 不混淆枚举类的 values 和 valueOf 方法</span><br><span class="line">-keepclassmembers enum * &#123;</span><br><span class="line">    public static **[] values();</span><br><span class="line">    public static ** valueOf(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"># 不混淆 Parceable 子类的 CREATOR 常量</span><br><span class="line">-keepclassmembers class * implements android.os.Parcelable &#123;</span><br><span class="line">    public static final ** CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"># 不混淆 R 类的所有 public static 成员</span><br><span class="line">-keepclassmembers class **.R$* &#123;</span><br><span class="line">    public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Preserve annotated Javascript interface methods.</span><br><span class="line"># 不混淆 JavascriptInterface 注解的方法</span><br><span class="line">-keepclassmembers class * &#123;</span><br><span class="line">    @android.webkit.JavascriptInterface &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># The support libraries contains references to newer platform versions.</span><br><span class="line"># Don&#39;t warn about those in case this app is linking against an older</span><br><span class="line"># platform version. We know about them, and they are safe.</span><br><span class="line"># 不要警告 support 和 androidx 的报错</span><br><span class="line">-dontnote android.support.**</span><br><span class="line">-dontnote androidx.**</span><br><span class="line">-dontwarn android.support.**</span><br><span class="line">-dontwarn androidx.**</span><br><span class="line"></span><br><span class="line"># This class is deprecated, but remains for backward compatibility.</span><br><span class="line"># 不要警告 FloatMath 的报错</span><br><span class="line">-dontwarn android.util.FloatMath</span><br><span class="line"></span><br><span class="line"># Understand the @Keep support annotation.</span><br><span class="line"># 不混淆 @Keep 注解的类、成员</span><br><span class="line">-keep class android.support.annotation.Keep</span><br><span class="line">-keep class androidx.annotation.Keep</span><br><span class="line"></span><br><span class="line">-keep @android.support.annotation.Keep class * &#123;*;&#125;</span><br><span class="line">-keep @androidx.annotation.Keep class * &#123;*;&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @android.support.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    @androidx.annotation.Keep &lt;init&gt;(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># These classes are duplicated between android.jar and org.apache.http.legacy.jar.</span><br><span class="line"># 不警告 org.apache.http 和 android.net.http</span><br><span class="line">-dontnote org.apache.http.**</span><br><span class="line">-dontnote android.net.http.**</span><br><span class="line"></span><br><span class="line"># These classes are duplicated between android.jar and core-lambda-stubs.jar.</span><br><span class="line"># 不警告 java.lang.invoke</span><br><span class="line">-dontnote java.lang.invoke.**</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://developer.android.com/studio/build/shrink-code">缩减、混淆处理和优化应用</a></li><li><a href="https://stackoverflow.com/questions/46219987/shrinkresources-true-cant-be-used-on-instant-apps-feature">shrinkResources true can’t be used on Instant Apps Feature?</a></li><li><a href="https://www.jianshu.com/p/69878ed712be">Android ProGuard 代码混淆那些事儿</a></li><li><a href="https://blog.csdn.net/chen930724/article/details/49687067">Android ProGuard 混淆 详解</a></li><li><a href="https://juejin.im/entry/6844903444826832904">Android 混淆从入门到精通</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-Proguard-混淆&quot;&gt;&lt;a href=&quot;#Android-Proguard-混淆&quot; class=&quot;headerlink&quot; title=&quot;Android Proguard 混淆&quot;&gt;&lt;/a&gt;Android Proguard 混淆&lt;/h1&gt;&lt;p&gt;An</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="Proguard" scheme="https://www.okclouder.cn/tags/Proguard/"/>
    
  </entry>
  
  <entry>
    <title>Android View 生成唯一 Id</title>
    <link href="https://www.okclouder.cn/2020/08/31/android-view-generates-unique-id/"/>
    <id>https://www.okclouder.cn/2020/08/31/android-view-generates-unique-id/</id>
    <published>2020-08-31T15:06:48.000Z</published>
    <updated>2020-12-08T15:46:39.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-View-生成唯一-Id"><a href="#Android-View-生成唯一-Id" class="headerlink" title="Android View 生成唯一 Id"></a>Android View 生成唯一 Id</h1><p>可以使用 Hook LayoutInflater 的方法替换 SystemService 原有的 LayoutInflater，在自定义的 LayoutInflater 遍历每一个 view，为它们生成 md5 作为 view 的唯一 id。</p><h2 id="Hook-LayoutInflater"><a href="#Hook-LayoutInflater" class="headerlink" title="Hook LayoutInflater"></a>Hook LayoutInflater</h2><p>Hook LayoutInflater 的核心在于使用反射调用 registerService 方法，注册自定义的 LayoutInflater。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflaterHook</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LayoutInflaterHook&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hookLayoutInflater</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; serviceFetcher = Class.forName(<span class="string">&quot;android.app.SystemServiceRegistry$ServiceFetcher&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 ServiceFetcher 的实例 serviceFetcherImpl</span></span><br><span class="line">        Object serviceFetcherImpl = Proxy.newProxyInstance(LayoutInflaterHook.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serviceFetcher&#125;,</span><br><span class="line">                <span class="keyword">new</span> ServiceFetcherHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SystemServiceRegistry 的 registerService 方法</span></span><br><span class="line">        Class&lt;?&gt; systemServiceRegistry = Class.forName(<span class="string">&quot;android.app.SystemServiceRegistry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无法反射调用 registerService，registerService 在 Android 10 版本以上都是 blacklist 级别的 api，</span></span><br><span class="line">        <span class="comment">// 反射调用会被系统拒绝，抛出 NoSuchMethodException。</span></span><br><span class="line">        Method registerService = systemServiceRegistry.getDeclaredMethod(<span class="string">&quot;registerService&quot;</span>,</span><br><span class="line">                String.class,</span><br><span class="line">                CustomLayoutInflater.class.getClass(),</span><br><span class="line">                serviceFetcher);</span><br><span class="line">        registerService.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 registerService 方法，将自定义的 CustomLayoutInflater 设置到 SystemServiceRegistry</span></span><br><span class="line">        registerService.invoke(systemServiceRegistry,</span><br><span class="line">                Context.LAYOUT_INFLATER_SERVICE, CustomLayoutInflater.class, serviceFetcherImpl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        Field systemServiceFetchers = systemServiceRegistry.getDeclaredField(<span class="string">&quot;SYSTEM_SERVICE_FETCHERS&quot;</span>);</span><br><span class="line">        systemServiceFetchers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Map systemServiceFetchersField = (Map) systemServiceFetchers.get(<span class="keyword">null</span>);</span><br><span class="line">        Set set = systemServiceFetchersField.keySet();</span><br><span class="line">        Object service = systemServiceFetchersField.get(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;find layout inflater:&quot;</span> + service);</span><br><span class="line">        <span class="keyword">for</span> (Object next : set) &#123;</span><br><span class="line">            Object value = systemServiceFetchersField.get(next);</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;key:&quot;</span> + next);</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">            <span class="keyword">if</span> (Context.LAYOUT_INFLATER_SERVICE.equals(next)) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;find Service for layout inflater:&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态代理-ServiceFetcher"><a href="#动态代理-ServiceFetcher" class="headerlink" title="动态代理 ServiceFetcher"></a>动态代理 ServiceFetcher</h2><p>因为 ServiceFetcher 是 SystemServiceRegistry 的内部借口，因此需要使用动态代理的方式实现它的 invoke 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFetcherHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 当调用 ServiceFetcherImpl 的 getService 的时候，会返回自定义的 LayoutInflater</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ServiceFetcherHandler&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutInflater((Context) args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-LayoutInflater"><a href="#自定义-LayoutInflater" class="headerlink" title="自定义 LayoutInflater"></a>自定义 LayoutInflater</h2><p>当调用 getService 时，会返回自定义的 CustomLayoutInflater。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLayoutInflater</span> <span class="keyword">extends</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">            <span class="string">&quot;android.widget.&quot;</span>,</span><br><span class="line">            <span class="string">&quot;android.webkit.&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> VIEW_TAG = <span class="number">0x10000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomLayoutInflater</span><span class="params">(LayoutInflater original, Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(original, newContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                View view = createView(name, prefix, attrs);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomLayoutInflater(<span class="keyword">this</span>, newContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(<span class="keyword">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">        View viewGroup = <span class="keyword">super</span>.inflate(resource, root, attachToRoot);</span><br><span class="line">        View rootView = viewGroup;</span><br><span class="line">        View tempView = viewGroup;</span><br><span class="line">        <span class="comment">// 向上遍历得到根 View</span></span><br><span class="line">        <span class="keyword">while</span> (tempView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rootView = viewGroup;</span><br><span class="line">            tempView = ((ViewGroup) tempView.getParent());</span><br><span class="line">        &#125;</span><br><span class="line">        traversalViewGroup(rootView);</span><br><span class="line">        <span class="keyword">return</span> viewGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversalViewGroup</span><span class="params">(View rootView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rootView == <span class="keyword">null</span> || !(rootView <span class="keyword">instanceof</span> ViewGroup)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 rootView 没有 tag，设置它的 view 值为 VIEW_TAG 计数值</span></span><br><span class="line">        <span class="keyword">if</span> (rootView.getTag() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rootView.setTag(getViewTag());</span><br><span class="line">        &#125;</span><br><span class="line">        ViewGroup viewGroup = (ViewGroup) rootView;</span><br><span class="line">        <span class="keyword">int</span> childCount = ((ViewGroup) rootView).getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; ++i) &#123;</span><br><span class="line">            View childView = viewGroup.getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (childView.getTag() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                childView.setTag(combineTag(getViewTag(), rootView.getTag().toString()));</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;Hooker&quot;</span>, <span class="string">&quot;childView name=&quot;</span> + childView.getClass().getName()</span><br><span class="line">                    + <span class="string">&quot;, id = &quot;</span> + childView.getTag().toString());</span><br><span class="line">            <span class="keyword">if</span> (childView <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                <span class="comment">// 深度优先遍历</span></span><br><span class="line">                traversalViewGroup(childView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">combineTag</span><span class="params">(String tag1, String tag2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMd5(getMd5(tag1) + getMd5(tag2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getViewTag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(VIEW_TAG++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMd5</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            md5.update(str.getBytes());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="number">1</span>, md5.digest()).toString(<span class="number">16</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过组合父 view 和自身 view 的 md5 得到唯一的 view id。</p><h2 id="Android-黑名单的限制"><a href="#Android-黑名单的限制" class="headerlink" title="Android 黑名单的限制"></a>Android 黑名单的限制</h2><p>从 Android 9 开始，Android 系统限制了部分 System api 的调用。Hook LayoutInflater 用到的 registerService 方法就被列入了黑名单，反射调用直接抛出 NoSuchMethodException。因此 Hook LayoutInflater 的方法实际不可用，但是可以通过修改系统设置本地调试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell settings put global hidden_api_policy  1</span><br></pre></td></tr></table></figure><p>关于在 Android 10 中授予对非 SDK 接口的访问权限，可以查看 <a href="https://developer.android.google.cn/about/versions/10/non-sdk-q#enable-non-sdk-access">Android 10 中有关限制非 SDK 接口的更新</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/caoshen/AndroidEfficientAdvanced">https://github.com/caoshen/AndroidEfficientAdvanced</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-View-生成唯一-Id&quot;&gt;&lt;a href=&quot;#Android-View-生成唯一-Id&quot; class=&quot;headerlink&quot; title=&quot;Android View 生成唯一 Id&quot;&gt;&lt;/a&gt;Android View 生成唯一 Id&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="https://www.okclouder.cn/categories/Android/"/>
    
    
    <category term="View" scheme="https://www.okclouder.cn/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="https://www.okclouder.cn/2020/06/20/regular-expression-matching/"/>
    <id>https://www.okclouder.cn/2020/06/20/regular-expression-matching/</id>
    <published>2020-06-20T13:36:40.000Z</published>
    <updated>2020-12-08T15:46:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;.&#39; 匹配任意单个字符</span><br><span class="line">&#39;*&#39; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>说明:</p><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为形如 .* 的字符串可以匹配无数类型的字符串，所以使用动态规划的方法，通过上一段字符串的匹配情况推导出当前字符串是否能匹配。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenSrc = s.length();</span><br><span class="line">        <span class="keyword">int</span> lenPattern = p.length();</span><br><span class="line">        <span class="comment">// 注意这里的状态方程保存了 (lenSrc + 1) * (lenPatth + 1)种，因为需要考虑空字符串的比较</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[lenSrc + <span class="number">1</span>][lenPattern + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 两个空字符串是匹配的</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算两个字符串在各个位置的状态。</span></span><br><span class="line">        <span class="comment">// 需要考虑源字符串为空串，而正则字符串不为空的场景，所以 i 从 0 开始。</span></span><br><span class="line">        <span class="comment">// 而源字符串不为空，但是正则字符串为空，这种场景是匹配不上的，属于无效状态，所以 j 从 1 开始。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lenSrc; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenPattern; ++j) &#123;</span><br><span class="line">                <span class="comment">// p[j] 是一个字母</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 比较 p 和 s 最后一个字符</span></span><br><span class="line">                    <span class="keyword">if</span> (isCharMatch(s, p, i, j)) &#123;</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// p[j] 是 *</span></span><br><span class="line">                    <span class="comment">// 假设 p[j - 1] 是 a，可以把 * 算作 0 次字符，那么 p[j - 1 : j] 变为空串，只需比较 p[j - 2]</span></span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 如果 s[i] == p[j - 1]，可以在 i 维度上进一步动态规划。假设 s[i] = a，p[j - 1] = a，p[j -2] = *，那么 a* 可以匹配无数个 a(a..a)，既然 s[i] == p[j - 1]，可以进一步匹配 s[i - 1] 和 p[j - 1]，依次向前类推。</span></span><br><span class="line">                    <span class="keyword">if</span> (isCharMatch(s, p, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 在 f[i][j] 是 false 的情况下，进一步考察 f[i - 1][j] 是否为 true。</span></span><br><span class="line">                        f[i][j] = f[i][j] || f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[lenSrc][lenPattern];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCharMatch</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// s 是空串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式匹配&quot;&gt;&lt;a href=&quot;#正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;正则表达式匹配&quot;&gt;&lt;/a&gt;正则表达式匹配&lt;/h1&gt;&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙 II</title>
    <link href="https://www.okclouder.cn/2020/06/15/word-solitaire-2/"/>
    <id>https://www.okclouder.cn/2020/06/15/word-solitaire-2/</id>
    <published>2020-06-14T16:26:57.000Z</published>
    <updated>2020-12-08T15:46:39.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词接龙-II"><a href="#单词接龙-II" class="headerlink" title="单词接龙 II"></a>单词接龙 II</h1><p>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换后得到的单词必须是字典中的单词。<br>说明:</p><p>如果不存在这样的转换序列，返回一个空列表。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。<br>示例 1:</p><p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>输出:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br>示例 2:</p><p>输入:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p>输出: []</p><p>解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-ladder-ii">https://leetcode-cn.com/problems/word-ladder-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>查找目标单词的过程实际上是一个图的广度优先搜索过程（BFS），如果一个单词可以由另外一个单词变换得到，那么把这个单词加入到备选路径中，然后将路径加入到 BFS 的队列。</p><p>可以将每个单词映射到一个 id，方便查找和构建图的边，将单词搜索转换为 id 搜索。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; idWord;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        wordId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        idWord = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="comment">// 初始化 word id map 和 id word list</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class="line">                wordId.put(word, id++);</span><br><span class="line">                idWord.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提前判断 endWord 在不在列表</span></span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入 beginWord 的 id，方便查找</span></span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(beginWord)) &#123;</span><br><span class="line">            wordId.put(beginWord, id++);</span><br><span class="line">            idWord.add(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化图的边</span></span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList[idWord.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; ++i) &#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; idWord.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (transformCheck(idWord.get(i), idWord.get(j))) &#123;</span><br><span class="line">                    edges[i].add(j);</span><br><span class="line">                    edges[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 beginWord 到每个 word 的花费 cost</span></span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[id];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id; ++i) &#123;</span><br><span class="line">            cost[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 起点 id</span></span><br><span class="line">        <span class="keyword">int</span> source = wordId.get(beginWord);</span><br><span class="line">        <span class="comment">// beginWord 的 cost 为 0</span></span><br><span class="line">        cost[source] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 目的 id</span></span><br><span class="line">        <span class="keyword">int</span> dest = wordId.get(endWord);</span><br><span class="line">        <span class="comment">// 输出的答案</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将起点加入队列</span></span><br><span class="line">        Queue&lt;ArrayList&lt;Integer&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; tmpBegin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmpBegin.add(source);</span><br><span class="line">        q.add(tmpBegin);</span><br><span class="line">        <span class="comment">// 开始 BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; now = q.poll();</span><br><span class="line">            <span class="comment">// 最近访问的点，也就是当前搜索路径上最靠前的点</span></span><br><span class="line">            <span class="keyword">int</span> last = now.get(now.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (last == dest) &#123;</span><br><span class="line">                <span class="comment">// 找到了终点</span></span><br><span class="line">                ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; now.size(); ++i) &#123;</span><br><span class="line">                    tmp.add(idWord.get(now.get(i)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把找到的路径加入到答案，然后继续查找剩余的可能路径。</span></span><br><span class="line">                res.add(tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 继续查找最近访问节点的每一条边，找到可以变换单词的路径</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[last].size(); ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edges[last].get(i);</span><br><span class="line">                    <span class="comment">// &lt;= 的作用在于把代价相同的其他路径也保存下来</span></span><br><span class="line">                    <span class="keyword">if</span> (cost[last] + <span class="number">1</span> &lt;= cost[to]) &#123;</span><br><span class="line">                        cost[to] = cost[last] + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 这里构造了一个新的节点，进入队列</span></span><br><span class="line">                        ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(now);</span><br><span class="line">                        <span class="comment">// 更新最近访问的点</span></span><br><span class="line">                        tmp.add(to);</span><br><span class="line">                        <span class="comment">// 把符合条件的路径加入队列</span></span><br><span class="line">                        q.add(tmp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否能够变换一个字母成为相同单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">transformCheck</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() &amp;&amp; diff &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">                ++diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单词接龙-II&quot;&gt;&lt;a href=&quot;#单词接龙-II&quot; class=&quot;headerlink&quot; title=&quot;单词接龙 II&quot;&gt;&lt;/a&gt;单词接龙 II&lt;/h1&gt;&lt;p&gt;给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 be</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://www.okclouder.cn/tags/%E5%9B%BE/"/>
    
    <category term="BFS" scheme="https://www.okclouder.cn/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Android 蓝牙 HFP 和 A2DP</title>
    <link href="https://www.okclouder.cn/2020/06/02/android-bluetooth-hfp-and-a2dp/"/>
    <id>https://www.okclouder.cn/2020/06/02/android-bluetooth-hfp-and-a2dp/</id>
    <published>2020-06-01T16:12:26.000Z</published>
    <updated>2020-12-08T15:46:39.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-蓝牙-HFP-和-A2DP"><a href="#Android-蓝牙-HFP-和-A2DP" class="headerlink" title="Android 蓝牙 HFP 和 A2DP"></a>Android 蓝牙 HFP 和 A2DP</h1><p>HFP（Hands Free Profile）和 A2DP (Advanced Audio Distribution Profile) 是经典蓝牙常用的两个协议。</p><p>HFP 协议一般用来支持耳机打电话、接电话、挂断电话、拒接电话等操作。</p><p>A2DP 协议一般用来听歌，传输音频立体声。</p><h2 id="ProfileProxy"><a href="#ProfileProxy" class="headerlink" title="ProfileProxy"></a>ProfileProxy</h2><p>Android SDK 使用 BluetoothAdapter 的 getProfileProxy 获取每个具体的 Profile。</p><p>获取 HFP：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getHfpProfileProxy</span><span class="params">(Context context, BluetoothProfile.ServiceListener listener)</span> </span>&#123;</span><br><span class="line">    BluetoothAdapter defaultAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">    <span class="keyword">boolean</span> hfp = defaultAdapter.getProfileProxy(context, listener, BluetoothProfile.HEADSET);</span><br><span class="line">    <span class="keyword">return</span> hfp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 A2DP：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getA2dpProfileProxy</span><span class="params">(Context context, BluetoothProfile.ServiceListener listener)</span> </span>&#123;</span><br><span class="line">    BluetoothAdapter defaultAdapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">    <span class="keyword">boolean</span> profileProxy = defaultAdapter.getProfileProxy(context, listener, BluetoothProfile.A2DP);</span><br><span class="line">    <span class="keyword">return</span> profileProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HFP-连接"><a href="#HFP-连接" class="headerlink" title="HFP 连接"></a>HFP 连接</h2><p>通过反射调用 BluetoothHeadset 的 connect 方法连接 HFP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">connectHfp</span><span class="params">(BluetoothHeadset hfp, BluetoothDevice device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">    Method connect = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connect = BluetoothHeadset.class.getDeclaredMethod(<span class="string">&quot;connect&quot;</span>, BluetoothDevice.class);</span><br><span class="line">        connect.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ret = (<span class="keyword">boolean</span>) connect.invoke(hfp, device);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="A2DP-连接"><a href="#A2DP-连接" class="headerlink" title="A2DP 连接"></a>A2DP 连接</h2><p>通过反射调用 BluetoothA2dp 的 connect 方法连接 A2DP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">connectA2dp</span><span class="params">(BluetoothA2dp a2dp, BluetoothDevice device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">    Method connect = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connect = BluetoothA2dp.class.getDeclaredMethod(<span class="string">&quot;connect&quot;</span>, BluetoothDevice.class);</span><br><span class="line">        connect.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ret = (<span class="keyword">boolean</span>) connect.invoke(a2dp, device);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HFP-状态广播"><a href="#HFP-状态广播" class="headerlink" title="HFP 状态广播"></a>HFP 状态广播</h2><p>通过 BluetoothHeadset 的 ACTION_CONNECTION_STATE_CHANGED 监听 HFP 连接状态变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intent used to broadcast the change in connection state of the Headset</span></span><br><span class="line"><span class="comment"> * profile.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This intent will have 3 extras:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #EXTRA_STATE&#125; - The current state of the profile. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #EXTRA_PREVIOUS_STATE&#125;- The previous state of the profile. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> BluetoothDevice#EXTRA_DEVICE&#125; - The remote device. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@link</span> #EXTRA_STATE&#125; or &#123;<span class="doctag">@link</span> #EXTRA_PREVIOUS_STATE&#125; can be any of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #STATE_DISCONNECTED&#125;, &#123;<span class="doctag">@link</span> #STATE_CONNECTING&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #STATE_CONNECTED&#125;, &#123;<span class="doctag">@link</span> #STATE_DISCONNECTING&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Requires &#123;<span class="doctag">@link</span> android.Manifest.permission#BLUETOOTH&#125; permission to</span></span><br><span class="line"><span class="comment"> * receive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_CONNECTION_STATE_CHANGED =</span><br><span class="line">        <span class="string">&quot;android.bluetooth.headset.profile.action.CONNECTION_STATE_CHANGED&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="A2DP-状态广播"><a href="#A2DP-状态广播" class="headerlink" title="A2DP 状态广播"></a>A2DP 状态广播</h2><p>通过 BluetoothA2dp 的 ACTION_CONNECTION_STATE_CHANGED 监听 A2DP 连接状态变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intent used to broadcast the change in connection state of the A2DP</span></span><br><span class="line"><span class="comment"> * profile.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This intent will have 3 extras:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #EXTRA_STATE&#125; - The current state of the profile. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> #EXTRA_PREVIOUS_STATE&#125;- The previous state of the profile.&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; &#123;<span class="doctag">@link</span> BluetoothDevice#EXTRA_DEVICE&#125; - The remote device. &lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@link</span> #EXTRA_STATE&#125; or &#123;<span class="doctag">@link</span> #EXTRA_PREVIOUS_STATE&#125; can be any of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #STATE_DISCONNECTED&#125;, &#123;<span class="doctag">@link</span> #STATE_CONNECTING&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #STATE_CONNECTED&#125;, &#123;<span class="doctag">@link</span> #STATE_DISCONNECTING&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Requires &#123;<span class="doctag">@link</span> android.Manifest.permission#BLUETOOTH&#125; permission to</span></span><br><span class="line"><span class="comment"> * receive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_CONNECTION_STATE_CHANGED =</span><br><span class="line">        <span class="string">&quot;android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-蓝牙-HFP-和-A2DP&quot;&gt;&lt;a href=&quot;#Android-蓝牙-HFP-和-A2DP&quot; class=&quot;headerlink&quot; title=&quot;Android 蓝牙 HFP 和 A2DP&quot;&gt;&lt;/a&gt;Android 蓝牙 HFP 和 A2DP&lt;/</summary>
      
    
    
    
    <category term="蓝牙" scheme="https://www.okclouder.cn/categories/%E8%93%9D%E7%89%99/"/>
    
    
    <category term="蓝牙Profile" scheme="https://www.okclouder.cn/tags/%E8%93%9D%E7%89%99Profile/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://www.okclouder.cn/2020/05/25/lru-caching-mechanism/"/>
    <id>https://www.okclouder.cn/2020/05/25/lru-caching-mechanism/</id>
    <published>2020-05-25T15:49:10.000Z</published>
    <updated>2020-12-08T15:46:39.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>进阶:</p><p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache">https://leetcode-cn.com/problems/lru-cache</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用 LinkedHashMap 实现 LRU，LinkedHashMap 可以按照读取顺序或者写入顺序保存每个数据。注意初始化时选择 accessOrder，并且重写 removeEldestEntry 方法。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; mCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        mCache = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry entry)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCache.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        mCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LRU缓存机制&quot;&gt;&lt;a href=&quot;#LRU缓存机制&quot; class=&quot;headerlink&quot; title=&quot;LRU缓存机制&quot;&gt;&lt;/a&gt;LRU缓存机制&lt;/h1&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： </summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="https://www.okclouder.cn/2020/05/16/reverse-linked-list/"/>
    <id>https://www.okclouder.cn/2020/05/16/reverse-linked-list/</id>
    <published>2020-05-16T15:27:30.000Z</published>
    <updated>2020-12-08T15:46:39.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>注意：本题与主站 206 题相同：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用头插法将当前节点的下一个节点依次插入到头部。构造一个假头节点方便插入。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="comment">// 假头节点</span></span><br><span class="line">        ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        h.next = p;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点的下一个节点插入到链表头部</span></span><br><span class="line">            ListNode q = p.next;</span><br><span class="line">            p.next = q.next;</span><br><span class="line">            q.next = h.next;</span><br><span class="line">            h.next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h1&gt;&lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="链表" scheme="https://www.okclouder.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>和为K的子数组</title>
    <link href="https://www.okclouder.cn/2020/05/16/the-sub-array-of-k/"/>
    <id>https://www.okclouder.cn/2020/05/16/the-sub-array-of-k/</id>
    <published>2020-05-16T14:24:05.000Z</published>
    <updated>2020-12-08T15:46:39.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h1><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure><p>说明 :</p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以采用双重遍历的方式得到每一段数组的和，判断是不是等于目标值。</p><p>或者使用 Map 保存数组前缀和，以及前缀和出现的次数。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 顺序向后累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = i; start &lt; nums.length; ++start) &#123;</span><br><span class="line">                sum = sum + nums[start];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 倒序向前累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start = i; start &gt;= <span class="number">0</span>; --start) &#123;</span><br><span class="line">                sum = sum + nums[start];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存前缀和出现的次数</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; preSumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 前缀和为 0 出现的次数至少为 1，空数组的情况。</span></span><br><span class="line">        preSumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            preSum += n;</span><br><span class="line">            <span class="keyword">int</span> preSumStart = preSum - k;</span><br><span class="line">            <span class="keyword">if</span> (preSumMap.containsKey(preSumStart)) &#123;</span><br><span class="line">                count += preSumMap.get(preSumStart);</span><br><span class="line">            &#125;</span><br><span class="line">            preSumMap.put(preSum, preSumMap.getOrDefault(preSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;和为K的子数组&quot;&gt;&lt;a href=&quot;#和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;和为K的子数组&quot;&gt;&lt;/a&gt;和为K的子数组&lt;/h1&gt;&lt;p&gt;给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。&lt;/p&gt;
&lt;p&gt;示</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://www.okclouder.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="https://www.okclouder.cn/2020/05/14/nearest-common-ancestor-of-binary-tree/"/>
    <id>https://www.okclouder.cn/2020/05/14/nearest-common-ancestor-of-binary-tree/</id>
    <published>2020-05-14T15:53:00.000Z</published>
    <updated>2020-12-08T15:46:39.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉树中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用递归的方式分别判断左右子树是否存在两个目标节点。如果节点的左子树包含 p 而且右子树包含 q，或者节点自身等于 p 或 q 而且节点的子树包含 q 或 p，那么它就是最近公共祖先。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode ans = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> lson = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> rson = dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root.val == p.val) || (root.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉树的最近公共祖先&lt;/h1&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;p&gt;百度</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://www.okclouder.cn/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="https://www.okclouder.cn/2020/05/14/a-number-that-appears-only-once/"/>
    <id>https://www.okclouder.cn/2020/05/14/a-number-that-appears-only-once/</id>
    <published>2020-05-14T15:47:08.000Z</published>
    <updated>2020-12-08T15:46:39.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number">https://leetcode-cn.com/problems/single-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个数异或自己之后为 0，因此如果数组只有一个只出现一次的数，其他的数都出现两次，那么所有的数异或之后就是只出现一次的数。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            x = x ^ n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;只出现一次的数字&quot;&gt;&lt;a href=&quot;#只出现一次的数字&quot; class=&quot;headerlink&quot; title=&quot;只出现一次的数字&quot;&gt;&lt;/a&gt;只出现一次的数字&lt;/h1&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>另一个树的子树</title>
    <link href="https://www.okclouder.cn/2020/05/12/subtree-of-another-tree/"/>
    <id>https://www.okclouder.cn/2020/05/12/subtree-of-another-tree/</id>
    <published>2020-05-12T15:51:19.000Z</published>
    <updated>2020-12-08T15:46:39.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="另一个树的子树"><a href="#另一个树的子树" class="headerlink" title="另一个树的子树"></a>另一个树的子树</h1><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p>示例 1:</p><p>给定的树 s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><p>示例 2:</p><p>给定的树 s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 false。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree">https://leetcode-cn.com/problems/subtree-of-another-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规解法是暴力匹配原始树和目标树是否相同。但是这种方法时间复杂度高，因为需要依次比对两棵树上的所有节点。</p><p>另一种方法是将两棵树转化为字符串，然后判断是不是子字符串。参考 <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/</a></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>暴力匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSameTree(s, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSubtree(s.left, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSubtree(s.right, t)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode a, TreeNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> &amp;&amp; b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.val != b.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(a.left, b.left) &amp;&amp; isSameTree(a.right, b.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;另一个树的子树&quot;&gt;&lt;a href=&quot;#另一个树的子树&quot; class=&quot;headerlink&quot; title=&quot;另一个树的子树&quot;&gt;&lt;/a&gt;另一个树的子树&lt;/h1&gt;&lt;p&gt;给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://www.okclouder.cn/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数组中数字出现的次数</title>
    <link href="https://www.okclouder.cn/2020/05/04/occurrences-of-numbers-in-the-array/"/>
    <id>https://www.okclouder.cn/2020/05/04/occurrences-of-numbers-in-the-array/</id>
    <published>2020-05-04T08:24:09.000Z</published>
    <updated>2020-12-08T15:46:39.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h1><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><p>限制：</p><p>2 &lt;= nums &lt;= 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一种方法是使用 Set 保存已经存在的数，如果再次出现就把它从 Set 删除，留下只出现一次的数。</p><p>更好的方法是使用异或的思想。如果一个数字出现了两次，那么异或以后就是 0，最后剩下只出现一次的数的异或。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numSet.contains(n)) &#123;</span><br><span class="line">                numSet.remove(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                numSet.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : numSet) &#123;</span><br><span class="line">            result[i++] = n;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            xor ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找出只出现一次的两个数 a、b 的不相同的最低位。</span></span><br><span class="line">        <span class="keyword">while</span> ((d &amp; xor) == <span class="number">0</span>) &#123;</span><br><span class="line">            d &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据找到的最低位分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; d) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组中数字出现的次数&quot;&gt;&lt;a href=&quot;#数组中数字出现的次数&quot; class=&quot;headerlink&quot; title=&quot;数组中数字出现的次数&quot;&gt;&lt;/a&gt;数组中数字出现的次数&lt;/h1&gt;&lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="https://www.okclouder.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>CNAME 配置</title>
    <link href="https://www.okclouder.cn/2020/05/01/cname/"/>
    <id>https://www.okclouder.cn/2020/05/01/cname/</id>
    <published>2020-05-01T05:22:07.000Z</published>
    <updated>2020-12-08T15:46:39.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNAME-配置"><a href="#CNAME-配置" class="headerlink" title="CNAME 配置"></a>CNAME 配置</h1><h2 id="CNAME作用"><a href="#CNAME作用" class="headerlink" title="CNAME作用"></a>CNAME作用</h2><p>CNAME 即指别名记录，也被称为规范名字。这种记录允许将多个名字映射到同一台计算机。 当需要将域名指向另一个域名，再由另一个域名提供 ip地址，就需要添加 CNAME 记录。</p><p>CNAME会解析到另一个域名，之后再对另一个域名继续解析，直到解析出节点。</p><h2 id="域名网站添加域名解析"><a href="#域名网站添加域名解析" class="headerlink" title="域名网站添加域名解析"></a>域名网站添加域名解析</h2><p>以腾讯云为例，找到“云解析”，在“域名解析列表”添加CNAME记录。</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>线路类型</th><th>记录值</th><th>TTL（秒）</th></tr></thead><tbody><tr><td>xxx</td><td>CNAME</td><td>默认</td><td>xxx.github.io.</td><td>600</td></tr></tbody></table><p>等待解析生效后，xxx.yourdomain.com 就能解析到 xxx.github.io</p><p>注意记录值最后需要加上一个点</p><h2 id="在-github-pages-新建-CNAME-文件"><a href="#在-github-pages-新建-CNAME-文件" class="headerlink" title="在 github pages 新建 CNAME 文件"></a>在 github pages 新建 CNAME 文件</h2><p>新增 CNAME 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.yourdomain.com</span><br></pre></td></tr></table></figure><h2 id="Hexo-博客添加-CNAME"><a href="#Hexo-博客添加-CNAME" class="headerlink" title="Hexo 博客添加 CNAME"></a>Hexo 博客添加 CNAME</h2><p>Hexo 博客添加 CNAME 时，需要将 CNAME 文件放入 source 目录中。hexo g -d 部署后，CNAME 文件会被自动放入网站的根目录下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNAME-配置&quot;&gt;&lt;a href=&quot;#CNAME-配置&quot; class=&quot;headerlink&quot; title=&quot;CNAME 配置&quot;&gt;&lt;/a&gt;CNAME 配置&lt;/h1&gt;&lt;h2 id=&quot;CNAME作用&quot;&gt;&lt;a href=&quot;#CNAME作用&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://www.okclouder.cn/2020/04/27/search-rotated-sorted-array/"/>
    <id>https://www.okclouder.cn/2020/04/27/search-rotated-sorted-array/</id>
    <published>2020-04-27T14:42:54.000Z</published>
    <updated>2020-12-08T15:46:39.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">https://leetcode-cn.com/problems/search-in-rotated-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用二分查找，只不过要分为有序部分和无序部分。如果目标值在有序部分的左右两个边界值之中，那么可以继续在有序部分查找，否则在另一半查找。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">return</span> searchBinary(nums, <span class="number">0</span>, length - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchBinary</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="comment">// 左边升序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 可能在左边升序</span></span><br><span class="line">                <span class="keyword">return</span> searchBinary(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> searchBinary(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 左边旋转升序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                <span class="comment">// 可能在右边升序</span></span><br><span class="line">                <span class="keyword">return</span> searchBinary(nums, mid + <span class="number">1</span>, right, target);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> searchBinary(nums, left, mid - <span class="number">1</span>, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搜索旋转排序数组&quot;&gt;&lt;a href=&quot;#搜索旋转排序数组&quot; class=&quot;headerlink&quot; title=&quot;搜索旋转排序数组&quot;&gt;&lt;/a&gt;搜索旋转排序数组&lt;/h1&gt;&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计重复个数</title>
    <link href="https://www.okclouder.cn/2020/04/19/count-the-number-of-duplicates/"/>
    <id>https://www.okclouder.cn/2020/04/19/count-the-number-of-duplicates/</id>
    <published>2020-04-19T11:04:31.000Z</published>
    <updated>2020-12-08T15:46:39.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计重复个数"><a href="#统计重复个数" class="headerlink" title="统计重复个数"></a>统计重复个数</h1><p>由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcabcabc”。</p><p>如果我们可以从 s2 中删除某些字符使其变为 s1，则称字符串 s1 可以从字符串 s2 获得。例如，根据定义，”abc” 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。</p><p>现在给你两个非空字符串 s1 和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106 和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。</p><p>请你找出一个可以满足使[S2,M] 从 S1 获得的最大整数 M 。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">s1 &#x3D;&quot;acb&quot;,n1 &#x3D; 4</span><br><span class="line">s2 &#x3D;&quot;ab&quot;,n2 &#x3D; 2</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-the-repetitions">https://leetcode-cn.com/problems/count-the-repetitions</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑 s2 在 S1 中出现的循环节，然后根据循环节中出现的 s1 和 s2 的个数计算得到 s2 出现的总数，最后除以 n2 得到 S2 出现的次数。</p><p>建议参考官方题解：<a href="https://leetcode-cn.com/problems/count-the-repetitions/solution/tong-ji-zhong-fu-ge-shu-by-leetcode-solution/">https://leetcode-cn.com/problems/count-the-repetitions/solution/tong-ji-zhong-fu-ge-shu-by-leetcode-solution/</a></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxRepetitions</span><span class="params">(String s1, <span class="keyword">int</span> n1, String s2, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 寻找循环节过程中 s1 出现的个数</span></span><br><span class="line">        <span class="keyword">int</span> s1Count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找循环节过程中 s2 出现的个数</span></span><br><span class="line">        <span class="keyword">int</span> s2Count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// s2 的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存索引对应的 s1、s2 个数</span></span><br><span class="line">        HashMap&lt;Integer, <span class="keyword">int</span>[]&gt; recallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 循环开始前的头部</span></span><br><span class="line">        <span class="keyword">int</span>[] preLoop = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环节</span></span><br><span class="line">        <span class="keyword">int</span>[] inLoop = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试下一个 s1 匹配</span></span><br><span class="line">            s1Count++;</span><br><span class="line">            <span class="comment">// 遍历 s1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s1.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c == s2.charAt(index)) &#123;</span><br><span class="line">                    <span class="comment">// 匹配到 s2 的一个字符</span></span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="comment">// 完全匹配到 s2</span></span><br><span class="line">                    <span class="keyword">if</span> (index == s2.length()) &#123;</span><br><span class="line">                        s2Count++;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// S1 所有的 s1 都匹配完了，遍历完毕，返回 s2 的个数除以 s2 的乘数</span></span><br><span class="line">            <span class="keyword">if</span> (s1Count == n1) &#123;</span><br><span class="line">                <span class="keyword">return</span> s2Count / n2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现了之前的循环节，表示找到了 s2 循环</span></span><br><span class="line">            <span class="keyword">if</span> (recallMap.containsKey(index)) &#123;</span><br><span class="line">                preLoop[<span class="number">0</span>] = recallMap.get(index)[<span class="number">0</span>];</span><br><span class="line">                preLoop[<span class="number">1</span>] = recallMap.get(index)[<span class="number">1</span>];</span><br><span class="line">                inLoop[<span class="number">0</span>] = s1Count - preLoop[<span class="number">0</span>];</span><br><span class="line">                inLoop[<span class="number">1</span>] = s2Count - preLoop[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有找到循环节，记录 s1Count 和 s2Count 给下一次循环使用</span></span><br><span class="line">                recallMap.put(index, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;s1Count, s2Count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ans 是 S1 包含的 s2 的数量，考虑之前的 preLoop 头部，和循环节 inLoop</span></span><br><span class="line">        <span class="keyword">int</span> ans = preLoop[<span class="number">1</span>] + (n1 - preLoop[<span class="number">0</span>]) / inLoop[<span class="number">0</span>] * inLoop[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S1 的末尾还剩一些 s1，开始暴力匹配</span></span><br><span class="line">        <span class="keyword">int</span> rest = (n1 - preLoop[<span class="number">0</span>]) % inLoop[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 剩余 rest 个 s1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rest; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s1.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (c == s2.charAt(index)) &#123;</span><br><span class="line">                    <span class="comment">// 匹配到 s2 的一个字符</span></span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="comment">// 完全匹配到 s2</span></span><br><span class="line">                    <span class="keyword">if</span> (index == s2.length()) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        index = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// S1 包含 ans 个 s2，那么 S1 包含 ans / n2 个 S2</span></span><br><span class="line">        <span class="keyword">return</span> ans / n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;统计重复个数&quot;&gt;&lt;a href=&quot;#统计重复个数&quot; class=&quot;headerlink&quot; title=&quot;统计重复个数&quot;&gt;&lt;/a&gt;统计重复个数&lt;/h1&gt;&lt;p&gt;由 n 个连接的字符串 s 组成字符串 S，记作 S = [s,n]。例如，[“abc”,3]=“abcab</summary>
      
    
    
    
    <category term="算法" scheme="https://www.okclouder.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://www.okclouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
