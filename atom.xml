<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caoshen</title>
  
  <subtitle>caoshen 的博客</subtitle>
  <link href="https://www.okclouder.cn/atom.xml" rel="self"/>
  
  <link href="https://www.okclouder.cn/"/>
  <updated>2020-11-27T00:56:17.815Z</updated>
  <id>https://www.okclouder.cn/</id>
  
  <author>
    <name>caoshen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>https://www.okclouder.cn/2020/11/27/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</id>
    <published>2020-11-27T00:56:17.814Z</published>
    <updated>2020-11-27T00:56:17.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h1><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p>说明:</p><p>你的解法应该是 O(logN) 时间复杂度的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-peak-element">https://leetcode-cn.com/problems/find-peak-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先想到的是顺序遍历，但是顺序遍历的时间复杂度是 O(N)，不满足要求。虽然也能通过用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = nums[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> right = nums[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> mid = nums[i];</span><br><span class="line">                <span class="keyword">if</span> (left &lt; mid &amp;&amp; mid &gt; right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 题目要求 O(logN) 时间复杂度，那么一般是树状结构的遍历，比如二叉树。</p><p>如果中间节点是峰值，直接返回中间节点。否则取左右节点中较大的那个节点，在它所属的区间内遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findPeakElementRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElementRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left] &gt; nums[right] ? left : right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = left + right;</span><br><span class="line">        <span class="keyword">int</span> mid = ((total &amp; <span class="number">1</span>) == <span class="number">1</span>) ? (total - <span class="number">1</span>) / <span class="number">2</span>: total / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElementRange(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElementRange(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻找峰值&quot;&gt;&lt;a href=&quot;#寻找峰值&quot; class=&quot;headerlink&quot; title=&quot;寻找峰值&quot;&gt;&lt;/a&gt;寻找峰值&lt;/h1&gt;&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.812Z</published>
    <updated>2020-11-27T00:56:17.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的外观模式"><a href="#Android-源码的外观模式" class="headerlink" title="Android 源码的外观模式"></a>Android 源码的外观模式</h1><h2 id="外观模式介绍"><a href="#外观模式介绍" class="headerlink" title="外观模式介绍"></a>外观模式介绍</h2><p>外观模式（Facade）在开发过程中的运用频率非常高，尤其是在现阶段各种第三方 SDK 充斥在我们的周边，而这些 SDK 很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如网络模块、ImageLoader模块等。</p><h2 id="外观模式定义"><a href="#外观模式定义" class="headerlink" title="外观模式定义"></a>外观模式定义</h2><p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式（Facade 模式）提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="Android-源码中的外观模式"><a href="#Android-源码中的外观模式" class="headerlink" title="Android 源码中的外观模式"></a>Android 源码中的外观模式</h2><p>在用 Android 开发过程中，Context 是最重要的一个类型。Context 只是一个抽象类，它的真正实现在 ContextImpl 类中，ContextImpl 就是今天我们要分析的外观类。</p><p>在应用启动时，首先会 fork 一个子进程，并且调用 ActivityThread 的 main 方法启动该进程。ActivityThread 又会构建 Application 对象，然后和 Activity、ContextImpl 关联起来，最后会调用 Activity 的 onCreate、onStart、onResume 函数使 Activity 运行起来，此时应用的用户界面就呈现在我们面前。</p><p>main 函数会间接地调用 ActivityThread 中的 handleLaunchActivity 函数启动默认的 Activity。</p><p>handleLaunchActivity 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建并且加载 Activity，调用它的 onCreate</span></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performLaunchActivity 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 构建 ContextImpl</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        <span class="comment">// 创建 Activity</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Unable to instantiate activity &quot;</span> + component</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Performing launch of &quot;</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">&quot;: app=&quot;</span> + app</span><br><span class="line">                + <span class="string">&quot;, appName=&quot;</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">&quot;, pkg=&quot;</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">&quot;, comp=&quot;</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">&quot;, dir=&quot;</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 Activity 的 title</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">&quot;Launching activity &quot;</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">&quot; with config &quot;</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">// Activity 与 Context、Application 关联起来</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调 Activity 的 onCreate 方法</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">&quot; did not call through to super.onCreate()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Unable to start activity &quot;</span> + component</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 handleLaunchActivity 中会调用 perfromLaunchActivity 执行 Applicaton、ContextImpl、Activity 的创建工作，并且通过Activity 的 attach 将这3者关联起来，</p><p>Activity 是 Context 的子类，因此，Activity 就具有了 Context 定义的所有方法。但 Activity 并不实现具体的功能，它只是继承了 Context 的接口，并且将相关的操作交给 ContextImpl。ContextImpl 存储在 Activity 的上两层父类 ContextWrapper 中，变量名为 mBase，具体代码如下：</p><p>ContextThemeWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextThemeWrapper</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>ContextWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the base context for this ContextWrapper.  All calls will then be</span></span><br><span class="line"><span class="comment">     * delegated to the base context.  Throws</span></span><br><span class="line"><span class="comment">     * IllegalStateException if a base context has already been set.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base The new base context for this wrapper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Base context already set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在 ActivityThread 类的 perfromLaunchActivity 函数中会调用 Activity 的 attach 方法将 ContextImpl 等对象关联到 Activity 中，这个 ContextImp l最终会被 ContentWrapper 类的 mBase 字段引用。</p><p>Activity 的 attach 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自身的 attachBaseContext</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="keyword">if</span> (voiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mVoiceInteractor = <span class="keyword">new</span> VoiceInteractor(voiceInteractor, <span class="keyword">this</span>, <span class="keyword">this</span>,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line"></span><br><span class="line">    setAutofillCompatibilityEnabled(application.isAutofillCompatibilityEnabled());</span><br><span class="line">    enableAutofillCompatibilityIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>attach 主要就是一些赋值操作。在 attach 中，调用了 attachBaseContext 函数。attachBaseContext 调用了父类 ContextWrapper 类，它就是简单地将 Context 参数传递给 mBase 字段。此时，我们的 Activity 内部就持有了 ContextImpl 的引用。</p><p>Activity 的 attachBaseContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context newBase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了 ContextThemeWrapper 的 attachBaseContext</span></span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(newBase);</span><br><span class="line">    <span class="keyword">if</span> (newBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newBase.setAutofillClient(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity 在开发过程中部分充当了代理的角色，例如，当我们通过 Activity 对象调用 sendBroadcast、getResource 等函数时，实际上 Activity 只是代理了 ContextImpl 的操作，也就是内部都调用了 mBase 对象的相应方法来处理，这些方法被封装在 Activity 的父类 ContextWrapper 中。</p><p>ContextWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mBase.sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getResources();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getPackageManager();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现如下：</p><p>ContextImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">            ActivityManager.getService().broadcastIntent(</span><br><span class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                    Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                    getUserId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mPackageManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Doesn&#x27;t matter if we make more than one instance.</span></span><br><span class="line">            <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextImpl 内部封装了很多不同子系统的操作，例如，Activity 的跳转、发送广播、启动服务、设置壁纸等，这些工作并不是在 ContextImpl 中实现，而是转交给了具体的子系统进行处理。通过 Context 这个抽象类定义了一组接口，ContextImpl 实现 Context 定义的接口，使得用户可以通过 Context 这个接口统一与 Android 系统进行交互，这样用户通常情况下就不需要对每个子系统进行了解，例如启动 Activity 时用户不需要手动调用 mMainThread.getInstrumentation().execStartActivity 启动 Activity。用户与系统服务的交互都通过 Context 的高层接口。这样对用户屏蔽了具体实现的细节，降低了使用成本。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Android 源码设计模式解析与实战 · 第23章 统一编程接口——外观模式》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的外观模式&quot;&gt;&lt;a href=&quot;#Android-源码的外观模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的外观模式&quot;&gt;&lt;/a&gt;Android 源码的外观模式&lt;/h1&gt;&lt;h2 id=&quot;外观模式介绍&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.811Z</published>
    <updated>2020-11-27T00:56:17.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的组合模式"><a href="#Android-源码的组合模式" class="headerlink" title="Android 源码的组合模式"></a>Android 源码的组合模式</h1><h2 id="组合模式介绍"><a href="#组合模式介绍" class="headerlink" title="组合模式介绍"></a>组合模式介绍</h2><p>组合模式（Composite Pattern）也称为部分整体模式（Part-Whole Pattern），结构型设计模式之一。</p><p>组合模式比较简单，它将一组相似的对象看作一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象集合之间的差别。</p><h2 id="组合模式的定义"><a href="#组合模式的定义" class="headerlink" title="组合模式的定义"></a>组合模式的定义</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="Android-源码中的组合模式实现"><a href="#Android-源码中的组合模式实现" class="headerlink" title="Android 源码中的组合模式实现"></a>Android 源码中的组合模式实现</h2><p>Android 中的 View 和 ViewGroup 的嵌套组合是一个典型的组合模式实现。</p><p>在 Android 的这个视图层级中，容器一定是 ViewGroup，而且只有 ViewGroup 才能包含其他的 View，比如 LinearLayout 能包含 TextView、Button、CheckBox 等，但是反过来 TextView 是不能包含 LinearLayout 的，因为 TextView 直接继承于 View，其并非一个容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        addView(child, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (removeViewInternal(view)) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">            invalidate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getChildAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= mChildrenCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mChildren[index];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么-ViewGroup-有容器的功能"><a href="#为什么-ViewGroup-有容器的功能" class="headerlink" title="为什么 ViewGroup 有容器的功能"></a>为什么 ViewGroup 有容器的功能</h2><p>ViewGroup 是继承于 View 类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承的角度来说，ViewGroup 拥有 View 类所有的非私有方法。既然如此，两者的差别就在于 ViewGroup 所实现的 ViewParent 和 ViewManager 接口上，而事实也是如此。</p><p>ViewManager 定义了 addView、removeView 等对子视图操作的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Assign the passed LayoutParams to the passed View and add the view to the window.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Throws &#123;<span class="doctag">@link</span> android.view.WindowManager.BadTokenException&#125; for certain programming</span></span><br><span class="line"><span class="comment">     * errors, such as adding a second view to a window without removing the first view.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Throws &#123;<span class="doctag">@link</span> android.view.WindowManager.InvalidDisplayException&#125; if the window is on a</span></span><br><span class="line"><span class="comment">     * secondary &#123;<span class="doctag">@link</span> Display&#125; and the specified display can&#x27;t be found</span></span><br><span class="line"><span class="comment">     * (see &#123;<span class="doctag">@link</span> android.app.Presentation&#125;).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view The view to be added to this window.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params The LayoutParams to assign to view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ViewParent 则定义了刷新容器的接口 requestLayout 和其他一些焦点事件的处理的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewParent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求重新布局</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经请求布局。这里需要注意，当我们调用 requestLayout 请求布局后，这一过程并非是立即执行的，Android 会将请求布局的操作以消息的形式发送至主线程的 Handler 并由其分发处理。因此在调用 requestLayout 方法请求布局到布局真正接收到重新布局的命令时需要一段时间间隔</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLayoutRequested</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取当前 View 的 ViewParent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewParent <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一些方法比较常见，比如 requestLayout 和 bringChildToFront 等。</p><p>ViewGroup 除了所实现的这两个接口与 View 不一样外，还有重要的一点就是 ViewGroup 是抽象类，将 View 的 onLayout 重置为抽象方法。容器子类必须实现 onLayout 来布局定位。</p><p>除此之外，在 View 中比较重要的两个测绘流程的方法 onMeasure 和 onDraw 在 ViewGroup 中都没有被重写，相对于 onMeasure 方法，在 ViewGroup 中增加了一些计算子 View 的方法，如 measureChildren、measureChildrenWithMargins 等；而对于 onDraw 方法，ViewGroup 定义了一个 dispatchDraw 方法来调用其每一个子 View 的 onDraw 方法，由此可见，ViewGroup 真的就象一个容器一样，其职责只是负责对子元素的操作而非具体的个体行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的组合模式&quot;&gt;&lt;a href=&quot;#Android-源码的组合模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的组合模式&quot;&gt;&lt;/a&gt;Android 源码的组合模式&lt;/h1&gt;&lt;h2 id=&quot;组合模式介绍&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-11-27T00:56:17.811Z</published>
    <updated>2020-11-27T00:56:17.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-阻塞队列"><a href="#Java-阻塞队列" class="headerlink" title="Java 阻塞队列"></a>Java 阻塞队列</h1><p>阻塞队列在 Java 中时常被用到，比如线程池、生产者消费者模型。</p><h2 id="阻塞队列简介"><a href="#阻塞队列简介" class="headerlink" title="阻塞队列简介"></a>阻塞队列简介</h2><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h3 id="常见阻塞场景"><a href="#常见阻塞场景" class="headerlink" title="常见阻塞场景"></a>常见阻塞场景</h3><p>阻塞队列有两个常见的阻塞场景，它们分别是：</p><ol><li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p></li><li><p>当队列中填满了数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程自动被唤醒。</p></li></ol><p>支持以上两种阻塞场景的队列被称为阻塞队列。</p><h3 id="BlockingQueue-的核心方法"><a href="#BlockingQueue-的核心方法" class="headerlink" title="BlockingQueue 的核心方法"></a>BlockingQueue 的核心方法</h3><p>BlockingQueue 的核心方法可以分为放入数据和读取数据。</p><p>放入数据：</p><ul><li><p>boolean offer(E e) 表示如果可能的话，将 e 加到 BlockingQueue 里。如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。本方法不阻塞当前执行方法的线程。</p></li><li><p>boolean offer(E e, long timeout, TimeUnit unit) 可以设定等待的时间。如果在指定的时间内还不能往队列中加入 BlockingQueue，则返回失败。</p></li><li><p>void put(E e) 将 e 加到 BlockingQueue 里。如果 BlockingQueue 没有空间，则调用此方法的线程被阻断，直到 BlockingQueue 里面有空间在继续。</p></li></ul><p>读取数据：</p><ul><li><p>E poll() 取走 BlockingQueue 里排在首位的对象。</p></li><li><p>E poll(long timeout, TimeUnit unit) 从 BlockingQueue 中取出一个队首的对象。如果在指定时间内队列有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，就返回失败。</p></li><li><p>E take() 取走 BlockingQueue 里排在首位的对象。如果 BlockingQueue 是空，则阻断进入等待状态，否则返回失败。</p></li><li><p>int drainTo(Collection&lt;? super E&gt; c) 一次性从 BlockingQueue 获取所有可用的数据对象（也可以指定取出的个数）。通过该方法可以提升获取数据的效率，无需多次分批加锁或者释放锁。注意这里的下界通配符 super，表示 c 集合中的元素必须至少是 E 类型或者它的超类。</p></li></ul><h2 id="Java-中的阻塞队列"><a href="#Java-中的阻塞队列" class="headerlink" title="Java 中的阻塞队列"></a>Java 中的阻塞队列</h2><p>Java 中提供了很多阻塞队列，举例如下：</p><ul><li>ArrayBlockingQueue 由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue 由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue 支持优先级排序的无界阻塞队列</li><li>DelayQueue 使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue 不存储元素的阻塞队列</li><li>LinkedTransferQueue 由链表结构组成的无界阻塞队列</li><li>LinkedBlokcingDeque 由链表结构组成的阻塞双端队列</li></ul><p>这些阻塞队列有一个共同点，就是都实现了 BlockingQueue 接口。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是用数组实现的有界阻塞队列，按照先进先出 FIFO 的原则对元素进行排序。默认情况下不保证线程公平地访问队列。公平访问队列就是指阻塞地所有生产者线程或者消费者线程按照阻塞地先后顺序访问队列。即先阻塞地生产者线程，可以先往队列里面插入元素；先阻塞的消费者线程，可以先从队列里获取元素。通常情况下，保证公平性会降低吞吐量。</p><p>我们可以使用以下代码创建一个公平的阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">2000</span>, <span class="keyword">true</span>); </span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue 的第二个参数传 true，保证公平性。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序，其内部也维持着一个数据缓存队列（该队列由一个链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回。当队列缓冲区达到缓存容量的最大值时（LinkedBlockingQueue 可以通过构造方法指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒。反之，对于消费者这端的处理也基于同样的原理。</p><p>LinkedBlockingQueue 之所以能够高效地处理并发数据，因为它对于生产者端和消费者端分别采用了独立地锁来控制数据同步。这也意味着在高并发地情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>作为开发者需要注意的是，如果构造 LinkedBlockingQueue 时，没有指定大小，那么默认会用最大整数（Integer.MAX_VALUE）作为容量。如果生产者的速度大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就已经被消耗殆尽了。</p><p>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列。一般情况下，在处理多线程的生产者消费者问题时，使用这两个类就行。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。这里可以自定义元素的 compareTo 方法得到排序规则。也可以在构造 PriorityBlockingQueue 时传入 Comparator 来对元素进行排序，但是不能保证同优先级元素的顺序。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口。创建元素时，可以指定元素到期的时间，只有在元素到期时才能从队列中取走。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其实并没有任何一个元素，或者说容量是 0，严格来说它不是一种容器。由于队列没有容量，它的 peek 操作（返回队列的头元素）总是返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 Transfer 队列。LinkedTransferQueue 实现了一个重要的接口 TransferQueue。该接口有 5 个方法，其中有 3 个重要的方法，它们分别如下所示。</p><ol><li><p>void transfer(E e) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；如果没有消费者在等待接收数据，就会将元素插入到队尾底部，并且等待进入阻塞状态，直到有消费者线程取走该元素。</p></li><li><p>boolean tryTransfer(E e) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；若不存在，则返回 false，并且不进入队列，这是一个不阻塞的操作。与 transfer 方法不同的是，tryTransfer 方法无论消费者是否接收，其都会立即返回；而 transfer 方法则是消费者接收了才返回。</p></li><li><p>boolean tryTransfer(E e, long timeout, TimeUnit unit) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；若不存在则将元素插入到队列尾部，并且等待消费者线程取走该元素。若在指定的超时时间内元素未被消费者线程获取，则返回 false；若在指定的超时时间内被消费者线程获取，则返回 true。</p></li></ol><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是由一个链表结构组成的双向阻塞队列。双向队列可以从队列的两端插入和移除元素，因此在多线程同时入队时，减少了一半的竞争。由于是双向的，因此 LinkedBlockingDeque 多了 addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast 等方法。以 First 开头的表示插入、获取、移除双端队列的第一个元素；以 Last 结尾的方法表示插入、获取、移除双端队列的最后一个元素。</p><h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p>这里以 ArrayBlockingQueue 为例分析它的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可以看出 ArrayBlockingQueue 维护了一个 Object 类型的数组，takeIndex 和 putIndex 分别表示队首元素和队尾元素的下标。count 表示队列中元素的个数，lock 则是一个可重入锁，notEmpty 和 notFull 是等待条件。</p><p>ArrayBlockingQueue 的 put 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 put 方法可以看出，它先获取了 lock 锁，并且调用了 lockInterruptibly 方法表示可中断，然后循环判断当前元素个数是否等于数组的长度，如果相等就调用 notFull.await 进行等待。当此线程被其他线程唤醒时，通过 enqueue 方法插入一个元素，最后解锁。</p><p>ArrayBlockingQueue 的 enqueue 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 enqueue 方法把 putIndex 位置的元素赋值为 e。如果已经是最后一个位置，那么会重置为 0，然后元素个数加 1，最后调用条件对象 notEmpty 的 signal 方法，表示唤醒正在等待取元素的线程。</p><p>ArrayBlockingQueue 的 take 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 put 方法类似，take 方法等待的是 notEmpty 条件。在 take 方法中，如果元素个数为 0，就循环等待。否则调用 dequeue 方法出队一个元素。</p><p>ArrayBlockingQueue 的 dequeue 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E e = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在得到 takeIndex 位置的元素后会调用 notFull 条件的 signal 方法，表示唤醒正在等待插入元素的线程。</p><h2 id="阻塞队列的使用场景"><a href="#阻塞队列的使用场景" class="headerlink" title="阻塞队列的使用场景"></a>阻塞队列的使用场景</h2><p>除了线程池的实现使用了阻塞队列之外，还可以在生产者消费者模式中使用阻塞队列。</p><p>首先使用 Object.wait 、Object.notify 和非阻塞队列 PriorityQueue 实现生产者消费者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QueueTest queueTest = <span class="keyword">new</span> QueueTest();</span><br><span class="line">        Producer producer = queueTest.<span class="function">new <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = queueTest.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列空，等待数据&quot;</span> + queue);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 消费队首元素</span></span><br><span class="line">                    Integer poll = queue.poll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列取走&quot;</span> + poll + <span class="string">&quot;, &quot;</span> + queue);</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列满，等待有空余空间&quot;</span> + queue);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 插入一个元素</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;队列插入 1&quot;</span> + queue);</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用阻塞队列 ArrayBlockingQueue 实现生产者消费者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueueTest queueTest = <span class="keyword">new</span> BlockingQueueTest();</span><br><span class="line">        BlockingQueueTest.Producer producer = queueTest.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        BlockingQueueTest.Consumer consumer = queueTest.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 消费队首元素</span></span><br><span class="line">                    Integer poll = queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列取走&quot;</span> + poll + <span class="string">&quot;, &quot;</span> + queue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 插入一个元素</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;队列插入 1&quot;</span> + queue);</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出使用阻塞队列实现无须单独考虑同步和线程间通信的问题，实现起来比较简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-阻塞队列&quot;&gt;&lt;a href=&quot;#Java-阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;Java 阻塞队列&quot;&gt;&lt;/a&gt;Java 阻塞队列&lt;/h1&gt;&lt;p&gt;阻塞队列在 Java 中时常被用到，比如线程池、生产者消费者模型。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20RxJava%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20RxJava%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2020-11-27T00:56:17.810Z</published>
    <updated>2020-11-27T00:56:17.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-RxJava-基本用法"><a href="#Android-RxJava-基本用法" class="headerlink" title="Android RxJava 基本用法"></a>Android RxJava 基本用法</h1><p>RxJava 使用函数响应式编程方式，它可以简化项目，处理嵌套回调的异步事件。</p><h2 id="RxJava-依赖"><a href="#RxJava-依赖" class="headerlink" title="RxJava 依赖"></a>RxJava 依赖</h2><p>这里以 RxJava 2.2.1 为例。在 build.gradle 添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rxjava</span><br><span class="line">implementation &quot;io.reactivex.rxjava2:rxjava:2.2.11&quot;</span><br><span class="line">implementation &#39;io.reactivex.rxjava2:rxandroid:2.1.1&#39;</span><br></pre></td></tr></table></figure><h2 id="创建观察者-Observer"><a href="#创建观察者-Observer" class="headerlink" title="创建观察者 Observer"></a>创建观察者 Observer</h2><p>新建一个 Observer，复写它的回调方法：onSubscribe、onNext、onError、onComplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onSubscribe:&quot;</span> + d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onNext:&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onError:&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onComplete:&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>onSubscribe：订阅开始；</p><p>onNext：添加普通时间；</p><p>onError：异常事件；</p><p>onComplete：完结事件。</p><h2 id="创建被观察者-Observable"><a href="#创建被观察者-Observable" class="headerlink" title="创建被观察者 Observable"></a>创建被观察者 Observable</h2><p>创建 Observable 时可以使用 create、just 或者 from 方法。这里使用 just：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable = Observable.just(<span class="string">&quot;杨影枫&quot;</span>, <span class="string">&quot;月眉儿&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码相当于依次调用了 onNext(“杨影枫”) 和 onNext(“月眉儿”) ，最后调用 onComplete。</p><h2 id="订阅-subscribe"><a href="#订阅-subscribe" class="headerlink" title="订阅 subscribe"></a>订阅 subscribe</h2><p>使用 Observable 的 subscribe 方法可以触发订阅，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>运行结果 logcat 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxJavaActivity: onSubscribe:io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable@1816f28</span><br><span class="line">RxJavaActivity: onNext:杨影枫</span><br><span class="line">RxJavaActivity: onNext:月眉儿</span><br><span class="line">RxJavaActivity: onComplete:</span><br></pre></td></tr></table></figure><h2 id="RxJava-不完整回调"><a href="#RxJava-不完整回调" class="headerlink" title="RxJava 不完整回调"></a>RxJava 不完整回调</h2><p>RxJava 1.x 版本提供了 ActionX(X = 1~9、N) 来表示不同参数的回调。<br>在 RxJava 2 中使用 Consumer 代替 Action1，使用 BiConsumer 代替 Action2，使用 Consumer&lt;Object[]&gt; 代替 ActionN。</p><p>Action 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供一个无参 run 方法。</p><p>Consumer 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Consume the given value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供一个参数的 accept 方法。</p><p>BiConsumer 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T1 t1, T2 t2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供 2 个参数的 accept 方法。</p><p>如果需要多个参数的方法，可以给 Consumer 类传入数组类型，即 Consumer&lt;Object[]&gt;。</p><p>有了 Action 和 Consumer，可以把之前的代码改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRxJavaAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; nextConsumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;nextConsumer accept:&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Consumer&lt;Throwable&gt; errorConsumer = <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;errorConsumer accept:&quot;</span> + throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Action completeAction = <span class="keyword">new</span> Action() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;run:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Observable&lt;String&gt; observable = Observable.just(<span class="string">&quot;杨影枫&quot;</span>, <span class="string">&quot;月眉儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">    observable.subscribe(nextConsumer, errorConsumer, completeAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码把回调方法拆分在 3 个回调对象中，然后传递给了 subscribe 方法。</p><p>subscribe 方法也可以接收 1 个或 2 个回调对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(nextConsumer, errorConsumer);</span><br></pre></td></tr></table></figure><p>这种方法写起来更加灵活，可以选择想要的回调方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-RxJava-基本用法&quot;&gt;&lt;a href=&quot;#Android-RxJava-基本用法&quot; class=&quot;headerlink&quot; title=&quot;Android RxJava 基本用法&quot;&gt;&lt;/a&gt;Android RxJava 基本用法&lt;/h1&gt;&lt;p&gt;Rx</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-11-27T00:56:17.810Z</published>
    <updated>2020-11-27T00:56:17.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-volatile-关键字"><a href="#Java-volatile-关键字" class="headerlink" title="Java volatile 关键字"></a>Java volatile 关键字</h1><p>volatile 是 Java 的关键字，它的本意是易变的，即被 volatile 声明的变量可能被其他线程修改，需要用 volatile 保证变量的可见性和有序性。</p><p>有时仅仅为了读写一个或者两个实例域就使用同步的话，显得开销过大；而 volatile 关键字为实例域的同步访问提供了免锁机制。如果声明一个域为 volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此它存在内存可见性的问题。而局部变量、方法定义的参数则不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。Java 内存模型定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中，每个线程有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。</p><p>需要注意的是本地内存是 Java 内存模型的一个抽象概念，其并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java 内存模型控制线程之间的通信，它决定一个线程对主存共享变量的写入何时对另一个线程可见。</p><p>线程 A 和线程 B 之间若要通信的话，必须要经历下面两个步骤：</p><ol><li>线程 A 把线程 A 本地内存中更新过的共享变量刷新到主存中去；</li><li>线程 B 到主存中去读取线程 A 之前已更新过的共享变量。</li></ol><h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><p>原子性、可见性和有序性是并发编程中的三个特性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>对基本类型的读取和赋值操作是原子性的操作，即这些操作是不可中断的，要么执行完毕，要么不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = x;</span><br><span class="line">x++;</span><br></pre></td></tr></table></figure><p>上面 3 个语句只有第 1 条语句是原子性操作，其他 2 个语句都不是原子性操作。</p><p>第 2 条语句虽然是赋值操作，但是它包含了 2 个步骤，首先读取 x 的值，然后将 x 的值写入工作内存。读取 x 的值以及将 x 的值写入工作内存这两个操作单拿出来都是原子操作，但是合起来就不是原子操作。</p><p>第 3 条语句包括了 3 个操作：读取 x 的值、对 x 的值进行加 1、向工作内存写入新值。</p><p>通过这 3 个语句我们得知，一个语句包含多个操作时，就不是原子性操作，只有简单地读取和赋值（将数字赋值给某个变量）才是原子性操作。</p><p>java.util.concurrent.atomic 包中有很多类使用了高效的机器级指令（而不是使用锁）来保证操作的原子性。例如 AtomicInteger 类提供了方法 incrementAndGet 和 decrementAndGet，它们分别以原子方式将一个整数自增和自减。可以安全地使用 AtomicInteger 类作为共享计数器而无需同步。另外这个包还包含了 AtomicBoolean、AtomicLong、AtomicReference 这些原子类。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指线程之间地可见性，一个线程修改地状态对另一个线程时可见地。也就是说一个线程修改地结果，另一个线程马上就能看到。当一个共享变量被 volatile 修饰时，它会保证修改地值立即被更新到主存，同时其他线程读取共享变量时，会直接从主存中读取，而不是从线程工作内存读取，所以对其他线程是可见的。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>Java 内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性。这时可以通过 volatile 来保证有序性。除了 volatile，也可以通过 synchronized 和 lock 来保证有序性。我们知道，synchronized 和 lock 保证每个时刻只有一个线程执行同步代码，这相当于是让线程顺序执行同步代码，从而保证了有序性。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>当一个共享变量被 volatile 修饰之后，就具备了两个含义，一个是线程修改了变量的值时，变量的新值对其他线程时立即可见的。另一个含义是禁止指令重排序。重排序通常是编译器或者运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对于编译时和运行时环境。</p><h3 id="volatile-不保证原子性"><a href="#volatile-不保证原子性" class="headerlink" title="volatile 不保证原子性"></a>volatile 不保证原子性</h3><p>我们知道 volatile 保证了操作的可见性，但是对于一些自增操作，它无法保证原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VolatileTest volatileTest = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">                        volatileTest.increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有子线程就让出资源，保证所有子线程都执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(volatileTest.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9475</span><br></pre></td></tr></table></figure><p>可以看出并非每次都正确执行了自增操作。自增操作是不具备原子性的，它包括 3 个步骤，读取变量的原始值、进行加 1、写入工作内存。也就是说，自增操作的 3 个自操作可能分割开执行。</p><h3 id="volatile-保证有序性"><a href="#volatile-保证有序性" class="headerlink" title="volatile 保证有序性"></a>volatile 保证有序性</h3><p>volatile 关键字能禁止指令重排序，因此 volatile 能保证有序性。volatile 关键字禁止指令重排序有 2 个含义：一个是当程序执行到 volatile 变量的操作时，在其前面的操作已经全部执行完毕，并且结果会对后面的操作可见，在其后面的操作还没有运行；在进行指令优化时，在 volatile 变量之前的语句不能在 volatile 变量后面执行；同样，在 volatile 变量之后的语句也不能再 volatile 变量之前执行。</p><h2 id="正确使用-volatile-关键字"><a href="#正确使用-volatile-关键字" class="headerlink" title="正确使用 volatile 关键字"></a>正确使用 volatile 关键字</h2><p>通常来说，使用 volatile 必须具备以下两个条件：</p><ol><li>对变量的写操作不会依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>第一个条件就是不能是自增、自减操作，上文已经提到 volatile 不保证原子性。</p><p>关于第二个条件，我们来举一个例子，它包含了一个不等式：下界总是小于或者等于上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> lower, upper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; upper) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;great than upper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lower = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; lower) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;less than lower&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        upper = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        NumberRange numberRange = <span class="keyword">new</span> NumberRange();</span><br><span class="line">        numberRange.setLower(<span class="number">0</span>);</span><br><span class="line">        numberRange.setUpper(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    numberRange.setLower(<span class="number">4</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    numberRange.setUpper(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码 range 的初始值是 0 到 5，假如在同一时刻，线程 1 调用 setLower(4)，线程 2 调用 setUpper(3)，那么新的范围是 (4, 3)。这显然是不对的，因此无法用 volatile 实现 setLower 和 setUpper 操作的原子性。</p><p>使用 volatile 有很多种场景，这里介绍其中 2 种：</p><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">        <span class="comment">// do work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile boolean 标记保证了变量的可见性，对于变量的修改对每个线程都是可见的。</p><h3 id="双重校验锁（DCL）"><a href="#双重校验锁（DCL）" class="headerlink" title="双重校验锁（DCL）"></a>双重校验锁（DCL）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 singleton = new Singleton(); 这个操作会先分配内存，然后调用构造方法构造 Singleton，最后调用赋值操作。这三个操作可能被指令重排序，导致不按顺序执行，线程 1 还没将构造的 singleton 写入内存，线程 2 就去内存读取，读取出错误的值。加上 volatile 关键字之后会产生一个内存屏障，保证操作按照顺序执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与锁相比，volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况想将提供优于锁的性能和伸缩性。如果严格遵守 volatile 的使用条件，即变量真正独立于其他变量和自己以前的值，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。但是，使用 volatile 的代码比使用锁的代码更加容易出错。使用状态标志和双重校验锁是 volatile 的两种常见用例，其他情况下最好还是使用 synchronized 关键字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-volatile-关键字&quot;&gt;&lt;a href=&quot;#Java-volatile-关键字&quot; class=&quot;headerlink&quot; title=&quot;Java volatile 关键字&quot;&gt;&lt;/a&gt;Java volatile 关键字&lt;/h1&gt;&lt;p&gt;volatile 是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/ContentProvider%20%E9%9A%BE%E7%82%B9/"/>
    <id>https://www.okclouder.cn/2020/11/27/ContentProvider%20%E9%9A%BE%E7%82%B9/</id>
    <published>2020-11-27T00:56:17.809Z</published>
    <updated>2020-11-27T00:56:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider-难点"><a href="#ContentProvider-难点" class="headerlink" title="ContentProvider 难点"></a>ContentProvider 难点</h1><h2 id="ContentProvider-的生命周期"><a href="#ContentProvider-的生命周期" class="headerlink" title="ContentProvider 的生命周期"></a>ContentProvider 的生命周期</h2><p>ContentProvider 只有 onCreate 这个生命周期方法。</p><h2 id="ContentProvider-的-onCreate-和-CRUD"><a href="#ContentProvider-的-onCreate-和-CRUD" class="headerlink" title="ContentProvider 的 onCreate 和 CRUD"></a>ContentProvider 的 onCreate 和 CRUD</h2><p>ContentProvider 运行在哪个线程？他们是线程安全的吗？</p><p>onCreate 方法运行在主线程。如果是 ContentProvider 同进程通信，CRUD 运行在主线程。如果是 ContentProvider 跨进程通信，CRUD 运行在 Binder 线程。</p><h2 id="ContentProvider-的内部存储有哪些"><a href="#ContentProvider-的内部存储有哪些" class="headerlink" title="ContentProvider 的内部存储有哪些"></a>ContentProvider 的内部存储有哪些</h2><p>ContentProvider 的内部存储只能是 sqlite 吗？</p><p>ContentProvider 的内部存储不一定是 sqlite，可以是多种形式的存储。比如 sqlite、SharedPreference、文件、内存。</p><h2 id="ContentProvider-的-onCreate-和-Application-的-onCreate-先后顺序"><a href="#ContentProvider-的-onCreate-和-Application-的-onCreate-先后顺序" class="headerlink" title="ContentProvider 的 onCreate 和 Application 的 onCreate 先后顺序"></a>ContentProvider 的 onCreate 和 Application 的 onCreate 先后顺序</h2><p>ContentProvider 的 onCreate 早于 Application 的 onCreate 执行。在 Application 的 onCreate 之前，有 installProvider 和 publishProvider 的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ContentProvider-难点&quot;&gt;&lt;a href=&quot;#ContentProvider-难点&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider 难点&quot;&gt;&lt;/a&gt;ContentProvider 难点&lt;/h1&gt;&lt;h2 id=&quot;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.okclouder.cn/2020/11/27/OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-11-27T00:56:17.809Z</published>
    <updated>2020-11-27T00:56:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp-源码解析"><a href="#OkHttp-源码解析" class="headerlink" title="OkHttp 源码解析"></a>OkHttp 源码解析</h1><p>本文主要从两个方面分析 OkHttp 源代码。</p><ol><li>网络请求流程；</li><li>连接池复用。</li></ol><h2 id="OkHttp-的网络请求流程"><a href="#OkHttp-的网络请求流程" class="headerlink" title="OkHttp 的网络请求流程"></a>OkHttp 的网络请求流程</h2><h3 id="网络请求流程"><a href="#网络请求流程" class="headerlink" title="网络请求流程"></a>网络请求流程</h3><p>不管是异步请求还是同步请求，都会先通过 OkHttpClient 的 newCall 方法构造一个 Call。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">  <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newCall 方法返回的是 RealCall。不管是异步的 enqueue 方法还是同步的 execute 方法，都是由 RealCall 调用的。</p><p>enqueue 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    executed = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    executed = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter()</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，在 RealCall 中 enqueue 和 execute 最终的请求是 dispatcher 调用的。</p><h3 id="Dispatcher-任务调度"><a href="#Dispatcher-任务调度" class="headerlink" title="Dispatcher 任务调度"></a>Dispatcher 任务调度</h3><p>Dispatcher 类定义了控制并发的请求，包括最大请求数、消费者线程池、同步和异步的请求队列等变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>maxRequests 最大请求数</p><p>maxRequestsPerHost 每个主机的最大请求数</p><p>ExecutorService 消费者线程池</p><p>readyAsyncCalls 将要运行的异步请求队列</p><p>runningAsyncCalls 正在运行的异步请求队列</p><p>runningSyncCalls 正在运行的同步请求队列</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">      executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>executorService 的 get 方法返回一个 ThreadPoolExecutor，它的核心线程数是 0，最大线程数是 Int.MAX_VALUE，线程等待时间是 60 秒，任务队列是 SynchronousQueue。</p><p>之前说过 RealCall 的 enqueue 和 execute 实际上是调用的 Dispatcher 的 enqueue 和 execute 。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">    <span class="comment">// the same host.</span></span><br><span class="line">    <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueue 方法主要由以下 3 步：</p><ol><li><p>Dispatcher 的 enqueue 方法先将 AsyncCall 加入到 readyAsyncCalls 队列。</p></li><li><p>如果入队的 call 不是 websocket，那么查找任务准备队列（readyAsyncCalls）和任务执行队列（runningAsyncCalls），看里面是不是存在相同主机（host）的请求。如果存在，就把当前的 call 的主机访问数量设为已经存在的相同主机的 call 数量。这个操作保证每个主机的请求数不超过设定值。在后面的 promoteAndExecute 会被用到。</p></li><li><p>promoteAndExecute 方法会从 readyAsyncCalls 队列中筛选出符合条件的 call，然后调用 call 的 executeOn(executorService) 执行。</p></li></ol><p>promoteAndExecute 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove()</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealCall 的 executeOn 方法有个 success 局部变量。正常情况下，execute 走完，success 是 true，但是如果这个过程中抛出异常，那么 success 就还是 false。在最后的 finally 语句中可以发现，会调用 Dispatcher 的 finish 方法。finish 方法其实就是从 runningAsyncCalls 队列移除 call，然后再次调用 promoteAndExecute 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to enqueue this async call on [executorService]. This will attempt to clean up</span></span><br><span class="line"><span class="comment"> * if the executor has been shut down by reporting the call as failed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">  assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">  <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">    success = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">    <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">    ioException.initCause(e)</span><br><span class="line">    transmitter.noMoreExchanges(ioException)</span><br><span class="line">    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ### Interceptor 拦截器### 缓存策略### 失败重连## OkHttp 的复用连接池 -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OkHttp-源码解析&quot;&gt;&lt;a href=&quot;#OkHttp-源码解析&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 源码解析&quot;&gt;&lt;/a&gt;OkHttp 源码解析&lt;/h1&gt;&lt;p&gt;本文主要从两个方面分析 OkHttp 源代码。&lt;/p&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</id>
    <published>2020-11-27T00:56:17.807Z</published>
    <updated>2020-11-27T00:56:17.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程的状态"><a href="#Java-线程的状态" class="headerlink" title="Java 线程的状态"></a>Java 线程的状态</h1><p>Java 线程在运行的生命周期中可能处于 6 种不同的状态：</p><ol><li>New 新创建的状态。线程被创建，但是没有调用 start 方法，在运行之前有一些基础工作要做，比如初始化操作。</li><li>Runnable 可运行状态。一旦调用了 start 方法，线程就处于 Runnable 状态。一个可运行的线程可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。</li><li>Blocked 阻塞状态。表示线程被阻塞，暂时不活动。比如线程正在请求锁。</li><li>Waiting 等待状态。线程暂时不活动，并且不允许任何代码，这消耗最少的资源，知道线程调度器重新激活它。</li><li>Timed waiting 超时等待状态。和等待状态的区别是超时等待可以在指定的时间自行返回。</li><li>Terminated 终止状态。表示当前线程执行完毕。可能有 2 种情况：第一种情况是 run 方法正常执行完毕退出。第二种情况是因为一个没有被捕获的异常而终止了 run 方法，导致线程进入终止状态。</li></ol><p>New 状态 Thread.start 后会进入 Runnable 状态。</p><p>Runnable 调用 Object.wait 或者 Thread.join 会进入 Waiting 状态。</p><p>Waiting 调用 Object.notify 或者 Object.notifyAll 会进入 Runnable 状态。</p><p>Runnable 调用 Thread.sleep(long)、Object.wait(long) 、 Thread.join(long) 会进入 Timed Waiting 状态。</p><p>Timed Waiting 调用 Object.notify 或者 Object.notifyAll 会进入 Runnable 状态。</p><p>Runnable 请求锁会进入 Blocked 状态。</p><p>Blocked 得到锁会进入 Runnable 状态。</p><p>Runnable 执行完毕或者异常退出会进入 Terminated 状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程的状态&quot;&gt;&lt;a href=&quot;#Java-线程的状态&quot; class=&quot;headerlink&quot; title=&quot;Java 线程的状态&quot;&gt;&lt;/a&gt;Java 线程的状态&lt;/h1&gt;&lt;p&gt;Java 线程在运行的生命周期中可能处于 6 种不同的状态：&lt;/p&gt;
&lt;ol</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.805Z</published>
    <updated>2020-11-27T00:56:17.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的享元模式"><a href="#Android-源码的享元模式" class="headerlink" title="Android 源码的享元模式"></a>Android 源码的享元模式</h1><h2 id="享元模式介绍"><a href="#享元模式介绍" class="headerlink" title="享元模式介绍"></a>享元模式介绍</h2><p>享元模式是对象池的一种实现，它的英文名称叫做 Flyweight，代表轻量级的意思。享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。</p><h2 id="享元模式定义"><a href="#享元模式定义" class="headerlink" title="享元模式定义"></a>享元模式定义</h2><p>使用共享对象可有效地支持大量地细粒度的对象。</p><h2 id="Android-源码中的享元模式"><a href="#Android-源码中的享元模式" class="headerlink" title="Android 源码中的享元模式"></a>Android 源码中的享元模式</h2><p>Handler 消息机制中的 Message 消息池就是使用享元模式复用了 Message 对象。</p><p>使用 Message 时一般会用到 Message.obtain 来获取消息。如果使用 new Message() 会构造大量的 Message 对象。</p><p>obtain 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 清空 in-use 标记</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sPoolSync 和 sPool 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br></pre></td></tr></table></figure><p>sPoolSync 是一个对象锁，用于在获取 Message 对象时进行同步锁。</p><p>sPool 是一个静态的 Message 对象。</p><p>next 是一个 Message 对象，指向下一个 Message。</p><p>可以看出，Message 消息池没有使用 map 这样的容器，而是使用的链表。</p><p>那么这些 Message 是什么时候放入链表中的呢？我们在 obtain 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，obtain 中则是直接返回一个通过 new 创建的 Message 对象，而且并没有存储到链表中。</p><p>Message 类有一个 recycle 方法，它用来回收消息，并且把回收掉的消息添加到对象池链表中。</p><p>recycle 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断消息是否还在使用</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空状态，并且将消息添加到消息池中</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recycleUnchecked 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    <span class="comment">// 清空消息状态，设置该消息 in-use flag</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收消息到消息池中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recycle 会将一个 Message 回收到一个全局的池。如果消息在使用就抛出异常，否则调用 recycleUnchecked。</p><p>recycleUnchecked 先清空字段，然后回收消息，将 sPool 指向当前消息，同时 size 加一。</p><p>Message 通过在内部构建一个链表来维护一个被回收的 Message 对象的对象池，当用户调用 obtain 时会优先从池中取，如果池中没有可以复用的对象则创建这个新的 Message 对象。这些新创建的 Message 对象在被使用完之后会被回收到这个对象池中，当下次再调用 obtain 时，它们就会被复用。</p><p>因为 Android 应用是事件驱动的，因此，如果通过 new 创建 Message 会产生大量的重复的 Message 对象，导致内存占用率高、频繁 GC 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Android 源码设计模式解析与实战 · 第22章 对象共享，避免创建多对象——享元模式》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的享元模式&quot;&gt;&lt;a href=&quot;#Android-源码的享元模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的享元模式&quot;&gt;&lt;/a&gt;Android 源码的享元模式&lt;/h1&gt;&lt;h2 id=&quot;享元模式介绍&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.805Z</published>
    <updated>2020-11-27T00:56:17.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的责任链模式"><a href="#Android-源码的责任链模式" class="headerlink" title="Android 源码的责任链模式"></a>Android 源码的责任链模式</h1><h2 id="责任链模式介绍"><a href="#责任链模式介绍" class="headerlink" title="责任链模式介绍"></a>责任链模式介绍</h2><p>责任链模式是行为型设计模式之一。多个节点首尾相连接所构成的模型称为链。对于链式结构，每个节点都可以被拆开再连接，因此，链式结构也具有很好的灵活性。将这样一种结构应用于编程领域，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。我们将这种模式称为责任链模式。</p><h2 id="责任链模式的定义"><a href="#责任链模式的定义" class="headerlink" title="责任链模式的定义"></a>责任链模式的定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，只到有对象处理它为止。</p><h2 id="ViewGroup-的-dispatchTouchEvent"><a href="#ViewGroup-的-dispatchTouchEvent" class="headerlink" title="ViewGroup 的 dispatchTouchEvent"></a>ViewGroup 的 dispatchTouchEvent</h2><p>责任链模式在 Android 源码中比较类似的实现是 View 的 MotionEvent 事件分发。每当用户接触屏幕的时候，Android 都会将对应的事件包装成一个事件对象从 ViewTree 的顶部自上而下地分发传递。</p><p>ViewGroup 的 dispatchTouchEvent 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 对于辅助功能的事件处理</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理原始的 ACTION_DOWN 事件</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 这里主要是在新事件开始时，处理完上一个事件</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查事件拦截</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                <span class="comment">// 恢复事件防止其改变</span></span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事件被拦截了，则进行正常的事件分发</span></span><br><span class="line">        <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">        <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查事件是否取消</span></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有必要的话，为 DOWN 事件检查所有的目标对象</span></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果事件未被取消并未被拦截</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有辅助功能的参与，则直接将事件投递到对应的 View，否则将事件分发给所有的子 View</span></span><br><span class="line">            <span class="comment">// If the event is targeting accessibility focus we give it to the</span></span><br><span class="line">            <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">            <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">            <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">            <span class="comment">// state since these events are very rare.</span></span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果事件为起始事件</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="comment">// 如果 TouchTarget 为空并且子元素不为 0</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// 由上至下去寻找一个可以接收该事件的子 View</span></span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">// 遍历子元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果这个子元素无法接收 Pointer Event 或这个事件点压根就没有落在子元素的边界范围内，那么跳出该次循环继续遍历</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 找到 Event 改由哪个子元素持有</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 投递事件执行触摸操作</span></span><br><span class="line">                        <span class="comment">// 如果子元素还是一个 ViewGroup，则递归调用重复此过程</span></span><br><span class="line">                        <span class="comment">// 如果子元素是一个 View，那么则会调用 View 的 dispatchTouchEvent，并最终由 onTouchEvent 处理</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// 子 View 在其边界范围内接收事件</span></span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果发现没有子元素可以持有该次事件</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ViewGroup-的-dispatchTransformedTouchEvent"><a href="#ViewGroup-的-dispatchTransformedTouchEvent" class="headerlink" title="ViewGroup 的 dispatchTransformedTouchEvent"></a>ViewGroup 的 dispatchTransformedTouchEvent</h2><p>这里我们主要看看 dispatchTransformedTouchEvent 方法是如何调度子元素 dispatchTouchEvent 方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">// 如果事件被取消</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">// 如果没有子元素</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 那么就直接调用父类的 dispatchTouchEvent，注意，这里的父类终会为 View 类</span></span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有子元素则传递 cancel 事件</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算即将被传递的点的数量</span></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事件没有相应的点，那么就丢弃该事件</span></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明临时变量保存坐标转换后的 MotionEvent</span></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don&#x27;t need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="comment">// 如果事件点的数量一致</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="comment">// 子元素为空或子元素有一个单位矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="comment">// 再次区分子元素为空的情况</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为空则调用父类 dispatchTouchEvent</span></span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则尝试获取 xy 方向上的偏移量（如果通过 scrollTo 或者 scrollBy 对子视图进行滚动的话）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                <span class="comment">// 将 MotionEvent 进行坐标变换</span></span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                <span class="comment">// 再将变换后的 MotionEvent 传递给子元素</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">                <span class="comment">// 复位 MotionEvent 以便之后再次使用</span></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果通过以上的逻辑判断，当前事件被持有则可以直接返回</span></span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下述是一样的不再赘述</span></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewGroup 事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体地体现再 View 地 onTouchEvent 方法中返回值的设置，如果 onTouchEvent 返回 false，那么意味着当前 View 不会是该次事件的责任人，将不会对其持有；如果为 true 则相反，此时 View 会持有该事件并不再向外传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的责任链模式&quot;&gt;&lt;a href=&quot;#Android-源码的责任链模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的责任链模式&quot;&gt;&lt;/a&gt;Android 源码的责任链模式&lt;/h1&gt;&lt;h2 id=&quot;责任链模式介绍&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.804Z</published>
    <updated>2020-11-27T00:56:17.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的解释器模式"><a href="#Android-源码的解释器模式" class="headerlink" title="Android 源码的解释器模式"></a>Android 源码的解释器模式</h1><h2 id="解释器模式介绍"><a href="#解释器模式介绍" class="headerlink" title="解释器模式介绍"></a>解释器模式介绍</h2><p>解释器模式是一种用得比较少的行为型模式，其提供了一种解释语言的语法或表达式的方式。该模式定义了一个表达式接口，通过该接口解释一个特定的上下文。</p><h2 id="解释器模式的定义"><a href="#解释器模式的定义" class="headerlink" title="解释器模式的定义"></a>解释器模式的定义</h2><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><h2 id="PackageParser"><a href="#PackageParser" class="headerlink" title="PackageParser"></a>PackageParser</h2><p>Android 的 PackageParser 类对 AndroidManifest.xml 中的每一个组件标签创建了相应的类用以存储相应的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ActivityIntentInfo</span>&gt; <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ServiceIntentInfo</span>&gt; <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">ProviderIntentInfo</span>&gt; <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">IntentInfo</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">...</span></span><br></pre></td></tr></table></figure><p>PackageParser 为 Activity、Service、Provider 等组件在其内部以内部类的方式创建了对应的类，按照解释器模式的定义，这些类都对应 AndroidManifest.xml 文件中的一个标签，也就是一条文法，其在对该配置文件解析时充分运用了解释器模式分离实现、解释执行的特性。</p><p>在 Android 中，解析某个 apk 文件会调用到 PackageManagerService 中的 scanPackageLI 方法。</p><p>scanPackageLI 方法会调用 PackageParser 的 parsePackage 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> PackageParser.Package pkg;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pkg = pp.parsePackage(scanFile, parseFlags);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> scanPackageChildLI(pkg, parseFlags, scanFlags, currentTime, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parsePackage 方法经过多次调用，最后会调用 parseBaseApkCommon 方法，解析 AndroidManifest 的每个子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span></span><br><span class="line"><span class="function">        IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (foundApp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (RIGID_PARSER) &#123;</span><br><span class="line">                    outError[<span class="number">0</span>] = <span class="string">&quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;</span>;</span><br><span class="line">                    mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;</span>);</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foundApp = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseBaseApkCommon 调用 parseBaseApplication 解析 application 节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ApplicationInfo ai = owner.applicationInfo;</span><br><span class="line">    <span class="keyword">final</span> String pkgName = owner.applicationInfo.packageName;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123;</span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, cachedArgs, <span class="keyword">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hasActivityOrder |= (a.order != <span class="number">0</span>);</span><br><span class="line">            owner.activities.add(a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出 parseBaseApplication 发现 activity 标签时，会使用 parseActivity 解析 activity。</p><p>parseActivity 方法如下：</p><pre><code class="java">    private Activity parseActivity(Package owner, Resources res,            XmlResourceParser parser, int flags, String[] outError, CachedComponentArgs cachedArgs,            boolean receiver, boolean hardwareAccelerated)            throws XmlPullParserException, IOException &#123;        ...        while ((type=parser.next()) != XmlPullParser.END_DOCUMENT               &amp;&amp; (type != XmlPullParser.END_TAG                       || parser.getDepth() &gt; outerDepth)) &#123;            ...            if (parser.getName().equals(&quot;intent-filter&quot;)) &#123;                ActivityIntentInfo intent = new ActivityIntentInfo(a);                if (!parseIntent(res, parser, true /*allowGlobs*/, true /*allowAutoVerify*/,                        intent, outError)) &#123;                    return null;                &#125;                ...            &#125; else if (parser.getName().equals(&quot;meta-data&quot;)) &#123;                if ((a.metaData = parseMetaData(res, parser, a.metaData,                        outError)) == null) &#123;                    return null;                &#125;            ...        return a;    &#125;</code></pre><p>与 parseBaseApplication 类似，parseActivity 内部逻辑也是遍历子标签，并调用相应方法对其进行解析，比如 parseIntent 和 parseMetaData。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的解释器模式&quot;&gt;&lt;a href=&quot;#Android-源码的解释器模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的解释器模式&quot;&gt;&lt;/a&gt;Android 源码的解释器模式&lt;/h1&gt;&lt;h2 id=&quot;解释器模式介绍&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-11-27T00:56:17.803Z</published>
    <updated>2020-11-27T00:56:17.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><p>线程的创建和消耗都需要一定的开销，如果每次执行一个异步任务都需要开一个线程去执行，则这些线程的创建和销毁将消耗大量的资源，而且线程都是各自为政，很难对其进行控制，更何况有一堆的线程在执行。这时就需要线程池对线程进行管理。</p><p>在 Java 1.5 中提供了 Executor 框架用于把任务的提交和执行解耦，任务的提交交给 Runnable 或者 Callable，而 Executor 框架用来处理任务。Executor 框架中最核心的成员就是 ThreadPoolExecutor，它是线程池的核心实现类</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>可以通过 ThreadPoolExecutor 来创建一个线程池，ThreadPoolExecutor 类一共有 4 个构造方法。其中，拥有最多参数的构造方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共有 7 个参数，这些参数的作用如下：</p><ul><li><p>corePoolSize 核心线程数。默认情况下线程池是空的，只有任务提交时才会创建线程。如果当前运行的线程数少于核心线程数，则创建新的线程来处理任务。如果等于或者多于核心线程数，则不再创建。如果调用线程池的 prestartAllCoreThreads 方法，线程池会提前创建并且启动所有的核心线程来等待任务。</p></li><li><p>maximumPoolSize 线程池允许创建的最大线程数。如果任务队列满了并且线程数小于 maximumPoolSize，则线程池仍旧会创建新的线程来处理任务。</p></li><li><p>keepAliveTime 非核心线程闲置的超时时间。如果超过这个时间就回收线程。如果任务很多，并且每个任务的执行时间很短，则可以调大 keepAliveTime 来提高线程的利用率。另外，如果设置 allowCoreThreadTimeout 为 true （通过 allowsCoreThreadTimeOut 方法），keepAliveTime 也会应用到核心线程上。</p></li><li><p>TimeUnit keepAliveTime 参数的时间单位。可选单位有天、小时、分钟、秒、毫秒等。</p></li><li><p>workQueue 任务队列。如果当前任务数大于核心线程数，则将任务添加到任务队列。这里的任务队列是阻塞队列（BlockingQueue）。</p></li><li><p>ThreadFactory 线程工厂。可以用线程工厂来给每个创建出来的线程设置名字。如果不设置会使用默认的线程工厂。</p></li><li><p>RejectedExecutionHandler 饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是 AbortPolicy，表示无法处理新任务，并抛出 RejectedExecutionException 异常。除此之外还有 3 中策略，它们分别如下：</p></li></ul><ol><li><p>CallerRunsPolicy 用调用者所在的线程处理任务。此任务提供简单的反馈控制机制，能够减缓新任务的提交速度。</p></li><li><p>DiscardPolicy 不能执行的任务，并将该任务删除。</p></li><li><p>DiscardOldestPolicy 丢弃队列最近的任务，并执行当前的任务。</p></li></ol><h2 id="线程池的处理流程和原理"><a href="#线程池的处理流程和原理" class="headerlink" title="线程池的处理流程和原理"></a>线程池的处理流程和原理</h2><p>线程池的处理流程主要可以分为 3 个步骤，如下所示：</p><ol><li><p>提交任务后，线程池先判断线程数是否达到了核心线程数 corePoolSize。如果未达到核心线程数，则创建核心线程处理任务。否则就执行下一步操作。</p></li><li><p>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。</p></li><li><p>如果任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则就执行饱和策略，默认会抛出 RejectedExecutionException 异常。</p></li></ol><p>如果我们执行 ThreadPoolExecutor 的 execute 方法，会遇到各种情况：</p><ol><li><p>如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。</p></li><li><p>如果线程数大于或者等于核心线程数，则将任务加入到任务队列，线程池中的空闲线程会不断地从任务队列中取出任务进行处理。</p></li><li><p>如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。</p></li><li><p>如果线程数超过了最大线程数，则执行饱和策略。</p></li></ol><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p>通过直接或者间接地配置 ThreadPoolExecutor 的参数可以创建不同类型的 ThreadPoolExecutor，其中有几种线程池比较常用，它们分别是 FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool、ForkJoinPool。</p><ul><li>FixedThreadPool</li></ul><p>FixedThreadPool 是可重用固定线程数的线程池。在 Executors 类提供了创建 FixedThreadPool 的方法 newFixedThreadPool，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都设置为创建 FixedThreadPool 指定的参数 nThreads，也就是说 FixedThreadPool 只有核心线程，并且数量是固定的，没有非核心线程。keekAliveTime 设置为 0L 意味者多余的线程会被立即终止。因为不会产生多余的线程，所以 keepAliveTime 是无效的参数。另外，任务队列采用了无界的阻塞队列 LinkedBlockingQueue。</p><p>当执行 FixedThreadPool 的 execute 方法时，如果当前运行的线程未达到 corePoolSize （核心线程数）时就创建核心线程来处理任务，如果达到了核心线程数则将任务添加到 LinkedBlockingQueue 中。FixedThreadPool 就是一个有固定数量核心线程的线程池，并且这些核心线程不会被回收。当线程数超过 corePoolSize 时，就将任务存储在任务队列中；当线程池有空闲线程时，则从任务队列中去取任务执行。</p><ul><li>CachedThreadPool</li></ul><p>CachedThreadPool 是一个根据需要创建线程的线程池，创建 CachedThreadPool 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 的 corePoolSize 是 0，maximumPoolSize 设置为 Integer.MAX_VALUE，这意味着 CachedThreadPool 没有核心线程，非核心线程是无界的。keepAliveTime 设置为 60L，则空闲线程等待新任务的最长时间为 60s。在此用了阻塞队列 SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。</p><p>当执行 execute 方法时，首先会执行 SynchronousQueue 的 offer 方法来提交任务，并且查询线程池中是否有空闲的线程执行 SynchronousQueue 的 poll 方法来移除任务。如果有则配对成功，将任务交给这个空闲的线程处理；如果没有则配对失败，创建新的线程处理任务。当线程池中的线程空闲时，它会执行 SynchronousQueue 的 poll 方法，等待 SynchronousQueue 中新提交的任务。如果超过 60s 没有新任务提交到 SynchronousQueue，这个空闲线程将终止。</p><p>因为 maximumPoolSize 是无界的，所以如果提交的任务大于线程池中线程的处理速度，就会不断地创建新线程。另外，每次提交任务都会立即有线程去处理。所以，CachedThreadPool 比较适合有大量任务处理，但是每个任务耗时较少地情况。</p><ul><li>SingleThreadExecutor</li></ul><p>SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 都为 1，意味着 SingleThreadExecutor 只有一个核心线程，其他参数和 FixedThreadPool 一样。</p><p>但是 SingleThreadExecutor 使用 FinalizableDelegatedExecutorService 封装了一次，在封装类中只暴露了 ExecutorService 接口的方法，这意味着 ThreadPoolExecutor 里面的 public 方法对 SingleThreadExecutor 来说是无法调用的。也就是说 SingleThreadExecutor 是无法配置线程池的各个参数的，但是 FixedThreadPool 和 ThreadPoolExecutor 可以自由配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 execute 方法时，如果当前运行的线程数未达到核心线程数，也就是当前没有运行的线程，则创建一个新线程来处理任务。如果当前有运行的线程，则将任务添加到阻塞队列 LinkedBlockingQueue 中。因此，SingleThreadExecutor 能确保所有的任务在一个线程中按照顺序执行。</p><ul><li>ScheduledThreadPool</li></ul><p>ScheduledThreadPool 是一个能实现定时和周期性任务的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor 并且实现了 ScheduledExecutorService 接口。它主要用于给定延时之后的运行任务或者定期处理任务。</p><p>ScheduledThreadPoolExecutor 的构造方法调用了 ThreadPoolExecutor 的构造方法。corePoolSize 是传进来固定的数值，maximumPoolSize 的值是 Integer.MAX_VALUE。因 为 DelayedWorkQueue 是无界的，所以 Integer.MAX_VALUE 是无效的，总是用核心线程处理阻塞队列的任务。</p><p>当执行 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate 或者 scheduleWithFixedDelay 方法时，会向 DelayedWorkQueue 添加一个 ScheduledFutureTask，并检查运行的线程是否达到 corePoolSize。如果没有则创建新线程并启动它，但是并不是立即去执行任务，而是去 DelayedWorkQueue 中取 ScheduledFutureTask，然后去执行任务。如果运行的线程达到了 corePoolSize 时，则将任务添加到 DelayedWorkQueue 中。DelayedWorkQueue 会将任务进行排序，先要执行的任务放在队列的前面。与此前介绍的线程池不同的是，当执行完任务后，会将 ScheduledFutureTask 中的 time 变量改为下次要执行的时间，并且放回到 DelayedWorkQueue 中。</p><ul><li>ForkJoinPool</li></ul><p>Executors 中的 newWorkStealingPool 方法提供了工作窃取线程池，它是一个 ForkJoinPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newWorkStealingPool 构造了一个与 CPU 处理器核数相同的 ForkJoinPool，它适合多核并行计算的场景。</p><p>与其他线程池不同，ForkJoinPool 没有使用或者继承 ThreadPoolExecutor。它继承了 AbstractExecutorService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>java.util.concurrent 包中的 CompletableFuture 就用到了 ForkJoinPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMMON_POOL =</span><br><span class="line">    (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class="line"><span class="comment"> * support parallelism.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor ASYNC_POOL = USE_COMMON_POOL ?</span><br><span class="line">    ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出如果机器 CPU 支持并行计算就会使用 ForkJoinPool。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程池&quot;&gt;&lt;a href=&quot;#Java-线程池&quot; class=&quot;headerlink&quot; title=&quot;Java 线程池&quot;&gt;&lt;/a&gt;Java 线程池&lt;/h1&gt;&lt;p&gt;线程的创建和消耗都需要一定的开销，如果每次执行一个异步任务都需要开一个线程去执行，则这些线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BB%93%E5%90%88%20OkHttp%20%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BB%93%E5%90%88%20OkHttp%20%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C/</id>
    <published>2020-11-27T00:56:17.802Z</published>
    <updated>2020-11-27T00:56:17.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJava-结合-OkHttp-访问网络"><a href="#RxJava-结合-OkHttp-访问网络" class="headerlink" title="RxJava 结合 OkHttp 访问网络"></a>RxJava 结合 OkHttp 访问网络</h1><p>这里以访问 Github api 为例。</p><h2 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h2><p>首先使用 create 方法创建 Observable，在回调方法中使用 OkHttp 异步请求网络，然后将返回结果发送给 emitter 的 onNext 方法。同时实现 emitter 的 onError 和 onComplete。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;String&gt; <span class="title">getObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">            Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;https://api.github.com/users/flutter&quot;</span>)</span><br><span class="line">                    .get()</span><br><span class="line">                    .build();</span><br><span class="line">            Call call = okHttpClient.newCall(request);</span><br><span class="line">            call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> </span>&#123;</span><br><span class="line">                    emitter.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String str = response.body().string();</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;onResponse:&quot;</span> + response + <span class="string">&quot;, body:&quot;</span> + str);</span><br><span class="line">                    emitter.onNext(str);</span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="订阅观察者-Observer"><a href="#订阅观察者-Observer" class="headerlink" title="订阅观察者 Observer"></a>订阅观察者 Observer</h2><p>观察者订阅代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAsyncHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable&lt;String&gt; observable = getObservable();</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(str -&gt; Toast.makeText(getApplicationContext(), <span class="string">&quot;load success:&quot;</span> + str, Toast.LENGTH_LONG).show(),</span><br><span class="line">                    throwable -&gt; Log.e(TAG, <span class="string">&quot;onError:&quot;</span> + throwable.getMessage()), () -&gt; Log.d(TAG, <span class="string">&quot;onCompleted&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者收到 onNext 消息后发送 Toast。因为使用了 observeOn 方法运行在 Android 主线程，所以可以做 UI 操作。</p><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxJavaActivity: onResponse:Response&#123;protocol&#x3D;http&#x2F;1.1, code&#x3D;200, message&#x3D;OK, url&#x3D;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;flutter&#125;, body:&#123;&quot;login&quot;:&quot;flutter&quot;,&quot;id&quot;:14101776, ...</span><br></pre></td></tr></table></figure><h2 id="添加网络权限"><a href="#添加网络权限" class="headerlink" title="添加网络权限"></a>添加网络权限</h2><p>网络请求需要在 AndroidManifest 添加网络权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>如果是 P 版本以上的非 Https 请求，需要在 application 节点配置允许明文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:networkSecurityConfig&#x3D;&quot;@xml&#x2F;network_security_config&quot;</span><br></pre></td></tr></table></figure><p>res/xml 目录的 network_security_config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;network-security-config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RxJava-结合-OkHttp-访问网络&quot;&gt;&lt;a href=&quot;#RxJava-结合-OkHttp-访问网络&quot; class=&quot;headerlink&quot; title=&quot;RxJava 结合 OkHttp 访问网络&quot;&gt;&lt;/a&gt;RxJava 结合 OkHttp 访问网络&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/VirtualAPK%20%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.okclouder.cn/2020/11/27/VirtualAPK%20%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-27T00:56:17.802Z</published>
    <updated>2020-11-27T00:56:17.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VirtualAPK-插件化框架介绍"><a href="#VirtualAPK-插件化框架介绍" class="headerlink" title="VirtualAPK 插件化框架介绍"></a>VirtualAPK 插件化框架介绍</h1><p><a href="https://github.com/didi/VirtualAPK">VirtualAPK</a> 是一个 Android 插件化框架。如果一个 APK 有很多功能，其中一些功能使用的场景比较少，那么可以在这些功能被使用的时候动态加载，而不是一次性打包在整个 APK 中。插件化不仅可以缩小 APK 体积，也方便各个插件特性的动态更新。</p><p>使用 VirtualAPK 需要对主 APK （宿主）和插件 APK（插件）做一些修改定制。这里以 VirtualAPK 0.9.8 版本为例。</p><h2 id="主-APK-配置"><a href="#主-APK-配置" class="headerlink" title="主 APK 配置"></a>主 APK 配置</h2><p>在主 APK 的项目 build.gradle 配置 VirtualAPK 的插件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ....</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:3.2.0&#39;</span><br><span class="line">        classpath &#39;com.didi.virtualapk:gradle:0.9.8.6&#39;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是 gradle:3.2.0 的插件，如果使用 3.5 版本的 gradle，会出现 android 的 gradle 插件和 VirtualAPK 插件不兼容的情况，具体可以看 VirtualAPK 在 github 的 issue。</p><p>如果主 APK 使用了 AndroidX，也建议 android 的 gradle 插件版本在 3.2.0 以上，这样才能将 VirtualAPK 源码中对应 support 包的引用自动转换为 AndroidX。</p><p>然后配置主模块 app 的 build.gradle：</p><p>配置插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.didi.virtualapk.host&#39;</span><br></pre></td></tr></table></figure><p>配置依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; virtualapk</span><br><span class="line">    implementation &#39;com.didi.virtualapk:core:0.9.8&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 proguard 混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.didi.virtualapk.internal.VAInstrumentation &#123; *; &#125;</span><br><span class="line">-keep class com.didi.virtualapk.internal.PluginContentResolver &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">-dontwarn com.didi.virtualapk.**</span><br><span class="line">-dontwarn android.**</span><br><span class="line">-keep class android.** &#123; *; &#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">最后在 Application 的 attachBaseContext 方法中初始化 VirtualAPK</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Override</span><br><span class="line">protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    PluginManager.getInstance(base).init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为宿主 APK 需要加载插件，所以需要读取外部存储的权限（READ_EXTERNAL_STORAGE）。同时在 AndroidManifest 声明权限如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>以宿主 APK 的 HostActivity 启动插件 APK 的 MainActivity（com.android.plugin.MainActivity）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQ_WRITE_STORAGE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line">            <span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, REQ_WRITE_STORAGE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                launchPlugin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            launchPlugin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launchPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;virtualapk:&quot;</span>, <span class="string">&quot;launchPlugin&quot;</span>);</span><br><span class="line">        String pluginPath = Environment.getExternalStorageDirectory().getAbsolutePath().concat(<span class="string">&quot;/Test.apk&quot;</span>);</span><br><span class="line">        File plugin = <span class="keyword">new</span> File(pluginPath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            intent.setClassName(<span class="string">&quot;com.android.plugin&quot;</span>, <span class="string">&quot;com.android.plugin.MainActivity&quot;</span>);</span><br><span class="line">            LoadedPlugin loadedPlugin = PluginManager.getInstance(<span class="keyword">this</span>).getLoadedPlugin(intent);</span><br><span class="line">            <span class="keyword">if</span> (loadedPlugin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                PluginManager.getInstance(<span class="keyword">this</span>).loadPlugin(plugin);</span><br><span class="line">            &#125;</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;virtualapk:&quot;</span>, <span class="string">&quot;e:&quot;</span> + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQ_WRITE_STORAGE) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launchPlugin 首先从外部存储中加载插件 APK，如果插件 APK 已经加载过了，就直接跳转，否则先调用 loadPlugin 方法加载插件。</p><p>如果正常运行，宿主 APK 会先启动 HostActivity，然后立即跳转到插件 APK 的 MainActivity，显示插件 APK 的内容。</p><h2 id="插件-APK-配置"><a href="#插件-APK-配置" class="headerlink" title="插件 APK 配置"></a>插件 APK 配置</h2><p>在插件 APK 的项目 build.gradle 配置 VirtualAPK 的插件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:3.1.0&#39;</span><br><span class="line">        classpath &#39;com.didi.virtualapk:gradle:0.9.8.6&#39;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着配置 app 模块的 build.gradle：</p><p>配置插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.didi.virtualapk.plugin&#39;</span><br></pre></td></tr></table></figure><p>可以看出插件 APK 只需要配置 com.didi.virtualapk.plugin，而不用配置依赖，因为插件 APK 这时只是作为被依赖的。</p><p>最后需要配置 virtualApk 的定制配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtualApk &#123;</span><br><span class="line">    packageId &#x3D; 0x6f             &#x2F;&#x2F; The package id of Resources.</span><br><span class="line">    targetHost&#x3D;&#39;C:&#x2F;Users&#x2F;m&#x2F;AndroidStudioProjects&#x2F;AndroidSample&#x2F;app&#39; &#x2F;&#x2F; The path of application module in host project.</span><br><span class="line">    applyHostMapping &#x3D; true      &#x2F;&#x2F; [Optional] Default value is true.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是第二项配置，targetHost 表示主 APK 的 app 模块的路径，可以是绝对路径，可以是相对路径。这里用的是绝对路径。</p><p>如果插件 APK 的资源和主 APK 的资源名称相同，建议修改为其他名称和主 APK 的命名区分开。</p><p>比如 R.layout.activity_main 改名为 R.layout.activity_plugin_main</p><p>最后编译插件 APK 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean assemblePlugin</span><br></pre></td></tr></table></figure><p>注意插件 APK 必须要先配置好签名，不能用 debug 模式编译。</p><p>生成的插件 APK 位于 Plugin\app\build\outputs\plugin\release 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.plugin_20190921151552.apk</span><br></pre></td></tr></table></figure><p>然后将插件 APK 重命名为 Test.apk push 到手机的 /mnt/sdcard/ 目录，方便主 APK 从外部存储加载插件 APK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>VirtualAPK 是一个 Android 插件化框架，它支持四大组件以及资源的插件化。同时 VirtualAPK 有它自己的 Gradle 插件，宿主 APK 和 插件 APK 需要用 VirtualAPK 的 Gradle 插件编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VirtualAPK-插件化框架介绍&quot;&gt;&lt;a href=&quot;#VirtualAPK-插件化框架介绍&quot; class=&quot;headerlink&quot; title=&quot;VirtualAPK 插件化框架介绍&quot;&gt;&lt;/a&gt;VirtualAPK 插件化框架介绍&lt;/h1&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Dart%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.okclouder.cn/2020/11/27/Dart%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-27T00:56:17.800Z</published>
    <updated>2020-11-27T00:56:17.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart-语法简介"><a href="#Dart-语法简介" class="headerlink" title="Dart 语法简介"></a>Dart 语法简介</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>int 整数（-2^63 ~ 2^63-1）</p><p>double 双精度浮点数</p><p>num 既可以表示整数，也可以表示浮点数</p><p>String 字符串，采用 UTF-16 编码</p><p>bool 布尔值</p><p>List 列表</p><p>Set 集合</p><p>Map 键值对</p><p>Runes 表示采用 UTF-32 的字符串</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>?? 操作符</p><p>a ?? b 表示如果 a 是 null，那么表达式返回 b，否则返回 a。<br>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (a &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return b;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>??= 操作符</p><p>a ??= b 等价于 a = a ?? b</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是对象，它的类型是 Function。</p><p>返回值 函数名（参数） {</p><p>}</p><p>=&gt; 箭头函数</p><p>=&gt; 后面只能跟表达式，不能跟多个语句。表达式可以是函数或者值。</p><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    return expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>每个对象都是类的实例。所有类都继承自 Object 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dart-语法简介&quot;&gt;&lt;a href=&quot;#Dart-语法简介&quot; class=&quot;headerlink&quot; title=&quot;Dart 语法简介&quot;&gt;&lt;/a&gt;Dart 语法简介&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-11-27T00:56:17.799Z</published>
    <updated>2020-11-27T00:56:17.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-知识路线"><a href="#Android-知识路线" class="headerlink" title="Android 知识路线"></a>Android 知识路线</h1><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="Android-四大组件"><a href="#Android-四大组件" class="headerlink" title="Android 四大组件"></a>Android 四大组件</h3><p>Activity</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774856">Activity 难点</a></p><p>Service</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774909">Service 难点</a></p><p>ContentProvider</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774994">ContentProvider 难点</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100718356">ContentProvider 的 query 流程分析</a></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 的绘制</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774749">View 的绘制流程</a></p><p>事件分发</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774628">View 的绘制流程</a></p><p>RemoteViews<br><a href="https://blog.csdn.net/caoshen2014/article/details/99775098">Android RemoveViews</a></p><p>Window 和 ViewRootImpl</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99775159">Android Window</a></p><h3 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h3><p>Binder</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710327">Binder 笔记</a></p><p>AIDL</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710365">AIDL</a></p><p>多进程</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710355">Android 中的 IPC 方式</a></p><h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><p>消息队列 </p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774788">Android 消息机制</a></p><p>AsyncTask 原理</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782462">AsyncTask 异步任务</a></p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>AMS</p><p>WMS</p><p>PMS</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100753666">Android setPackagesSuspended 暂停应用</a></p><h2 id="开源库原理"><a href="#开源库原理" class="headerlink" title="开源库原理"></a>开源库原理</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>OkHttp</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782656">Okhttp 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782712">OkHttp 源码解析</a></p><p>Retrofit</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782769">Retrofit 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782825">Retrofit 源码分析</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Glide</p><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>Rxjava</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782892">Android RxJava 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100088147">RxJava 操作符介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100111136">RxJava 线程控制</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100129281">RxJava 结合 OkHttp 访问网络</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100181182">RxJava 结合 Retrofit 访问网络</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100188837">用 RxJava 实现 RxBus</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100603080">RxJava 线程切换过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100436237">RxJava 订阅过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100548442">RxJava 的 Map 变换过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100603080">RxJava 线程切换过程解析</a></p><h3 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h3><p>ButterKnife</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100831887">ButterKnife View 注解框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100852352">ButterKnife View 注解框架原理解析</a></p><p>Dagger2</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101002939">Dagger2 依赖注入框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101042600">Dagger2 依赖注入的原理分析</a></p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Groovy</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102426429">Groovy 语法简介</a></p><p>Gradle 插件基础</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102493114">Gradle 脚本的执行时序</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102512720">Gradle 自定义 task</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102528973">Gradle 插件基础</a></p><h2 id="初级架构"><a href="#初级架构" class="headerlink" title="初级架构"></a>初级架构</h2><p>设计模式</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102596842">Java 设计模式基本原则</a></p><p>MVC、MVP、MVVM</p><p>组件化</p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI 基础</p><p>NDK 基础</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>dalvik 沙盒机制</p><p>逆向工具：dex2jar jadx jd-gui</p><p>smali &amp; apktool</p><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>热修复：Tinker</p><p>插件化：VirtualAPK</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101108723">VirtualAPK 插件化框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101401674">VirtualAPK 插件化原理分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-知识路线&quot;&gt;&lt;a href=&quot;#Android-知识路线&quot; class=&quot;headerlink&quot; title=&quot;Android 知识路线&quot;&gt;&lt;/a&gt;Android 知识路线&lt;/h1&gt;&lt;h2 id=&quot;核心知识点&quot;&gt;&lt;a href=&quot;#核心知识点&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Flutter%20TabBar%20%E6%A0%87%E7%AD%BE/"/>
    <id>https://www.okclouder.cn/2020/11/27/Flutter%20TabBar%20%E6%A0%87%E7%AD%BE/</id>
    <published>2020-11-27T00:56:17.798Z</published>
    <updated>2020-11-27T00:56:17.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-TabBar-标签"><a href="#Flutter-TabBar-标签" class="headerlink" title="Flutter TabBar 标签"></a>Flutter TabBar 标签</h1><p>Flutter 实现标签左右滑动切换，可以使用 TabBar 和 TabBarView。TabBar 和 TabBarView 分别表示标签和标签对应的内容页面。</p><h2 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h2><p>TabBar 需要指定一个 TabController 才能使用，TabController 用来控制 TabBar 的切换。</p><p>unselectedLabelColor： 未选中的标签的颜色。</p><p>labelColor：选中的标签的颜色。</p><p>indicatorColor：标签下方指示器线条的颜色。</p><p>indicatorSize：标签下方指示器线条的长度。如果是 label，表示和标签内容长度一样，如果是 tab，表示和整个标签长度一样长，即上一个标签的右边到下一个标签左边的长度。</p><p>tabs：表示每个标签的 widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  constraints: BoxConstraints.expand(height: <span class="number">50</span>),</span><br><span class="line">  child: TabBar(</span><br><span class="line">      controller: _controller,</span><br><span class="line">      unselectedLabelColor: Colors.black,</span><br><span class="line">      labelColor: Colors.blue,</span><br><span class="line">      indicatorColor: Colors.blue,</span><br><span class="line">      indicatorSize: TabBarIndicatorSize.label,</span><br><span class="line">      tabs: [</span><br><span class="line">        Tab(text: <span class="string">&quot;未结束&quot;</span>),</span><br><span class="line">        Tab(text: <span class="string">&quot;已结束&quot;</span>),</span><br><span class="line">        Tab(text: <span class="string">&quot;我的比赛&quot;</span>)</span><br><span class="line">      ]),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="TabBarView"><a href="#TabBarView" class="headerlink" title="TabBarView"></a>TabBarView</h2><p>TabBarView 指的是每个标签对应的内容界面，这个设置成 Expanded 可以扩展到整个内容区域。</p><p>TabBarView 也需要指定 TabController 和 每个标签下的 widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Expanded(</span><br><span class="line">  child: TabBarView(controller: _controller, children: [</span><br><span class="line">    ScoreListWidget(_isLoaded, _unFinishedMatches),</span><br><span class="line">    ScoreListWidget(_isLoaded, _finishedMatches),</span><br><span class="line">    Center(child: Text(<span class="string">&quot;我的比赛&quot;</span>))</span><br><span class="line">  ]),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="TabController"><a href="#TabController" class="headerlink" title="TabController"></a>TabController</h2><p>TabController 用来控制内容切换，可以将 TabBar 和 TabBarView 嵌套在一个 DefaultTabController 中。也可以使用自定义的 TabController。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_controller = TabController(length: <span class="number">3</span>, vsync: ScrollableState());</span><br><span class="line">_controller.addListener(() =&gt; &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_controller.index == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>TabController 通过 length 指定标签的个数。addListener 可以添加标签的滑动监听。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flutter-TabBar-标签&quot;&gt;&lt;a href=&quot;#Flutter-TabBar-标签&quot; class=&quot;headerlink&quot; title=&quot;Flutter TabBar 标签&quot;&gt;&lt;/a&gt;Flutter TabBar 标签&lt;/h1&gt;&lt;p&gt;Flutter 实现</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20setPackagesSuspended%20%E6%9A%82%E5%81%9C%E5%BA%94%E7%94%A8/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20setPackagesSuspended%20%E6%9A%82%E5%81%9C%E5%BA%94%E7%94%A8/</id>
    <published>2020-11-27T00:56:17.797Z</published>
    <updated>2020-11-27T00:56:17.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-setPackagesSuspended-暂停应用"><a href="#Android-setPackagesSuspended-暂停应用" class="headerlink" title="Android setPackagesSuspended 暂停应用"></a>Android setPackagesSuspended 暂停应用</h1><p>setPackagesSuspended 是 PackageManager 的一个 public 方法，它可以用来暂停应用。<br>应用被暂停之后会进入 Suspended 状态，无法点击打开，会弹出一个系统对话框，提示应用已被暂停。应用的后台活动比如播放音乐也会被暂停。<br>Android 数字健康（com.google.android.apps.wellbeing)就是利用 setPackagesSuspended 方法暂停应用，达到限制应用使用的效果。</p><h2 id="setPackagesSuspended"><a href="#setPackagesSuspended" class="headerlink" title="setPackagesSuspended"></a>setPackagesSuspended</h2><p>setPackagesSuspended 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission(Manifest.permission.SUSPEND_APPS)</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspended(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        <span class="meta">@Nullable</span> PersistableBundle appExtras, <span class="meta">@Nullable</span> PersistableBundle launcherExtras,</span><br><span class="line">        String dialogMessage) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;setPackagesSuspended not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 setPackagesSuspended 是系统 api 方法，而且需要在 manifest 定义权限 Manifest.permission.SUSPEND_APPS。<br>Manifest.permission.SUSPEND_APPS 权限也是系统级别的。普通应用没有权限，只用系统应用可以使用 setPackagesSuspended。同时 setPackagesSuspended 也是 hide 方法。</p><p>setPackagesSuspended 的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPackageManager().setPackagesSuspended(packageNames, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, dialogMessage);</span><br></pre></td></tr></table></figure><p>getPackageManager 是 Context 类的抽象方法，本质上是调用了 ContextImpl 的 getPackageManager 方法。</p><p>getPackageManager() 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn&#x27;t matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出构造了一个 ApplicationPackageManager，传入 context 和 IPackageManager。IPackageManager 是一个 binder 接口，从 ServiceManager 通过 getService 获取。</p><h2 id="ApplicationPackageManager-setPackagesSuspended"><a href="#ApplicationPackageManager-setPackagesSuspended" class="headerlink" title="ApplicationPackageManager setPackagesSuspended"></a>ApplicationPackageManager setPackagesSuspended</h2><p>查看 ApplicationPackageManager 的 setPackagesSuspended 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspended(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        PersistableBundle appExtras, PersistableBundle launcherExtras,</span><br><span class="line">        String dialogMessage) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPM.setPackagesSuspendedAsUser(packageNames, suspended, appExtras,</span><br><span class="line">                launcherExtras, dialogMessage, mContext.getOpPackageName(),</span><br><span class="line">                mContext.getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出远程调用了 PMS 的 setPackagesSuspendedAsUser，传入了应用自身的包名和 uid。</p><h2 id="PMS-的-setPackagesSuspendedAsUser"><a href="#PMS-的-setPackagesSuspendedAsUser" class="headerlink" title="PMS 的 setPackagesSuspendedAsUser"></a>PMS 的 setPackagesSuspendedAsUser</h2><p>PMS 的 setPackagesSuspendedAsUser 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspendedAsUser(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        PersistableBundle appExtras, PersistableBundle launcherExtras,</span><br><span class="line">        SuspendDialogInfo dialogInfo, String callingPackage, <span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packageNames.length; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            pkgSetting.setSuspended(suspended, callingPackage, dialogInfo, appExtras,</span><br><span class="line">                    launcherExtras, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!changedPackagesList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] changedPackages = changedPackagesList.toArray(</span><br><span class="line">                <span class="keyword">new</span> String[changedPackagesList.size()]);V</span><br><span class="line">        sendPackagesSuspendedForUser(</span><br><span class="line">                changedPackages, changedUids.toArray(), userId, suspended, launcherExtras);</span><br><span class="line">        sendMyPackageSuspendedOrUnsuspended(changedPackages, suspended, appExtras, userId);</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            scheduleWritePackageRestrictionsLocked(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unactionedPackages.toArray(<span class="keyword">new</span> String[unactionedPackages.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码调用了 pkgSetting.setSuspended，然后调用了 sendPackagesSuspendedForUser、sendMyPackageSuspendedOrUnsuspended。<br>setPackagesSuspendedAsUser 返回了 unactionedPackages，也就是没有被 suspend 的应用。</p><p>pkgSetting 的 setSuspended 方法其实就是 PackageSettingBase 的 setSuspended。</p><p>PackageSettingBase 的 setSuspended 方法会将 PackageUserState 的 suspended 改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">existingUserState.suspended = suspended;</span><br></pre></td></tr></table></figure><p>在 PackageParser 的 updateApplicationInfo 会更新应用的 applicationInfo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state.suspended) &#123;</span><br><span class="line">    ai.flags |= ApplicationInfo.FLAG_SUSPENDED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ai.flags &amp;= ~ApplicationInfo.FLAG_SUSPENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出会根据 PackageUserState 的 suspended 属性添加或者删除 ApplicationInfo.FLAG_SUSPENDED。</p><p>FWK 中的其他地方判断一个应用是否被暂停了就是依靠这个 ApplicationInfo.FLAG_SUSPENDED 标记。</p><p>比如 ActivityStartInterceptor 应用启动拦截的 interceptSuspendedPackageIfNeeded 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not intercept if the package is not suspended</span></span><br><span class="line"><span class="keyword">if</span> (mAInfo == <span class="keyword">null</span> || mAInfo.applicationInfo == <span class="keyword">null</span> ||</span><br><span class="line">        (mAInfo.applicationInfo.flags &amp; FLAG_SUSPENDED) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果应用没有 ApplicationInfo.FLAG_SUSPENDED（mAInfo.applicationInfo.flags &amp; FLAG_SUSPENDED），说明它没有被暂停，不要拦截它的启动。</p><h2 id="sendPackagesSuspendedForUser"><a href="#sendPackagesSuspendedForUser" class="headerlink" title="sendPackagesSuspendedForUser"></a>sendPackagesSuspendedForUser</h2><p>sendPackagesSuspendedForUser 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPackagesSuspendedForUser</span><span class="params">(String[] pkgList, <span class="keyword">int</span>[] uidList, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> suspended, PersistableBundle launcherExtras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bundle extras = <span class="keyword">new</span> Bundle(<span class="number">3</span>);</span><br><span class="line">        extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST, pkgList);</span><br><span class="line">        extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST, uidList);</span><br><span class="line">        <span class="keyword">if</span> (launcherExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            extras.putBundle(Intent.EXTRA_LAUNCHER_EXTRAS,</span><br><span class="line">                    <span class="keyword">new</span> Bundle(launcherExtras.deepCopy()));</span><br><span class="line">        &#125;</span><br><span class="line">        sendPackageBroadcast(</span><br><span class="line">                suspended ? Intent.ACTION_PACKAGES_SUSPENDED</span><br><span class="line">                        : Intent.ACTION_PACKAGES_UNSUSPENDED,</span><br><span class="line">                <span class="keyword">null</span>, extras, Intent.FLAG_RECEIVER_REGISTERED_ONLY, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;userId&#125;, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码将参数封装到 bundle 中，然后发送了广播。广播 Action 是 Intent.ACTION_PACKAGES_SUSPENDED 或者 Intent.ACTION_PACKAGES_UNSUSPENDED。</p><p>sendPackageBroadcast 会调用 doSendBroadcast，然后调用 AMS 的 broadcastIntent。</p><h2 id="sendMyPackageSuspendedOrUnsuspended"><a href="#sendMyPackageSuspendedOrUnsuspended" class="headerlink" title="sendMyPackageSuspendedOrUnsuspended"></a>sendMyPackageSuspendedOrUnsuspended</h2><p>sendMyPackageSuspendedOrUnsuspended 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMyPackageSuspendedOrUnsuspended</span><span class="params">(String[] affectedPackages, <span class="keyword">boolean</span> suspended,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle appExtras, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">        action = Intent.ACTION_MY_PACKAGE_SUSPENDED;</span><br><span class="line">        <span class="keyword">if</span> (appExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Bundle bundledAppExtras = <span class="keyword">new</span> Bundle(appExtras.deepCopy());</span><br><span class="line">            intentExtras.putBundle(Intent.EXTRA_SUSPENDED_PACKAGE_EXTRAS, bundledAppExtras);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action = Intent.ACTION_MY_PACKAGE_UNSUSPENDED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendMyPackageSuspendedOrUnsuspended 也是发送广播，只不过它发送了 Intent.ACTION_MY_PACKAGE_SUSPENDED 和 Intent.ACTION_MY_PACKAGE_UNSUSPENDED。<br>被暂停的应用可以通过注册这两个 Action 的广播来通知自己是否被暂停了。另外被暂停的应用也可以使用 isPackageSuspended 方法判断自己是否处于暂停状态。</p><h2 id="ACTION-PACKAGES-SUSPENDED-广播接收"><a href="#ACTION-PACKAGES-SUSPENDED-广播接收" class="headerlink" title="ACTION_PACKAGES_SUSPENDED 广播接收"></a>ACTION_PACKAGES_SUSPENDED 广播接收</h2><p>查看 AMS 的 broadcastIntentLocked 方法，里面对 ACTION_PACKAGES_SUSPENDED 广播做了处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line"><span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">            intent.getAction());</span><br><span class="line">    <span class="keyword">final</span> String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">            Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userHandle = intent.getIntExtra(</span><br><span class="line">            Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">    mAtmInternal.onPackagesSuspendedChanged(packageNames, suspended,</span><br><span class="line">            userHandle);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以看出以上代码调用了 mAtmInternal.onPackagesSuspendedChanged 方法。</p><p>mAtmInternal 是ActivityTaskManagerService (ATMS)，它调用了 RecentTasks 的 onPackagesSuspendedChanged 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPackagesSuspendedChanged</span><span class="params">(String[] packages, <span class="keyword">boolean</span> suspended, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        mRecentTasks.onPackagesSuspendedChanged(packages, suspended, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecentTasks 的 onPackagesSuspendedChanged 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPackagesSuspendedChanged</span><span class="params">(String[] packages, <span class="keyword">boolean</span> suspended, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">            <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">                mSupervisor.removeTaskByIdLocked(tr.taskId, <span class="keyword">false</span>,</span><br><span class="line">                        REMOVE_FROM_RECENTS, <span class="string">&quot;suspended-package&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果应用被暂停，它会从 tasks 中移除。</p><p>除了 AMS， NMS（NotificationManagerService）、WMS（WindowManagerService）和其他一些地方也注册了 ACTION_PACKAGES_SUSPENDED 广播。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>PacakgeManager 的 setPackagesSuspended 方法可以暂停或者恢复应用。</li><li>setPackagesSuspended 通过 PMS 改变 ApplicationInfo 的 FLAG_SUSPENDED 标记和发送 ACTION_PACKAGES_SUSPENDED、ACTION_MY_PACKAGE_SUSPENDED 通知 FWK 的其他服务（AMS 等）实现应用暂停的效果。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-setPackagesSuspended-暂停应用&quot;&gt;&lt;a href=&quot;#Android-setPackagesSuspended-暂停应用&quot; class=&quot;headerlink&quot; title=&quot;Android setPackagesSuspend</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E6%BA%90%E7%A0%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-27T00:56:17.796Z</published>
    <updated>2020-11-27T00:56:17.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-源码的迭代器模式"><a href="#Android-源码的迭代器模式" class="headerlink" title="Android 源码的迭代器模式"></a>Android 源码的迭代器模式</h1><h2 id="迭代器模式的介绍"><a href="#迭代器模式的介绍" class="headerlink" title="迭代器模式的介绍"></a>迭代器模式的介绍</h2><p>迭代器模式（Iterator Pattern） 又称为游标（Cursor）模式，是行为型设计模式之一。迭代器模式是一个比较古老的设计模式，其源于对容器的访问，比如 Java 中的 List、Map、数组等。</p><h2 id="迭代器模式的定义"><a href="#迭代器模式的定义" class="headerlink" title="迭代器模式的定义"></a>迭代器模式的定义</h2><p>提供一个方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。</p><h2 id="Android-源码中的迭代器模式"><a href="#Android-源码中的迭代器模式" class="headerlink" title="Android 源码中的迭代器模式"></a>Android 源码中的迭代器模式</h2><p>Android 中典型的迭代器模式例子是数据库查询使用 Cursor，当我们使用 SQLiteDatabase 的 query 方法查询数据时，会返回一个 Cursor 游标对象，该游标对象实质就是一个具体的迭代器，我们可以使用它遍历数据库查询所得到的结果集。</p><p>首先定义一个 SQLiteOpenHelper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, <span class="string">&quot;DB_AIGE&quot;</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(<span class="string">&quot;CREATE TABLE table_aige (_id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, sex TEXT)&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;INSERT INTO table_aige (name, sex) values (&#x27;Aige&#x27;, &#x27;man&#x27;)&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;INSERT INTO table_aige (name, sex) values (&#x27;SMBrother&#x27;, &#x27;man&#x27;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造 ContentProvider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DBHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, <span class="meta">@Nullable</span> String[] projection, <span class="meta">@Nullable</span> String selection, <span class="meta">@Nullable</span> String[] selectionArgs, <span class="meta">@Nullable</span> String sortOrder)</span> </span>&#123;</span><br><span class="line">        SQLiteDatabase db = dbHelper.getReadableDatabase();</span><br><span class="line">        <span class="keyword">return</span> db.query(<span class="string">&quot;table_aige&quot;</span>, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(<span class="meta">@NonNull</span> Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, <span class="meta">@Nullable</span> ContentValues values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, <span class="meta">@Nullable</span> String selection, <span class="meta">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, <span class="meta">@Nullable</span> ContentValues values, <span class="meta">@Nullable</span> String selection, <span class="meta">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Activity 使用 ContentProvider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorActivity</span> <span class="keyword">extends</span> <span class="title">ListActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri URI = Uri.parse(<span class="string">&quot;content://com.android.androidsamples.dataprovider/table_aige&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] PROJECTION = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sex&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Cursor cursor = getContentResolver().query(URI, PROJECTION, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        cursor.moveToFirst();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; item = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            item.put(<span class="string">&quot;name&quot;</span>, cursor.getString(<span class="number">0</span>));</span><br><span class="line">            item.put(<span class="string">&quot;sex&quot;</span>, cursor.getString(<span class="number">1</span>));</span><br><span class="line">            list.add(item);</span><br><span class="line">        &#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">        cursor.close();</span><br><span class="line">        setListAdapter(<span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, list, android.R.layout.simple_list_item_2,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sex&quot;</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;android.R.id.text1, android.R.id.text2&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.iterator.IteratorActivity&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.android.androidsamples.dataprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.iterator.DataProvider&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-源码的迭代器模式&quot;&gt;&lt;a href=&quot;#Android-源码的迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;Android 源码的迭代器模式&quot;&gt;&lt;/a&gt;Android 源码的迭代器模式&lt;/h1&gt;&lt;h2 id=&quot;迭代器模式的介绍&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
