<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caoshen</title>
  
  <subtitle>caoshen 的博客</subtitle>
  <link href="https://www.okclouder.cn/atom.xml" rel="self"/>
  
  <link href="https://www.okclouder.cn/"/>
  <updated>2020-11-26T13:14:39.467Z</updated>
  <id>https://www.okclouder.cn/</id>
  
  <author>
    <name>caoshen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</id>
    <published>2020-11-26T13:13:31.929Z</published>
    <updated>2020-11-26T13:14:39.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两棵二叉搜索树中的所有元素"><a href="#两棵二叉搜索树中的所有元素" class="headerlink" title="两棵二叉搜索树中的所有元素"></a>两棵二叉搜索树中的所有元素</h1><p>给你 root1 和 root2 这两棵二叉搜索树。</p><p>请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</p><p> </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [2,1,4], root2 &#x3D; [1,0,3]</span><br><span class="line">输出：[0,1,1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [0,-10,10], root2 &#x3D; [5,1,7,0,2]</span><br><span class="line">输出：[-10,0,0,1,2,5,7,10]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [], root2 &#x3D; [5,1,7,0,2]</span><br><span class="line">输出：[0,1,2,5,7]</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [0,-10,10], root2 &#x3D; []</span><br><span class="line">输出：[-10,0,10]</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 &#x3D; [1,null,8], root2 &#x3D; [8,1]</span><br><span class="line">输出：[1,1,8,8]</span><br></pre></td></tr></table></figure><p>提示：</p><p>每棵树最多有 5000 个节点。<br>每个节点的值在 [-10^5, 10^5] 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先对两个树做先序遍历，会得到从小到大排序的 2 个有序数组。然后对两个有序数组进行合并。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = preOrderTree(root1);</span><br><span class="line">        List&lt;Integer&gt; list2 = preOrderTree(root2);</span><br><span class="line">        <span class="keyword">return</span> mergeOrderList(list1, list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">mergeOrderList</span><span class="params">(List&lt;Integer&gt; list1, List&lt;Integer&gt; list2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span> &amp;&amp; list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; list1.size() &amp;&amp; index2 &lt; list2.size()) &#123;</span><br><span class="line">            Integer val1 = list1.get(index1);</span><br><span class="line">            Integer val2 = list2.get(index2);</span><br><span class="line">            <span class="keyword">if</span> (val1 &lt; val2) &#123;</span><br><span class="line">                resultList.add(val1);</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultList.add(val2);</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; list1.size()) &#123;</span><br><span class="line">            resultList.add(list1.get(index1));</span><br><span class="line">            index1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index2 &lt; list2.size()) &#123;</span><br><span class="line">            resultList.add(list2.get(index2));</span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preOrderTree</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; preOrderList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// stop condition</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> preOrderList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            preOrderList.add(node.val);</span><br><span class="line">            <span class="keyword">return</span> preOrderList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// recursive get order list</span></span><br><span class="line">        List&lt;Integer&gt; left = preOrderTree(node.left);</span><br><span class="line">        preOrderList.addAll(left);</span><br><span class="line">        preOrderList.add(node.val);</span><br><span class="line">        List&lt;Integer&gt; right = preOrderTree(node.right);</span><br><span class="line">        preOrderList.addAll(right);</span><br><span class="line">        <span class="keyword">return</span> preOrderList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两棵二叉搜索树中的所有元素&quot;&gt;&lt;a href=&quot;#两棵二叉搜索树中的所有元素&quot; class=&quot;headerlink&quot; title=&quot;两棵二叉搜索树中的所有元素&quot;&gt;&lt;/a&gt;两棵二叉搜索树中的所有元素&lt;/h1&gt;&lt;p&gt;给你 root1 和 root2 这两棵二叉搜索树。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E6%8A%80%E6%9C%AF/</id>
    <published>2020-11-26T13:13:31.929Z</published>
    <updated>2020-11-26T13:14:39.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是低功耗蓝牙技术"><a href="#什么是低功耗蓝牙技术" class="headerlink" title="什么是低功耗蓝牙技术"></a>什么是低功耗蓝牙技术</h1><p>低功耗蓝牙是一种全新的技术，是当前可以用来设计和使用的功耗最低的无线技术。</p><p>经典蓝牙的设计目的在于统一全球各地的计算和通信设备，让手机与笔记本电脑相互连接。不过事实证明，蓝牙最为广泛的应用还是音频传输，比如将音频从手机传到蓝牙耳机。</p><p>低功耗蓝牙选择了完全不同的方向：并非只是增加可达的数据传输速率，而是从尽可能降低功耗方面进行优化。这意味着，也许你无法获得很高的传输速率，但是可以将连接保持数小时或数天的时间。</p><h2 id="低成本设计的三个要素"><a href="#低成本设计的三个要素" class="headerlink" title="低成本设计的三个要素"></a>低成本设计的三个要素</h2><p>从低成本的需求方面审视低功耗蓝牙的系统设计尤为重要。实现低成本的设计有三个关键因素：</p><ol><li>ISM 频段。2.4GHz ISM频段无线端传播特性差，能量极容易被各类物体吸收，尤其是水，而人体主要是由水构成的。但是该无线电频谱的优势是在全世界可以免许可、自由地使用。选择使用 ISM 频段能够降低成本。</li><li>IP 许可。当 Wibree（超低功耗蓝牙）技术发展成熟，考虑将其并入已有的无线标准工作组时，诺基亚原本有多种选择方案。比如加入 Wi-Fi 联盟，该联盟也在 2.4GHz ISM 频段制定了标准化技术。然而，鉴于蓝牙组值拥有较高的声誉和优厚的专利许可政策，他们最终选择了蓝牙技术联盟（Bluetooth Special Interest Group, BT SIG）。与其他采取 FRAND 政策的兴趣小组或者联盟相比，蓝牙技术联盟的政策使得蓝牙设备的专利许可成本大为降低。而许可成本的降低使得每件设备的成本也显著降低。</li><li>低功耗。设计一款低成本设备的最好方法就是建设制作这个设备所需的原料，比如电池。低功耗的基础设计就是以纽扣电池——这种最小、最便宜并且最容易购买的电池类型作为能量来源。这意味着我们无法令低功耗蓝牙实现很高的数据传送速率，或者将其用于大量数据的传输或者数据流传输。这一点或许是经典蓝牙与低功耗蓝牙的最大区别。</li></ol><h2 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h2><p>低功耗蓝牙技术可以构建两种类型的设备：双模设备和单模设备。双模设备既支持经典蓝牙又支持低功耗蓝牙。单模设备只支持低功耗蓝牙。当然，还有第三种仅支持经典蓝牙的设备。</p><p>仅支持低功耗蓝牙的单模设备不支持经典蓝牙，无法与现有的蓝牙设备通信，但是可以与其他单模设备或者双模设备通信。由于单模设备不支持头戴式耳机、立体声音乐或较高的文件传输速率，无法将其用于当今经典蓝牙使用的大部分领域。</p><p>下面展示了彼此间能相互通信的蓝牙设备类型以及蓝牙设备连接之后使用的无线电技术。</p><p>单模设备能够与其他的低功耗单模设备通信，也能与支持低功耗的双模设备通信。</p><p>双模设备能够与其他双模设备或者使用 BR/EDR 的经典蓝牙设备通信。</p><p>单模设备无法与经典蓝牙设备通信。</p><table><thead><tr><th></th><th>单模</th><th>双模</th><th>经典</th></tr></thead><tbody><tr><td>单模</td><td>LE</td><td>LE</td><td>无</td></tr><tr><td>双模</td><td>LE</td><td>经典</td><td>经典</td></tr><tr><td>经典</td><td>无</td><td>经典</td><td>经典</td></tr></tbody></table><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>蓝牙技术最初的设计目标主要包括以下几个方面：</p><ul><li>全球操作。全球操作需要一个在世界范围内都能使用的无线频段。2.45GHz频段是目前唯一一个可实现低成本、大批量制造的频段。</li><li>低成本。低成本的设计目标意味着系统应该尽可能做到简洁、高效。举个例子，尽管可以在低功耗蓝牙加入分散王（scatter net）或完整的网状网（mesh）支持，但这要求有更多的内存和处理能量来维护网络，从而增加了成本。所以低功耗蓝牙系统在进行低成本优化时，没有涉及在学术界广泛研究的网络拓扑学。</li><li>鲁棒性。鲁棒性还包括检测和纠正比特误码的能力，这类错误通常由背景噪声而引起。少数短距离无线标准使用长循环冗余校验（CRC），但大部分标准做了折中，使用较短的 CRC 校验码。优良的设计应在校验能力和发送校验信息所需的时间之间取得平衡。</li><li>短距离。短距离实际上存在一些问题。比如，如果想得到一个低功耗的系统，就必须尽可能降低传输功率以减少信号传输的能量。</li><li>低功耗。蓝牙的最初设计目标在设计低功耗时并没有太多改变，只是后者将能量的消耗目标降低了一到两个数量级。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>自适应跳频</strong>（Adaptive Frequency Hopping, AFH）一种使用某个频率子集的技术，使设备可以避免其他非自适应技术使用该频率（比如 Wi-Fi 接入点）。</p><p><strong>体系结构</strong>（architecture） 低功耗蓝牙的设计方案。</p><p><strong>频段</strong>（band） 参看<strong>无线频段</strong>（radio band）</p><p><strong>跳频</strong>（frequency hopping）两个设备之间使用多个频率通信。某个时刻只用一个频率，各个频率按照确定的顺序依次使用。</p><p><strong>层</strong> （layer）系统中实现一个具体功能的部分，例如物理层负责无线电操作。系统中每一层都是根据上层或下层抽象而来的。</p><p><strong>主设备</strong>（master）微微网中协调与其他设备的操作的一台复杂设备。</p><p><strong>微微网</strong>（piconet）piconet 是一个非常微小的网络。一个微微网包括唯一的一个主设备以及一个或多个从设备，主设备负责协调与本微微网中的所有其他从设备的操作。</p><p><strong>无线频段</strong>（radio band）无线电波通过频率或波长进行划分。不同的无线电波具有不同的规则和使用方法。当某一范围内的无线电频率以同一规则组合起来时，该频率的集合就被称为一个无线频段。</p><p><strong>从设备</strong>（slave）与主设备一起工作的简单设备。这些设备通常是用途单一的设备。</p><p><strong>Wi-Fi</strong> 一种为高传输率而设计的补充无线技术，用于计算即等复杂设备的互联网接入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是低功耗蓝牙技术&quot;&gt;&lt;a href=&quot;#什么是低功耗蓝牙技术&quot; class=&quot;headerlink&quot; title=&quot;什么是低功耗蓝牙技术&quot;&gt;&lt;/a&gt;什么是低功耗蓝牙技术&lt;/h1&gt;&lt;p&gt;低功耗蓝牙是一种全新的技术，是当前可以用来设计和使用的功耗最低的无线技术。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</id>
    <published>2020-11-26T13:13:31.929Z</published>
    <updated>2020-11-26T13:14:39.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分数到小数"><a href="#分数到小数" class="headerlink" title="分数到小数"></a>分数到小数</h1><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">输出: &quot;0.5&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">输出: &quot;2&quot;</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: numerator &#x3D; 2, denominator &#x3D; 3</span><br><span class="line">输出: &quot;0.(6)&quot;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal">https://leetcode-cn.com/problems/fraction-to-recurring-decimal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分数一定可以转化成循环小数的形式。为了找到循环部分，需要一个 Map 保存之前出现过的余数。如果余数重复出现，说明找到了循环部分，需要在循环开始前插入左括号，因此使用 Map 的 value 保存当前分数的长度作为插入位置。</p><p>另外需要考虑边界条件，比如：</p><ol><li>被除数为 0，直接返回 0</li><li>除数为 0，异常情况，这里可以不做处理</li><li>能整除的情况，不需要加小数点</li><li>正负数的情况，使用异或运算处理</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder fraction = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// only one number is negative</span></span><br><span class="line">        <span class="keyword">if</span> (numerator &lt; <span class="number">0</span> ^ denominator &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fraction.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// convert to positive long type</span></span><br><span class="line">        <span class="keyword">long</span> dividend = Math.abs(Long.valueOf(numerator));</span><br><span class="line">        <span class="keyword">long</span> divisor = Math.abs(Long.valueOf(denominator));</span><br><span class="line">        <span class="comment">// add integer part to fraction</span></span><br><span class="line">        fraction.append(dividend / divisor);</span><br><span class="line">        <span class="comment">// fraction is integer</span></span><br><span class="line">        <span class="keyword">long</span> remainder = dividend % divisor;</span><br><span class="line">        <span class="keyword">if</span> (remainder == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fraction.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// is fraction</span></span><br><span class="line">        fraction.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="comment">// create a remainder-length map</span></span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remainder)) &#123;</span><br><span class="line">                <span class="comment">// find a loop fraction</span></span><br><span class="line">                fraction.insert(map.get(remainder), <span class="string">&quot;(&quot;</span>);</span><br><span class="line">                fraction.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(remainder, fraction.length());</span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            fraction.append(remainder / divisor);</span><br><span class="line">            remainder %= divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fraction.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol start="166"><li>分数到小数 <a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">https://leetcode-cn.com/problems/fraction-to-recurring-decimal/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分数到小数&quot;&gt;&lt;a href=&quot;#分数到小数&quot; class=&quot;headerlink&quot; title=&quot;分数到小数&quot;&gt;&lt;/a&gt;分数到小数&lt;/h1&gt;&lt;p&gt;给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-11-26T13:13:31.929Z</published>
    <updated>2020-11-26T13:14:39.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="连续正整数之和"><a href="#连续正整数之和" class="headerlink" title="连续正整数之和"></a>连续正整数之和</h1><p>给定一个正整数，如何判断它是否是一段连续正整数之和？</p><p>比如，给定正整数 15，它可以表示成 15 = 1 + 2 + 3 + 4 + 5，也可以表示成 15 = 7 + 8。</p><p>给定正整数 6，它可以表示成 6 = 1 + 2 + 3。</p><p>那么这样的正整数有什么特征？什么样的数可以表示成连续正整数之和？什么样的数不可以表示成连续正整数之和？</p><p>显然，所有奇数都可以表示成连续正整数之和，比如 n = (n - 1) / 2 + (n + 1) / 2。</p><p>那么偶数呢？</p><p>当一个偶数的形式是 n = 2 ^ k （k &gt;= 1）时，它无法表示成连续正整数之和，比如 2、4、8、16……这样的偶数。其他形式的偶数都可以表示成连续正整数之和。</p><p>在代码中判断时，可以根据按位与的位运算符（&amp;）来判断。</p><p>如果 n 满足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &amp; (n - 1) &#x3D;&#x3D; 0</span><br></pre></td></tr></table></figure><p>那么它无法表示成一段连续正整数之和，否则可以表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;连续正整数之和&quot;&gt;&lt;a href=&quot;#连续正整数之和&quot; class=&quot;headerlink&quot; title=&quot;连续正整数之和&quot;&gt;&lt;/a&gt;连续正整数之和&lt;/h1&gt;&lt;p&gt;给定一个正整数，如何判断它是否是一段连续正整数之和？&lt;/p&gt;
&lt;p&gt;比如，给定正整数 15，它可以表</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0/</id>
    <published>2020-11-26T13:13:31.928Z</published>
    <updated>2020-11-26T13:14:39.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和为零的N个唯一整数"><a href="#和为零的N个唯一整数" class="headerlink" title="和为零的N个唯一整数"></a>和为零的N个唯一整数</h1><p>给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。</p><p> </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：[-7,-1,1,3,4]</span><br><span class="line">解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[-1,0,1]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= n &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero">https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果 n = 1，返回 0。</p><p>如果 n 是偶数，返回成对的整数，比如 1/-1。</p><p>如果 n 是奇数，返回 0 和成对的整数，比如 0、1/-1。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sumZero(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = i + <span class="number">1</span>;</span><br><span class="line">                result[i] = val;</span><br><span class="line">                result[i + <span class="number">1</span>] = -val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = i + <span class="number">1</span>;</span><br><span class="line">                result[i] = val;</span><br><span class="line">                result[i + <span class="number">1</span>] = -val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;和为零的N个唯一整数&quot;&gt;&lt;a href=&quot;#和为零的N个唯一整数&quot; class=&quot;headerlink&quot; title=&quot;和为零的N个唯一整数&quot;&gt;&lt;/a&gt;和为零的N个唯一整数&lt;/h1&gt;&lt;p&gt;给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/</id>
    <published>2020-11-26T13:13:31.928Z</published>
    <updated>2020-11-26T13:14:39.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a>最大间距</h1><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p><p>如果数组元素个数小于 2，则返回 0。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。<br>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-gap">https://leetcode-cn.com/problems/maximum-gap</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先按照题意，用排序加上遍历的方法解决问题。虽然不能满足线性时间复杂度和空间复杂度的条件。</p><p>这种解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (d &gt; diff) &#123;</span><br><span class="line">                diff = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最大间距&quot;&gt;&lt;a href=&quot;#最大间距&quot; class=&quot;headerlink&quot; title=&quot;最大间距&quot;&gt;&lt;/a&gt;最大间距&lt;/h1&gt;&lt;p&gt;给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。&lt;/p&gt;
&lt;p&gt;如果数组元素个数小于 2，则返回 0。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-26T13:13:31.928Z</published>
    <updated>2020-11-26T13:14:39.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p>在节点 c1 开始相交。</p><p> </p><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 </p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 </p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。 </p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>题目要求“尽量满足 O(n) 时间复杂度”，也就是说不能双重循环一个个比对节点。</p><p>解答思路是从 2 个链表中较短的那一个链表的开始位置同时遍历，一旦发现指向相同节点就说明链表相交。</p><p>要达成同时遍历的效果，必须让较长的链表先走多余的那一段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == headB) &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode lastNode = headA;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastNode = lastNode.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode = headB;</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lastNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastNode = lastNode.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode realStart;</span><br><span class="line">        ListNode otherStart;</span><br><span class="line">        <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">            <span class="comment">// let B go first</span></span><br><span class="line">            realStart = headB;</span><br><span class="line">            otherStart = headA;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB - lenA &amp;&amp; realStart != <span class="keyword">null</span>; ++i) &#123;</span><br><span class="line">                realStart = realStart.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// let A go first</span></span><br><span class="line">            realStart = headA;</span><br><span class="line">            otherStart = headB;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA - lenB &amp;&amp; realStart != <span class="keyword">null</span>; ++i) &#123;</span><br><span class="line">                realStart = realStart.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare one by one</span></span><br><span class="line">        <span class="keyword">while</span> (realStart != <span class="keyword">null</span> &amp;&amp; otherStart != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (realStart == otherStart) &#123;</span><br><span class="line">                <span class="keyword">return</span> realStart;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                realStart = realStart.next;</span><br><span class="line">                otherStart = otherStart.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;相交链表&quot;&gt;&lt;a href=&quot;#相交链表&quot; class=&quot;headerlink&quot; title=&quot;相交链表&quot;&gt;&lt;/a&gt;相交链表&lt;/h1&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;如下面的两个链表：&lt;/p&gt;
&lt;p&gt;在节点 c1 开始相交。&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%95%9C%E5%83%8F%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-26T13:13:31.928Z</published>
    <updated>2020-11-26T13:14:39.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h1><p>由于一些网络原因，下载软件和依赖的速度很慢。切换使用淘宝镜像下载。</p><h2 id="阿里云-Maven-镜像"><a href="#阿里云-Maven-镜像" class="headerlink" title="阿里云 Maven 镜像"></a>阿里云 Maven 镜像</h2><p>gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;url &#39;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&#39;&#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maven</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;aliyunmaven&lt;&#x2F;id&gt;</span><br><span class="line">        &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">    &lt;&#x2F;repository&gt;</span><br><span class="line">&lt;&#x2F;repositories&gt;</span><br></pre></td></tr></table></figure><h2 id="淘宝-NPM-镜像"><a href="#淘宝-NPM-镜像" class="headerlink" title="淘宝 NPM 镜像"></a>淘宝 NPM 镜像</h2><p><a href="https://npm.taobao.org/">https://npm.taobao.org/</a></p><p>可以使用 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;镜像配置&quot;&gt;&lt;a href=&quot;#镜像配置&quot; class=&quot;headerlink&quot; title=&quot;镜像配置&quot;&gt;&lt;/a&gt;镜像配置&lt;/h1&gt;&lt;p&gt;由于一些网络原因，下载软件和依赖的速度很慢。切换使用淘宝镜像下载。&lt;/p&gt;
&lt;h2 id=&quot;阿里云-Maven-镜像&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</id>
    <published>2020-11-26T13:13:31.927Z</published>
    <updated>2020-11-26T13:14:39.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h1><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p>说明:</p><p>你的解法应该是 O(logN) 时间复杂度的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-peak-element">https://leetcode-cn.com/problems/find-peak-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>首先想到的是顺序遍历，但是顺序遍历的时间复杂度是 O(N)，不满足要求。虽然也能通过用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = nums[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> right = nums[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> mid = nums[i];</span><br><span class="line">                <span class="keyword">if</span> (left &lt; mid &amp;&amp; mid &gt; right) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 题目要求 O(logN) 时间复杂度，那么一般是树状结构的遍历，比如二叉树。</p><p>如果中间节点是峰值，直接返回中间节点。否则取左右节点中较大的那个节点，在它所属的区间内遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findPeakElementRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElementRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left] &gt; nums[right] ? left : right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = left + right;</span><br><span class="line">        <span class="keyword">int</span> mid = ((total &amp; <span class="number">1</span>) == <span class="number">1</span>) ? (total - <span class="number">1</span>) / <span class="number">2</span>: total / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElementRange(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findPeakElementRange(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寻找峰值&quot;&gt;&lt;a href=&quot;#寻找峰值&quot; class=&quot;headerlink&quot; title=&quot;寻找峰值&quot;&gt;&lt;/a&gt;寻找峰值&lt;/h1&gt;&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9824.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9824.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-26T13:13:31.927Z</published>
    <updated>2020-11-26T13:14:39.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a>面试题24. 反转链表</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>注意：本题与主站 206 题相同：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用头插法将当前节点的下一个节点依次插入到头部。构造一个假头节点方便插入。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="comment">// 假头节点</span></span><br><span class="line">        ListNode h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        h.next = p;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点的下一个节点插入到链表头部</span></span><br><span class="line">            ListNode q = p.next;</span><br><span class="line">            p.next = q.next;</span><br><span class="line">            q.next = h.next;</span><br><span class="line">            h.next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题24-反转链表&quot;&gt;&lt;a href=&quot;#面试题24-反转链表&quot; class=&quot;headerlink&quot; title=&quot;面试题24. 反转链表&quot;&gt;&lt;/a&gt;面试题24. 反转链表&lt;/h1&gt;&lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9856%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9856%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2020-11-26T13:13:31.927Z</published>
    <updated>2020-11-26T13:14:39.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a>面试题56 - I. 数组中数字出现的次数</h1><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure><p>限制：</p><p>2 &lt;= nums &lt;= 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一种方法是使用 Set 保存已经存在的数，如果再次出现就把它从 Set 删除，留下只出现一次的数。</p><p>更好的方法是使用异或的思想。如果一个数字出现了两次，那么异或以后就是 0，最后剩下只出现一次的数的异或。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numSet.contains(n)) &#123;</span><br><span class="line">                numSet.remove(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                numSet.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : numSet) &#123;</span><br><span class="line">            result[i++] = n;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            xor ^= n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找出只出现一次的两个数 a、b 的不相同的最低位。</span></span><br><span class="line">        <span class="keyword">while</span> ((d &amp; xor) == <span class="number">0</span>) &#123;</span><br><span class="line">            d &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据找到的最低位分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; d) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题56-I-数组中数字出现的次数&quot;&gt;&lt;a href=&quot;#面试题56-I-数组中数字出现的次数&quot; class=&quot;headerlink&quot; title=&quot;面试题56 - I. 数组中数字出现的次数&quot;&gt;&lt;/a&gt;面试题56 - I. 数组中数字出现的次数&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9862.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%9862.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-11-26T13:13:31.927Z</published>
    <updated>2020-11-26T13:14:39.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62. 圆圈中最后剩下的数字"></a>面试题62. 圆圈中最后剩下的数字</h1><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>限制：</p><p>1 &lt;= n &lt;= 10^5<br>1 &lt;= m &lt;= 10^6</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>需要用倒推的思路解决。最后一个数的下标一定是 0，如果 m = 3，那么上一轮有2个数备选的情况下这个数的位置是1，以此类推。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最后一轮得到的数字的下标是 0，只有一个</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始反推 lastIndex = (curIndex + m) % i，i 是当前这一轮的剩余的个数。从剩余2人的情况开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题62-圆圈中最后剩下的数字&quot;&gt;&lt;a href=&quot;#面试题62-圆圈中最后剩下的数字&quot; class=&quot;headerlink&quot; title=&quot;面试题62. 圆圈中最后剩下的数字&quot;&gt;&lt;/a&gt;面试题62. 圆圈中最后剩下的数字&lt;/h1&gt;&lt;p&gt;0,1,,n-1这n个数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%88%86%E7%B3%96%E6%9E%9C%20II/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%88%86%E7%B3%96%E6%9E%9C%20II/</id>
    <published>2020-11-26T13:13:31.926Z</published>
    <updated>2020-11-26T13:14:39.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分糖果-II"><a href="#分糖果-II" class="headerlink" title="分糖果 II"></a>分糖果 II</h1><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; 7, num_people &#x3D; 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] +&#x3D; 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; 10, num_people &#x3D; 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] +&#x3D; 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people">https://leetcode-cn.com/problems/distribute-candies-to-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力解法。按照队伍顺序循环发糖果。</p><p>注意：这一题有时间复杂度更好的解法，具体可以看题解。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">        <span class="keyword">int</span> targetCandy = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_people &amp;&amp; candies &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> realCandy = targetCandy &gt; candies ? candies: targetCandy;</span><br><span class="line">                result[i] += realCandy;</span><br><span class="line">                candies -= realCandy; </span><br><span class="line">                targetCandy++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分糖果-II&quot;&gt;&lt;a href=&quot;#分糖果-II&quot; class=&quot;headerlink&quot; title=&quot;分糖果 II&quot;&gt;&lt;/a&gt;分糖果 II&lt;/h1&gt;&lt;p&gt;排排坐，分糖果。&lt;/p&gt;
&lt;p&gt;我们买了一些糖果 candies，打算把它们分给排好队的 n = num_p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%20rpx/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%20rpx/</id>
    <published>2020-11-26T13:13:31.926Z</published>
    <updated>2020-11-26T13:14:39.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpx-尺寸单位"><a href="#rpx-尺寸单位" class="headerlink" title="rpx 尺寸单位"></a>rpx 尺寸单位</h1><p>rpx 的全称是 responsive pixel，自适应像素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尺寸单位. rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx.</span><br></pre></td></tr></table></figure><p>任何手机的屏幕宽度都是750rpx，屏幕的高度可以根据手机的宽高比例换算出来。</p><p>举个例子：</p><p>iPhone 7 宽高比 375 x 667, 因此屏幕高度对应与 667 / 375 x 750 rpx = 1334 rpx</p><p>iPhone 7 Plus 宽高比 414 x 736，因此屏幕高度对应与 736 / 414 x 750 rpx = 1333.33 rpx</p><p>iPhone X 宽高比 375 x 812，因此屏幕高度对应与 812 / 375 x 750 rpx = 1624 rpx</p><h2 id="rpx小测试"><a href="#rpx小测试" class="headerlink" title="rpx小测试"></a>rpx小测试</h2><p>问题：</p><p>rpx 全称是什么？（请填写英语全称）</p><p>iphone 7 的屏幕宽度对应多少 rpx？</p><p>iphone 7 的屏幕高度对应多少 rpx？</p><p>iphone 7 Plus 的屏幕宽度对应多少 rpx？</p><p>iphone 7 Plus 的屏幕高度对应多少 rpx？</p><p>iphone X 的屏幕宽度对应多少 rpx？</p><p>iphone X 的屏幕高度对应多少 rpx？</p><p>答案：</p><p>responsive pixel<br>750<br>1334<br>750<br>1334<br>750<br>1624</p><h2 id="小程序文档链接"><a href="#小程序文档链接" class="headerlink" title="小程序文档链接"></a>小程序文档链接</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rpx-尺寸单位&quot;&gt;&lt;a href=&quot;#rpx-尺寸单位&quot; class=&quot;headerlink&quot; title=&quot;rpx 尺寸单位&quot;&gt;&lt;/a&gt;rpx 尺寸单位&lt;/h1&gt;&lt;p&gt;rpx 的全称是 responsive pixel，自适应像素&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E6%9C%80%E5%B0%8F%E6%A0%88/</id>
    <published>2020-11-26T13:13:31.926Z</published>
    <updated>2020-11-26T13:14:39.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>题目明确要求“在常数时间”解决，所以不能使用循环遍历的方法求最小值。</p><p>因此，需要额外的空间保存最小值。</p><p>这里的方法是使用一个额外的栈来保存每个元素所在位置对应的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Integer peek = minStack.peek();</span><br><span class="line">            <span class="keyword">if</span> (x &lt; peek) &#123;</span><br><span class="line">                <span class="comment">// 如果push的元素小于上一个位置的最小值，那么它自己就是最小值。</span></span><br><span class="line">                <span class="comment">// 极端情况是降序入栈，每个元素都是当前位置的最小值。</span></span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则把上一个位置的最小值最为当前位置的最小值。</span></span><br><span class="line">                <span class="comment">// 极端情况是升序入栈，最小值是第一个元素。</span></span><br><span class="line">                minStack.push(peek);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小栈&quot;&gt;&lt;a href=&quot;#最小栈&quot; class=&quot;headerlink&quot; title=&quot;最小栈&quot;&gt;&lt;/a&gt;最小栈&lt;/h1&gt;&lt;p&gt;设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E8%87%AA%E5%AE%9A%E4%B9%89%20ActivityNotifier%20%E8%A7%82%E5%AF%9F%E6%89%80%E6%9C%89%20Activity%20%E5%88%87%E6%8D%A2/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E8%87%AA%E5%AE%9A%E4%B9%89%20ActivityNotifier%20%E8%A7%82%E5%AF%9F%E6%89%80%E6%9C%89%20Activity%20%E5%88%87%E6%8D%A2/</id>
    <published>2020-11-26T13:13:31.926Z</published>
    <updated>2020-11-26T13:14:39.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义-ActivityNotifier-观察所有-Activity-切换"><a href="#自定义-ActivityNotifier-观察所有-Activity-切换" class="headerlink" title="自定义 ActivityNotifier 观察所有 Activity 切换"></a>自定义 ActivityNotifier 观察所有 Activity 切换</h1><p>我们知道，使用 Application 注册 ActivityLifecycleCallbacks 可以观察到本应用的所有 Activity 的生命周期切换。那么有没有一种方法可以观察到手机上所有应用的 Activity 的生命周期切换？</p><p>因为所有 Activity 的生命周期回调都会经过 ActivityManagerService(AMS) 管理，最后回调到应用的 ActivityThread。所以如果想要观察手机上所有应用的 Activity 生命周期回调，最好的办法就是在 AMS 中添加自定义的接口来实现。</p><h2 id="ActivityTaskManagerService"><a href="#ActivityTaskManagerService" class="headerlink" title="ActivityTaskManagerService"></a>ActivityTaskManagerService</h2><p>Android 10 版本（Q 版本）中新增了一个 ActivityTaskManagerService（ATMS） 类，它的作用是承担 AMS 的部分功能。由于 AMS 过于庞大，所以将部分功能剥离给 ATMS 来处理。</p><p>ActivityTaskManagerService 中有一些回调方法，例如 activityResumed 方法，所有 Activity 的 onResume 走完之后，都会调用 ATMS 的 activityResumed。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ActivityRecord.activityResumedLocked(token);</span><br><span class="line">        mWindowManager.notifyAppResumedFinished(token);</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityTopResumedStateLost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityStopped</span><span class="params">(IBinder token, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle persistentState, CharSequence description)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityDestroyed</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityRelaunched</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了 ActivityTaskManagerService 的 activityResumed 这些系统回调后，我们就可以在每个方法中添加分发方法，将每个生命周期事件分发出去。如果发现有应用注册了某个事件，就将该事件分发给它。</p><p>比如自定义接口 IActivityNotifier</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IActivityNotifier &#123;</span><br><span class="line">    void call(Bundle extras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call 方法表示某个事件被触发，extras 参数表示这个事件携带的一些信息，比如是什么原因引起的这次事件。</p><p>然后通过 AMS 注册接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regsiterActivityNotifier</span><span class="params">(IActivityNotifier notifier)</span> </span>&#123;</span><br><span class="line">    ActivityManagerEx.regsiterActivityNotifier(notifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 ActivityManagerEx 表示 ActivityManager 的扩展类，它包含了一些定制的方法。</p><p>然后使用 RemoteCallbackList 保存每个注册过来的 IActivityNotifier 回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RemoteCallbackList&lt;IActivityNotifier&gt; mCallbacks =</span><br><span class="line">        <span class="keyword">new</span> RemoteCallbackList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>分别注册和反注册回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regsiterActivityNotifier</span><span class="params">(IActivityNotifier cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCallbacks.register(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregsiterActivityNotifier</span><span class="params">(IActivityNotifier cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCallbacks.unregister(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 ATMS 的 activityResumed 将事件分发出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ActivityRecord.activityResumedLocked(token);</span><br><span class="line">        mWindowManager.notifyAppResumedFinished(token);</span><br><span class="line">        <span class="comment">// 分发事件</span></span><br><span class="line">        ATMSEx.dispatchActivityLifeState(...);</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatchActivityLifeState 方法将事件通过消息的方式分发出去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchActivityLifeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Message message = Message.obtain(mHandler, NOTIFY_CALL);</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    <span class="comment">// 存入数据</span></span><br><span class="line">    bundle.putInt(...);</span><br><span class="line">    message.obj = bundle;</span><br><span class="line">    mHandler.sendMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 mHandler 中处理消息，遍历每一个 IActivityNotifier 回调，依次派发。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> NOTIFY_CALL: &#123;</span><br><span class="line">                <span class="keyword">int</span> n = mCallbacks.beginBroadcast();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mCallbacks.getBroadcastItem(i).call(bundle);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mCallbacks.finishBroadcast();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，整个流程和 Application 注册 ActivityLifecycleCallbacks 的过程很类似，都是在某个事件发生时派发给各个注册的接口。只不过 IActivityNotifier 是应用注册到 AMS。而 ActivityLifecycleCallbacks 在应用内部注册。</p><h2 id="ActivityLifecycleItem"><a href="#ActivityLifecycleItem" class="headerlink" title="ActivityLifecycleItem"></a>ActivityLifecycleItem</h2><p>最后看一下为什么所有 Activity 的 onResume 后，都会走到 ATMS 的 activityResumed 方法。</p><p>在 Android 9 版本（P 版本）之后，AMS 不是直接调用 ActivityThread 的各个方法，而是通过 ActivityLifecycleItem 来管理。比如 Acivity 启动后最终要到 onResume 状态，就使用 ResumeActivityItem。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request to move an activity to resumed state.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResumeActivityItem</span> <span class="keyword">extends</span> <span class="title">ActivityLifecycleItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ResumeActivityItem&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mProcState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mUpdateProcState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsForward;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(ClientTransactionHandler client, IBinder token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mUpdateProcState) &#123;</span><br><span class="line">            client.updateProcessState(mProcState, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityResume&quot;</span>);</span><br><span class="line">        client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">                <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">            ActivityTaskManager.getService().activityResumed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和 AsyncTask 类似，ResumeActivityItem 有 3 个回调方法，preExecute、execute、postExecute，依次表示执行前、执行中、执行后。</p><p>查看 execute 和 postExecute 方法，可以看出 handleResumeActivity 之后会执行 ATMS 的 activityResumed 方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自定义-ActivityNotifier-观察所有-Activity-切换&quot;&gt;&lt;a href=&quot;#自定义-ActivityNotifier-观察所有-Activity-切换&quot; class=&quot;headerlink&quot; title=&quot;自定义 ActivityNotifi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E5%9C%A8%20build.gradle.kts%20%E6%B7%BB%E5%8A%A0%20maven%20%E4%BB%93%E5%BA%93/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E5%9C%A8%20build.gradle.kts%20%E6%B7%BB%E5%8A%A0%20maven%20%E4%BB%93%E5%BA%93/</id>
    <published>2020-11-26T13:13:31.925Z</published>
    <updated>2020-11-26T13:14:39.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-build-gradle-kts-添加-maven-仓库"><a href="#在-build-gradle-kts-添加-maven-仓库" class="headerlink" title="在 build.gradle.kts 添加 maven 仓库"></a>在 build.gradle.kts 添加 maven 仓库</h1><p>使用 kotlin script DSL 配置 build.gradle.kts 时，添加 maven 仓库的方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        setUrl(<span class="string">&quot;http://maven.aliyun.com/nexus/content/groups/public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它等价于以下 gradle 配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27;</span>&#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cloud.tencent.com/developer/ask/142262">如何使用kotlinscript DSL（build.gradle.kts）通过url添加maven存储库？</a></p><p><a href="https://github.com/gradle/kotlin-dsl-samples/issues/256">Provide maven(url: String, name: String? = null, …) shortcut</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在-build-gradle-kts-添加-maven-仓库&quot;&gt;&lt;a href=&quot;#在-build-gradle-kts-添加-maven-仓库&quot; class=&quot;headerlink&quot; title=&quot;在 build.gradle.kts 添加 maven 仓库&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E7%94%A8%20RxJava%20%E5%AE%9E%E7%8E%B0%20RxBus/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E7%94%A8%20RxJava%20%E5%AE%9E%E7%8E%B0%20RxBus/</id>
    <published>2020-11-26T13:13:31.925Z</published>
    <updated>2020-11-26T13:14:39.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-RxJava-实现-RxBus"><a href="#用-RxJava-实现-RxBus" class="headerlink" title="用 RxJava 实现 RxBus"></a>用 RxJava 实现 RxBus</h1><p>RxJava 可以用来实现 RxBus，实现事件发送和监听。</p><h2 id="创建-RxBus"><a href="#创建-RxBus" class="headerlink" title="创建 RxBus"></a>创建 RxBus</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RxBus rxBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object&gt; subject = PublishSubject.create().toSerialized();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RxBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxBus <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rxBus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RxBus.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rxBus == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rxBus = <span class="keyword">new</span> RxBus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rxBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        subject.onNext(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">toObservable</span><span class="params">(Class&lt;T&gt; eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject.ofType(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用双重校验锁（DCL）加上 volatile 关键字的方式实现 RxBus 单例。</p><p>使用 PublishSubject.create().toSerialized() 方法得到一个线程安全的 Subject。</p><p>toSerialized 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subject&lt;T&gt; <span class="title">toSerialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SerializedSubject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SerializedSubject&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RxJava2 中 SerializedSubject 类不再是 public 修饰的，没有对外暴露，而是使用 toSerialized 创建。</p><p>post 方法用来发送事件，它直接调用了 onNext 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    subject.onNext(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toObservable 用来把事件类型转换为 Observable 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">toObservable</span><span class="params">(Class&lt;T&gt; eventType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subject.ofType(eventType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ofType 方法代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span><br><span class="line">    return filter(Functions.isInstanceOf(clazz)).cast(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出先通过 instanceOf 判断是否是指定类型，然后用 filter 过滤指定类型的事件，最后使用 cast 将 Observable 转换为指定类型的 Observable。</p><h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBusActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_rx_bus);</span><br><span class="line">        Button btn = findViewById(R.id.rx_btn);</span><br><span class="line">        btn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            RxBus.getInstance().post(<span class="keyword">new</span> MessageEvent(<span class="string">&quot;用 RxJava 实现 RxBus&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮时，用调用 post 方法发送事件。</p><h2 id="接收事件"><a href="#接收事件" class="headerlink" title="接收事件"></a>接收事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBusFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView text;</span><br><span class="line">    <span class="keyword">private</span> Disposable disposable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> LayoutInflater inflater, <span class="meta">@Nullable</span> ViewGroup container, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_rx_bus, container, <span class="keyword">false</span>);</span><br><span class="line">        text = view.findViewById(R.id.frag_text);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        disposable = RxBus.getInstance().toObservable(MessageEvent.class).subscribe(messageEvent -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (messageEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                text.setText(messageEvent.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="keyword">if</span> (disposable != <span class="keyword">null</span> &amp;&amp; !disposable.isDisposed()) &#123;</span><br><span class="line">            disposable.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Fragment 的 onActivityCreated 方法中订阅事件，如果收到事件就改变 textView 文字。</p><h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>为了避免内存泄漏，需要在订阅者的退出回调 onDestroy 中取消事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="keyword">if</span> (disposable != <span class="keyword">null</span> &amp;&amp; !disposable.isDisposed()) &#123;</span><br><span class="line">        disposable.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了实现事件的发送和订阅，可以使用 RxJava 的 PublishSubject.create().toSerialized() 方法得到一个线程安全的 Subject，然后分别在合适的地方订阅（subject subscribe）和发送（subject onNext）事件。为了避免内存泄漏，需要在合适的地方取消订阅（dispose）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用-RxJava-实现-RxBus&quot;&gt;&lt;a href=&quot;#用-RxJava-实现-RxBus&quot; class=&quot;headerlink&quot; title=&quot;用 RxJava 实现 RxBus&quot;&gt;&lt;/a&gt;用 RxJava 实现 RxBus&lt;/h1&gt;&lt;p&gt;RxJava 可以用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.01.%20%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.01.%20%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-26T13:13:31.925Z</published>
    <updated>2020-11-26T13:14:39.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a>面试题 10.01. 合并排序的数组</h1><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">B &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>说明:</p><p>A.length == n + m</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sorted-merge-lcci">https://leetcode-cn.com/problems/sorted-merge-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从后往前合并，因为A有足够的空间容纳B。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从后往前合并，因为A有足够的空间容纳B</span></span><br><span class="line">        <span class="keyword">int</span> indexA = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexB = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexAll = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (indexA &gt;= <span class="number">0</span> &amp;&amp; indexB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[indexA] &gt; B[indexB]) &#123;</span><br><span class="line">                A[indexAll] = A[indexA];</span><br><span class="line">                indexA--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                A[indexAll] = B[indexB];</span><br><span class="line">                indexB--;</span><br><span class="line">            &#125;</span><br><span class="line">            indexAll--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (indexA &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            A[indexAll] = A[indexA];</span><br><span class="line">            indexA--;</span><br><span class="line">            indexAll--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (indexB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            A[indexAll] = B[indexB];</span><br><span class="line">            indexB--;</span><br><span class="line">            indexAll--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题-10-01-合并排序的数组&quot;&gt;&lt;a href=&quot;#面试题-10-01-合并排序的数组&quot; class=&quot;headerlink&quot; title=&quot;面试题 10.01. 合并排序的数组&quot;&gt;&lt;/a&gt;面试题 10.01. 合并排序的数组&lt;/h1&gt;&lt;p&gt;给定两个排序后的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.03.%20%E4%BA%A4%E7%82%B9/"/>
    <id>https://www.okclouder.cn/2020/11/26/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.03.%20%E4%BA%A4%E7%82%B9/</id>
    <published>2020-11-26T13:13:31.925Z</published>
    <updated>2020-11-26T13:14:39.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题-16-03-交点"><a href="#面试题-16-03-交点" class="headerlink" title="面试题 16.03. 交点"></a>面试题 16.03. 交点</h1><p>给定两条线段（表示为起点start = {X1, Y1}和终点end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。</p><p>要求浮点型误差不超过10^-6。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 0&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;0, -1&#125;</span><br><span class="line">输出： &#123;0.5, 0&#125;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;3, 3&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 1&#125;, &#123;2, 2&#125;</span><br><span class="line">输出： &#123;1, 1&#125;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">line1 &#x3D; &#123;0, 0&#125;, &#123;1, 1&#125;</span><br><span class="line">line2 &#x3D; &#123;1, 0&#125;, &#123;2, 1&#125;</span><br><span class="line">输出： &#123;&#125;，两条线段没有交点</span><br></pre></td></tr></table></figure><p>提示：</p><p>坐标绝对值不会超过 2^7<br>输入的坐标均是有效的二维坐标</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-lcci">https://leetcode-cn.com/problems/intersection-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果其中一个线段的两个点都在另一个线段的同一边，那么它们不会相交。如果每一个线段的两个点都在另一个线段的不同边或者有一个点在另一个线段上，那么会相交。</p><p>针对相交的情况，又可以分为两种情况：</p><ol><li>两条线段在一条直线的情况，需要根据线段的端点判断两条线段是否重叠。</li><li>两条线段不在一条直线的情况，根据两条直线的方程求交点坐标。</li></ol><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个线段是否相交。</span></span><br><span class="line"><span class="comment">     * 如果其中一个线段的两个点都在另一个线段的同一边，那么不会相交。</span></span><br><span class="line"><span class="comment">     * 如果每一个线段的两个点都在另一个线段的不同边，那么会相交。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] intersection(<span class="keyword">int</span>[] start1, <span class="keyword">int</span>[] end1, <span class="keyword">int</span>[] start2, <span class="keyword">int</span>[] end2) &#123;</span><br><span class="line">        <span class="keyword">int</span> resultStart2OfLine1 = calcSide(start1, end1, start2);</span><br><span class="line">        <span class="keyword">int</span> resultEnd2OfLine1 = calcSide(start1, end1, end2);</span><br><span class="line">        <span class="keyword">boolean</span> isLine2CrossLine1 = resultStart2OfLine1 * resultEnd2OfLine1 &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resultStart1OfLine2 = calcSide(start2, end2, start1);</span><br><span class="line">        <span class="keyword">int</span> resultEnd1OfLine2 = calcSide(start2, end2, end1);</span><br><span class="line">        <span class="keyword">boolean</span> isLine1CrossLine2 = resultStart1OfLine2 * resultEnd1OfLine2 &lt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线段会相交</span></span><br><span class="line">        <span class="keyword">if</span> (isLine2CrossLine1 &amp;&amp; isLine1CrossLine2) &#123;</span><br><span class="line">            <span class="comment">// 重叠情况，同一条直线。其中一个端点一定在另一条线段上。</span></span><br><span class="line">            <span class="keyword">if</span> (resultStart2OfLine1 == <span class="number">0</span> &amp;&amp; resultEnd2OfLine1 == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将线段端点按序排列</span></span><br><span class="line">                <span class="keyword">int</span>[] min1 = calcMinPointer(start1, end1);</span><br><span class="line">                <span class="keyword">int</span>[] max1 = end1;</span><br><span class="line">                <span class="keyword">if</span> (min1 != start1) &#123;</span><br><span class="line">                    max1 = start1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span>[] min2 = calcMinPointer(start2, end2);</span><br><span class="line">                <span class="keyword">int</span>[] max2 = end2;</span><br><span class="line">                <span class="keyword">if</span> (min2 != start2) &#123;</span><br><span class="line">                    max2 = start2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (min1[<span class="number">0</span>] &gt; min2[<span class="number">0</span>] || min1[<span class="number">1</span>] &gt; min2[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换线段位置</span></span><br><span class="line">                    <span class="keyword">int</span>[] temp = min1;</span><br><span class="line">                    min1 = min2;</span><br><span class="line">                    min2 = temp;</span><br><span class="line"></span><br><span class="line">                    temp = max1;</span><br><span class="line">                    max1 = max2;</span><br><span class="line">                    max2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (comparePoints(max1, min2) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparePoints(max2, min1) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparePoints(max1, min2) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;min2[<span class="number">0</span>], min2[<span class="number">1</span>]&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparePoints(max2, min1) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;min1[<span class="number">0</span>], min1[<span class="number">1</span>]&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 两条直线有交点情况</span></span><br><span class="line">            <span class="comment">// 求解 (y1 - y2) * (x - x1) - (x1 - x2) * (y - y1) = 0 和 (y3 - y4) * (x - x3) - (x3 - x4) * (y - y3) = 0</span></span><br><span class="line">            <span class="comment">//  先求 x 。(y1 - y2) * (x - x1) / (x1 - x2) + y1 = y = (y3 - y4) * (x - x3) / (x3 - x4) + y3 = y</span></span><br><span class="line">            <span class="comment">// (y1-y2)(x-x1)(x3-x4) - (y3-y4)(x-x3)(x1-x2) = (y3 - y1)(x1-x2)(x3-x4);</span></span><br><span class="line">            <span class="comment">//  [(y1-y2)(x3-x4) - (y3-y4)(x1-x2)]x + [(y3-y4)(x1-x2)x3 - (y1-y2)(x3-x4)x1] = (y3 - y1)(x1-x2)(x3-x4)</span></span><br><span class="line">            <span class="comment">// x = &#123;(y3 - y1)(x1-x2)(x3-x4) - [(y3-y4)(x1-x2)x3 - (y1-y2)(x3-x4)x1]&#125; / [(y1-y2)(x3-x4) - (y3-y4)(x1-x2)]</span></span><br><span class="line">            <span class="keyword">double</span> p0 = ((start2[<span class="number">1</span>] - start1[<span class="number">1</span>]) * (start1[<span class="number">0</span>] - end1[<span class="number">0</span>]) * (start2[<span class="number">0</span>] - end2[<span class="number">0</span>])</span><br><span class="line">                - ((start2[<span class="number">1</span>] - end2[<span class="number">1</span>]) * (start1[<span class="number">0</span>] - end1[<span class="number">0</span>]) * start2[<span class="number">0</span>] - (start1[<span class="number">1</span>] - end1[<span class="number">1</span>]) * (start2[<span class="number">0</span>] - end2[<span class="number">0</span>]) * start1[<span class="number">0</span>])</span><br><span class="line">                ) * <span class="number">1.0</span> / ((start1[<span class="number">1</span>] - end1[<span class="number">1</span>]) * (start2[<span class="number">0</span>] - end2[<span class="number">0</span>]) - (start2[<span class="number">1</span>] - end2[<span class="number">1</span>]) * (start1[<span class="number">0</span>] - end1[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">// 同理 y = &#123;(x3 - x1)(y1-y2)(y3-y4) - [(x3-x4)(y1-y2)y3 - (x1-x2)(y3-y4)y1]&#125; / [(x1-x2)(y3-y4) - (x3-x4)(y1-y2)]</span></span><br><span class="line">            <span class="keyword">double</span> p1 = ((start2[<span class="number">0</span>] - start1[<span class="number">0</span>]) * (start1[<span class="number">1</span>] - end1[<span class="number">1</span>]) * (start2[<span class="number">1</span>] - end2[<span class="number">1</span>])</span><br><span class="line">                - ((start2[<span class="number">0</span>] - end2[<span class="number">0</span>]) * (start1[<span class="number">1</span>] - end1[<span class="number">1</span>]) * start2[<span class="number">1</span>] - (start1[<span class="number">0</span>] - end1[<span class="number">0</span>]) * (start2[<span class="number">1</span>] - end2[<span class="number">1</span>]) * start1[<span class="number">1</span>])</span><br><span class="line">                ) * <span class="number">1.0</span> / ((start1[<span class="number">0</span>] - end1[<span class="number">0</span>]) * (start2[<span class="number">1</span>] - end2[<span class="number">1</span>]) - (start2[<span class="number">0</span>] - end2[<span class="number">0</span>]) * (start1[<span class="number">1</span>] - end1[<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;p0, p1&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线段的方程： (y1 - y2) * (x - x1) - (x1 - x2) * (y - y1) = 0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calcSide</span><span class="params">(<span class="keyword">int</span>[] start, <span class="keyword">int</span>[] end, <span class="keyword">int</span>[] point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (start[<span class="number">1</span>] - end[<span class="number">1</span>]) * (point[<span class="number">0</span>] - start[<span class="number">0</span>]) - (start[<span class="number">0</span>] - end[<span class="number">0</span>]) * (point[<span class="number">1</span>] - start[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] calcMinPointer(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (point1[<span class="number">0</span>] &lt; point2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> point1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">0</span>] == point2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (point1[<span class="number">1</span>] &lt; point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> point1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> point2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">comparePoints</span><span class="params">(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (point1[<span class="number">0</span>] &lt; point2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">0</span>] == point2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (point1[<span class="number">1</span>] &lt; point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (point1[<span class="number">1</span>] == point2[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题-16-03-交点&quot;&gt;&lt;a href=&quot;#面试题-16-03-交点&quot; class=&quot;headerlink&quot; title=&quot;面试题 16.03. 交点&quot;&gt;&lt;/a&gt;面试题 16.03. 交点&lt;/h1&gt;&lt;p&gt;给定两条线段（表示为起点start = {X1, Y1}</summary>
      
    
    
    
    
  </entry>
  
</feed>
