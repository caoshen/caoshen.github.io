<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>caoshen</title>
  
  <subtitle>caoshen 的博客</subtitle>
  <link href="https://www.okclouder.cn/atom.xml" rel="self"/>
  
  <link href="https://www.okclouder.cn/"/>
  <updated>2020-11-27T00:56:17.811Z</updated>
  <id>https://www.okclouder.cn/</id>
  
  <author>
    <name>caoshen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-11-27T00:56:17.811Z</published>
    <updated>2020-11-27T00:56:17.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-阻塞队列"><a href="#Java-阻塞队列" class="headerlink" title="Java 阻塞队列"></a>Java 阻塞队列</h1><p>阻塞队列在 Java 中时常被用到，比如线程池、生产者消费者模型。</p><h2 id="阻塞队列简介"><a href="#阻塞队列简介" class="headerlink" title="阻塞队列简介"></a>阻塞队列简介</h2><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h3 id="常见阻塞场景"><a href="#常见阻塞场景" class="headerlink" title="常见阻塞场景"></a>常见阻塞场景</h3><p>阻塞队列有两个常见的阻塞场景，它们分别是：</p><ol><li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p></li><li><p>当队列中填满了数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程自动被唤醒。</p></li></ol><p>支持以上两种阻塞场景的队列被称为阻塞队列。</p><h3 id="BlockingQueue-的核心方法"><a href="#BlockingQueue-的核心方法" class="headerlink" title="BlockingQueue 的核心方法"></a>BlockingQueue 的核心方法</h3><p>BlockingQueue 的核心方法可以分为放入数据和读取数据。</p><p>放入数据：</p><ul><li><p>boolean offer(E e) 表示如果可能的话，将 e 加到 BlockingQueue 里。如果 BlockingQueue 可以容纳，则返回 true，否则返回 false。本方法不阻塞当前执行方法的线程。</p></li><li><p>boolean offer(E e, long timeout, TimeUnit unit) 可以设定等待的时间。如果在指定的时间内还不能往队列中加入 BlockingQueue，则返回失败。</p></li><li><p>void put(E e) 将 e 加到 BlockingQueue 里。如果 BlockingQueue 没有空间，则调用此方法的线程被阻断，直到 BlockingQueue 里面有空间在继续。</p></li></ul><p>读取数据：</p><ul><li><p>E poll() 取走 BlockingQueue 里排在首位的对象。</p></li><li><p>E poll(long timeout, TimeUnit unit) 从 BlockingQueue 中取出一个队首的对象。如果在指定时间内队列有数据可取，则立即返回队列中的数据，否则直到时间超时还没有数据可取，就返回失败。</p></li><li><p>E take() 取走 BlockingQueue 里排在首位的对象。如果 BlockingQueue 是空，则阻断进入等待状态，否则返回失败。</p></li><li><p>int drainTo(Collection&lt;? super E&gt; c) 一次性从 BlockingQueue 获取所有可用的数据对象（也可以指定取出的个数）。通过该方法可以提升获取数据的效率，无需多次分批加锁或者释放锁。注意这里的下界通配符 super，表示 c 集合中的元素必须至少是 E 类型或者它的超类。</p></li></ul><h2 id="Java-中的阻塞队列"><a href="#Java-中的阻塞队列" class="headerlink" title="Java 中的阻塞队列"></a>Java 中的阻塞队列</h2><p>Java 中提供了很多阻塞队列，举例如下：</p><ul><li>ArrayBlockingQueue 由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue 由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue 支持优先级排序的无界阻塞队列</li><li>DelayQueue 使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue 不存储元素的阻塞队列</li><li>LinkedTransferQueue 由链表结构组成的无界阻塞队列</li><li>LinkedBlokcingDeque 由链表结构组成的阻塞双端队列</li></ul><p>这些阻塞队列有一个共同点，就是都实现了 BlockingQueue 接口。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是用数组实现的有界阻塞队列，按照先进先出 FIFO 的原则对元素进行排序。默认情况下不保证线程公平地访问队列。公平访问队列就是指阻塞地所有生产者线程或者消费者线程按照阻塞地先后顺序访问队列。即先阻塞地生产者线程，可以先往队列里面插入元素；先阻塞的消费者线程，可以先从队列里获取元素。通常情况下，保证公平性会降低吞吐量。</p><p>我们可以使用以下代码创建一个公平的阻塞队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">2000</span>, <span class="keyword">true</span>); </span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue 的第二个参数传 true，保证公平性。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 是基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序，其内部也维持着一个数据缓存队列（该队列由一个链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回。当队列缓冲区达到缓存容量的最大值时（LinkedBlockingQueue 可以通过构造方法指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒。反之，对于消费者这端的处理也基于同样的原理。</p><p>LinkedBlockingQueue 之所以能够高效地处理并发数据，因为它对于生产者端和消费者端分别采用了独立地锁来控制数据同步。这也意味着在高并发地情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>作为开发者需要注意的是，如果构造 LinkedBlockingQueue 时，没有指定大小，那么默认会用最大整数（Integer.MAX_VALUE）作为容量。如果生产者的速度大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就已经被消耗殆尽了。</p><p>ArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列。一般情况下，在处理多线程的生产者消费者问题时，使用这两个类就行。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。这里可以自定义元素的 compareTo 方法得到排序规则。也可以在构造 PriorityBlockingQueue 时传入 Comparator 来对元素进行排序，但是不能保证同优先级元素的顺序。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口。创建元素时，可以指定元素到期的时间，只有在元素到期时才能从队列中取走。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其实并没有任何一个元素，或者说容量是 0，严格来说它不是一种容器。由于队列没有容量，它的 peek 操作（返回队列的头元素）总是返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 Transfer 队列。LinkedTransferQueue 实现了一个重要的接口 TransferQueue。该接口有 5 个方法，其中有 3 个重要的方法，它们分别如下所示。</p><ol><li><p>void transfer(E e) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；如果没有消费者在等待接收数据，就会将元素插入到队尾底部，并且等待进入阻塞状态，直到有消费者线程取走该元素。</p></li><li><p>boolean tryTransfer(E e) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；若不存在，则返回 false，并且不进入队列，这是一个不阻塞的操作。与 transfer 方法不同的是，tryTransfer 方法无论消费者是否接收，其都会立即返回；而 transfer 方法则是消费者接收了才返回。</p></li><li><p>boolean tryTransfer(E e, long timeout, TimeUnit unit) 若当前存在一个正在等待获取的消费者线程，则立即将元素传递给消费者；若不存在则将元素插入到队列尾部，并且等待消费者线程取走该元素。若在指定的超时时间内元素未被消费者线程获取，则返回 false；若在指定的超时时间内被消费者线程获取，则返回 true。</p></li></ol><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque 是由一个链表结构组成的双向阻塞队列。双向队列可以从队列的两端插入和移除元素，因此在多线程同时入队时，减少了一半的竞争。由于是双向的，因此 LinkedBlockingDeque 多了 addFirst、addLast、offerFirst、offerLast、peekFirst、peekLast 等方法。以 First 开头的表示插入、获取、移除双端队列的第一个元素；以 Last 结尾的方法表示插入、获取、移除双端队列的最后一个元素。</p><h2 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h2><p>这里以 ArrayBlockingQueue 为例分析它的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Itrs itrs;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可以看出 ArrayBlockingQueue 维护了一个 Object 类型的数组，takeIndex 和 putIndex 分别表示队首元素和队尾元素的下标。count 表示队列中元素的个数，lock 则是一个可重入锁，notEmpty 和 notFull 是等待条件。</p><p>ArrayBlockingQueue 的 put 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 put 方法可以看出，它先获取了 lock 锁，并且调用了 lockInterruptibly 方法表示可中断，然后循环判断当前元素个数是否等于数组的长度，如果相等就调用 notFull.await 进行等待。当此线程被其他线程唤醒时，通过 enqueue 方法插入一个元素，最后解锁。</p><p>ArrayBlockingQueue 的 enqueue 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 enqueue 方法把 putIndex 位置的元素赋值为 e。如果已经是最后一个位置，那么会重置为 0，然后元素个数加 1，最后调用条件对象 notEmpty 的 signal 方法，表示唤醒正在等待取元素的线程。</p><p>ArrayBlockingQueue 的 take 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 put 方法类似，take 方法等待的是 notEmpty 条件。在 take 方法中，如果元素个数为 0，就循环等待。否则调用 dequeue 方法出队一个元素。</p><p>ArrayBlockingQueue 的 dequeue 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E e = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在得到 takeIndex 位置的元素后会调用 notFull 条件的 signal 方法，表示唤醒正在等待插入元素的线程。</p><h2 id="阻塞队列的使用场景"><a href="#阻塞队列的使用场景" class="headerlink" title="阻塞队列的使用场景"></a>阻塞队列的使用场景</h2><p>除了线程池的实现使用了阻塞队列之外，还可以在生产者消费者模式中使用阻塞队列。</p><p>首先使用 Object.wait 、Object.notify 和非阻塞队列 PriorityQueue 实现生产者消费者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        QueueTest queueTest = <span class="keyword">new</span> QueueTest();</span><br><span class="line">        Producer producer = queueTest.<span class="function">new <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = queueTest.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列空，等待数据&quot;</span> + queue);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 消费队首元素</span></span><br><span class="line">                    Integer poll = queue.poll();</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列取走&quot;</span> + poll + <span class="string">&quot;, &quot;</span> + queue);</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == queueSize) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;队列满，等待有空余空间&quot;</span> + queue);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 插入一个元素</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;队列插入 1&quot;</span> + queue);</span><br><span class="line">                    queue.offer(<span class="number">1</span>);</span><br><span class="line">                    queue.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用阻塞队列 ArrayBlockingQueue 实现生产者消费者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueueTest queueTest = <span class="keyword">new</span> BlockingQueueTest();</span><br><span class="line">        BlockingQueueTest.Producer producer = queueTest.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        BlockingQueueTest.Consumer consumer = queueTest.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 消费队首元素</span></span><br><span class="line">                    Integer poll = queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;队列取走&quot;</span> + poll + <span class="string">&quot;, &quot;</span> + queue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 插入一个元素</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;队列插入 1&quot;</span> + queue);</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出使用阻塞队列实现无须单独考虑同步和线程间通信的问题，实现起来比较简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-阻塞队列&quot;&gt;&lt;a href=&quot;#Java-阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;Java 阻塞队列&quot;&gt;&lt;/a&gt;Java 阻塞队列&lt;/h1&gt;&lt;p&gt;阻塞队列在 Java 中时常被用到，比如线程池、生产者消费者模型。&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20RxJava%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20RxJava%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2020-11-27T00:56:17.810Z</published>
    <updated>2020-11-27T00:56:17.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-RxJava-基本用法"><a href="#Android-RxJava-基本用法" class="headerlink" title="Android RxJava 基本用法"></a>Android RxJava 基本用法</h1><p>RxJava 使用函数响应式编程方式，它可以简化项目，处理嵌套回调的异步事件。</p><h2 id="RxJava-依赖"><a href="#RxJava-依赖" class="headerlink" title="RxJava 依赖"></a>RxJava 依赖</h2><p>这里以 RxJava 2.2.1 为例。在 build.gradle 添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; rxjava</span><br><span class="line">implementation &quot;io.reactivex.rxjava2:rxjava:2.2.11&quot;</span><br><span class="line">implementation &#39;io.reactivex.rxjava2:rxandroid:2.1.1&#39;</span><br></pre></td></tr></table></figure><h2 id="创建观察者-Observer"><a href="#创建观察者-Observer" class="headerlink" title="创建观察者 Observer"></a>创建观察者 Observer</h2><p>新建一个 Observer，复写它的回调方法：onSubscribe、onNext、onError、onComplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onSubscribe:&quot;</span> + d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onNext:&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onError:&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onComplete:&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>onSubscribe：订阅开始；</p><p>onNext：添加普通时间；</p><p>onError：异常事件；</p><p>onComplete：完结事件。</p><h2 id="创建被观察者-Observable"><a href="#创建被观察者-Observable" class="headerlink" title="创建被观察者 Observable"></a>创建被观察者 Observable</h2><p>创建 Observable 时可以使用 create、just 或者 from 方法。这里使用 just：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable = Observable.just(<span class="string">&quot;杨影枫&quot;</span>, <span class="string">&quot;月眉儿&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码相当于依次调用了 onNext(“杨影枫”) 和 onNext(“月眉儿”) ，最后调用 onComplete。</p><h2 id="订阅-subscribe"><a href="#订阅-subscribe" class="headerlink" title="订阅 subscribe"></a>订阅 subscribe</h2><p>使用 Observable 的 subscribe 方法可以触发订阅，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><p>运行结果 logcat 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxJavaActivity: onSubscribe:io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable@1816f28</span><br><span class="line">RxJavaActivity: onNext:杨影枫</span><br><span class="line">RxJavaActivity: onNext:月眉儿</span><br><span class="line">RxJavaActivity: onComplete:</span><br></pre></td></tr></table></figure><h2 id="RxJava-不完整回调"><a href="#RxJava-不完整回调" class="headerlink" title="RxJava 不完整回调"></a>RxJava 不完整回调</h2><p>RxJava 1.x 版本提供了 ActionX(X = 1~9、N) 来表示不同参数的回调。<br>在 RxJava 2 中使用 Consumer 代替 Action1，使用 BiConsumer 代替 Action2，使用 Consumer&lt;Object[]&gt; 代替 ActionN。</p><p>Action 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供一个无参 run 方法。</p><p>Consumer 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Consume the given value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供一个参数的 accept 方法。</p><p>BiConsumer 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T1 t1, T2 t2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出提供 2 个参数的 accept 方法。</p><p>如果需要多个参数的方法，可以给 Consumer 类传入数组类型，即 Consumer&lt;Object[]&gt;。</p><p>有了 Action 和 Consumer，可以把之前的代码改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRxJavaAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; nextConsumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;nextConsumer accept:&quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Consumer&lt;Throwable&gt; errorConsumer = <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;errorConsumer accept:&quot;</span> + throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Action completeAction = <span class="keyword">new</span> Action() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;run:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Observable&lt;String&gt; observable = Observable.just(<span class="string">&quot;杨影枫&quot;</span>, <span class="string">&quot;月眉儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">    observable.subscribe(nextConsumer, errorConsumer, completeAction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码把回调方法拆分在 3 个回调对象中，然后传递给了 subscribe 方法。</p><p>subscribe 方法也可以接收 1 个或 2 个回调对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(nextConsumer, errorConsumer);</span><br></pre></td></tr></table></figure><p>这种方法写起来更加灵活，可以选择想要的回调方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-RxJava-基本用法&quot;&gt;&lt;a href=&quot;#Android-RxJava-基本用法&quot; class=&quot;headerlink&quot; title=&quot;Android RxJava 基本用法&quot;&gt;&lt;/a&gt;Android RxJava 基本用法&lt;/h1&gt;&lt;p&gt;Rx</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20volatile%20%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-11-27T00:56:17.810Z</published>
    <updated>2020-11-27T00:56:17.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-volatile-关键字"><a href="#Java-volatile-关键字" class="headerlink" title="Java volatile 关键字"></a>Java volatile 关键字</h1><p>volatile 是 Java 的关键字，它的本意是易变的，即被 volatile 声明的变量可能被其他线程修改，需要用 volatile 保证变量的可见性和有序性。</p><p>有时仅仅为了读写一个或者两个实例域就使用同步的话，显得开销过大；而 volatile 关键字为实例域的同步访问提供了免锁机制。如果声明一个域为 volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java 中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此它存在内存可见性的问题。而局部变量、方法定义的参数则不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。Java 内存模型定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中，每个线程有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。</p><p>需要注意的是本地内存是 Java 内存模型的一个抽象概念，其并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java 内存模型控制线程之间的通信，它决定一个线程对主存共享变量的写入何时对另一个线程可见。</p><p>线程 A 和线程 B 之间若要通信的话，必须要经历下面两个步骤：</p><ol><li>线程 A 把线程 A 本地内存中更新过的共享变量刷新到主存中去；</li><li>线程 B 到主存中去读取线程 A 之前已更新过的共享变量。</li></ol><h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><p>原子性、可见性和有序性是并发编程中的三个特性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>对基本类型的读取和赋值操作是原子性的操作，即这些操作是不可中断的，要么执行完毕，要么不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span>;</span><br><span class="line">y = x;</span><br><span class="line">x++;</span><br></pre></td></tr></table></figure><p>上面 3 个语句只有第 1 条语句是原子性操作，其他 2 个语句都不是原子性操作。</p><p>第 2 条语句虽然是赋值操作，但是它包含了 2 个步骤，首先读取 x 的值，然后将 x 的值写入工作内存。读取 x 的值以及将 x 的值写入工作内存这两个操作单拿出来都是原子操作，但是合起来就不是原子操作。</p><p>第 3 条语句包括了 3 个操作：读取 x 的值、对 x 的值进行加 1、向工作内存写入新值。</p><p>通过这 3 个语句我们得知，一个语句包含多个操作时，就不是原子性操作，只有简单地读取和赋值（将数字赋值给某个变量）才是原子性操作。</p><p>java.util.concurrent.atomic 包中有很多类使用了高效的机器级指令（而不是使用锁）来保证操作的原子性。例如 AtomicInteger 类提供了方法 incrementAndGet 和 decrementAndGet，它们分别以原子方式将一个整数自增和自减。可以安全地使用 AtomicInteger 类作为共享计数器而无需同步。另外这个包还包含了 AtomicBoolean、AtomicLong、AtomicReference 这些原子类。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指线程之间地可见性，一个线程修改地状态对另一个线程时可见地。也就是说一个线程修改地结果，另一个线程马上就能看到。当一个共享变量被 volatile 修饰时，它会保证修改地值立即被更新到主存，同时其他线程读取共享变量时，会直接从主存中读取，而不是从线程工作内存读取，所以对其他线程是可见的。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>Java 内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性。这时可以通过 volatile 来保证有序性。除了 volatile，也可以通过 synchronized 和 lock 来保证有序性。我们知道，synchronized 和 lock 保证每个时刻只有一个线程执行同步代码，这相当于是让线程顺序执行同步代码，从而保证了有序性。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>当一个共享变量被 volatile 修饰之后，就具备了两个含义，一个是线程修改了变量的值时，变量的新值对其他线程时立即可见的。另一个含义是禁止指令重排序。重排序通常是编译器或者运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对于编译时和运行时环境。</p><h3 id="volatile-不保证原子性"><a href="#volatile-不保证原子性" class="headerlink" title="volatile 不保证原子性"></a>volatile 不保证原子性</h3><p>我们知道 volatile 保证了操作的可见性，但是对于一些自增操作，它无法保证原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VolatileTest volatileTest = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; ++j) &#123;</span><br><span class="line">                        volatileTest.increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有子线程就让出资源，保证所有子线程都执行完</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(volatileTest.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9475</span><br></pre></td></tr></table></figure><p>可以看出并非每次都正确执行了自增操作。自增操作是不具备原子性的，它包括 3 个步骤，读取变量的原始值、进行加 1、写入工作内存。也就是说，自增操作的 3 个自操作可能分割开执行。</p><h3 id="volatile-保证有序性"><a href="#volatile-保证有序性" class="headerlink" title="volatile 保证有序性"></a>volatile 保证有序性</h3><p>volatile 关键字能禁止指令重排序，因此 volatile 能保证有序性。volatile 关键字禁止指令重排序有 2 个含义：一个是当程序执行到 volatile 变量的操作时，在其前面的操作已经全部执行完毕，并且结果会对后面的操作可见，在其后面的操作还没有运行；在进行指令优化时，在 volatile 变量之前的语句不能在 volatile 变量后面执行；同样，在 volatile 变量之后的语句也不能再 volatile 变量之前执行。</p><h2 id="正确使用-volatile-关键字"><a href="#正确使用-volatile-关键字" class="headerlink" title="正确使用 volatile 关键字"></a>正确使用 volatile 关键字</h2><p>通常来说，使用 volatile 必须具备以下两个条件：</p><ol><li>对变量的写操作不会依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>第一个条件就是不能是自增、自减操作，上文已经提到 volatile 不保证原子性。</p><p>关于第二个条件，我们来举一个例子，它包含了一个不等式：下界总是小于或者等于上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> lower, upper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; upper) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;great than upper&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lower = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; lower) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">&quot;less than lower&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        upper = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">        NumberRange numberRange = <span class="keyword">new</span> NumberRange();</span><br><span class="line">        numberRange.setLower(<span class="number">0</span>);</span><br><span class="line">        numberRange.setUpper(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    numberRange.setLower(<span class="number">4</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    numberRange.setUpper(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码 range 的初始值是 0 到 5，假如在同一时刻，线程 1 调用 setLower(4)，线程 2 调用 setUpper(3)，那么新的范围是 (4, 3)。这显然是不对的，因此无法用 volatile 实现 setLower 和 setUpper 操作的原子性。</p><p>使用 volatile 有很多种场景，这里介绍其中 2 种：</p><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">        <span class="comment">// do work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile boolean 标记保证了变量的可见性，对于变量的修改对每个线程都是可见的。</p><h3 id="双重校验锁（DCL）"><a href="#双重校验锁（DCL）" class="headerlink" title="双重校验锁（DCL）"></a>双重校验锁（DCL）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 singleton = new Singleton(); 这个操作会先分配内存，然后调用构造方法构造 Singleton，最后调用赋值操作。这三个操作可能被指令重排序，导致不按顺序执行，线程 1 还没将构造的 singleton 写入内存，线程 2 就去内存读取，读取出错误的值。加上 volatile 关键字之后会产生一个内存屏障，保证操作按照顺序执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与锁相比，volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况想将提供优于锁的性能和伸缩性。如果严格遵守 volatile 的使用条件，即变量真正独立于其他变量和自己以前的值，在某些情况下可以使用 volatile 代替 synchronized 来简化代码。但是，使用 volatile 的代码比使用锁的代码更加容易出错。使用状态标志和双重校验锁是 volatile 的两种常见用例，其他情况下最好还是使用 synchronized 关键字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-volatile-关键字&quot;&gt;&lt;a href=&quot;#Java-volatile-关键字&quot; class=&quot;headerlink&quot; title=&quot;Java volatile 关键字&quot;&gt;&lt;/a&gt;Java volatile 关键字&lt;/h1&gt;&lt;p&gt;volatile 是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/ContentProvider%20%E9%9A%BE%E7%82%B9/"/>
    <id>https://www.okclouder.cn/2020/11/27/ContentProvider%20%E9%9A%BE%E7%82%B9/</id>
    <published>2020-11-27T00:56:17.809Z</published>
    <updated>2020-11-27T00:56:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ContentProvider-难点"><a href="#ContentProvider-难点" class="headerlink" title="ContentProvider 难点"></a>ContentProvider 难点</h1><h2 id="ContentProvider-的生命周期"><a href="#ContentProvider-的生命周期" class="headerlink" title="ContentProvider 的生命周期"></a>ContentProvider 的生命周期</h2><p>ContentProvider 只有 onCreate 这个生命周期方法。</p><h2 id="ContentProvider-的-onCreate-和-CRUD"><a href="#ContentProvider-的-onCreate-和-CRUD" class="headerlink" title="ContentProvider 的 onCreate 和 CRUD"></a>ContentProvider 的 onCreate 和 CRUD</h2><p>ContentProvider 运行在哪个线程？他们是线程安全的吗？</p><p>onCreate 方法运行在主线程。如果是 ContentProvider 同进程通信，CRUD 运行在主线程。如果是 ContentProvider 跨进程通信，CRUD 运行在 Binder 线程。</p><h2 id="ContentProvider-的内部存储有哪些"><a href="#ContentProvider-的内部存储有哪些" class="headerlink" title="ContentProvider 的内部存储有哪些"></a>ContentProvider 的内部存储有哪些</h2><p>ContentProvider 的内部存储只能是 sqlite 吗？</p><p>ContentProvider 的内部存储不一定是 sqlite，可以是多种形式的存储。比如 sqlite、SharedPreference、文件、内存。</p><h2 id="ContentProvider-的-onCreate-和-Application-的-onCreate-先后顺序"><a href="#ContentProvider-的-onCreate-和-Application-的-onCreate-先后顺序" class="headerlink" title="ContentProvider 的 onCreate 和 Application 的 onCreate 先后顺序"></a>ContentProvider 的 onCreate 和 Application 的 onCreate 先后顺序</h2><p>ContentProvider 的 onCreate 早于 Application 的 onCreate 执行。在 Application 的 onCreate 之前，有 installProvider 和 publishProvider 的过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ContentProvider-难点&quot;&gt;&lt;a href=&quot;#ContentProvider-难点&quot; class=&quot;headerlink&quot; title=&quot;ContentProvider 难点&quot;&gt;&lt;/a&gt;ContentProvider 难点&lt;/h1&gt;&lt;h2 id=&quot;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.okclouder.cn/2020/11/27/OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-11-27T00:56:17.809Z</published>
    <updated>2020-11-27T00:56:17.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp-源码解析"><a href="#OkHttp-源码解析" class="headerlink" title="OkHttp 源码解析"></a>OkHttp 源码解析</h1><p>本文主要从两个方面分析 OkHttp 源代码。</p><ol><li>网络请求流程；</li><li>连接池复用。</li></ol><h2 id="OkHttp-的网络请求流程"><a href="#OkHttp-的网络请求流程" class="headerlink" title="OkHttp 的网络请求流程"></a>OkHttp 的网络请求流程</h2><h3 id="网络请求流程"><a href="#网络请求流程" class="headerlink" title="网络请求流程"></a>网络请求流程</h3><p>不管是异步请求还是同步请求，都会先通过 OkHttpClient 的 newCall 方法构造一个 Call。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Prepares the [request] to be executed at some point in the future. */</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">  <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newCall 方法返回的是 RealCall。不管是异步的 enqueue 方法还是同步的 execute 方法，都是由 RealCall 调用的。</p><p>enqueue 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    executed = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(!executed) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    executed = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter()</span><br><span class="line">  transmitter.callStart()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，在 RealCall 中 enqueue 和 execute 最终的请求是 dispatcher 调用的。</p><h3 id="Dispatcher-任务调度"><a href="#Dispatcher-任务调度" class="headerlink" title="Dispatcher 任务调度"></a>Dispatcher 任务调度</h3><p>Dispatcher 类定义了控制并发的请求，包括最大请求数、消费者线程池、同步和异步的请求队列等变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:Synchronized</span> <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>maxRequests 最大请求数</p><p>maxRequestsPerHost 每个主机的最大请求数</p><p>ExecutorService 消费者线程池</p><p>readyAsyncCalls 将要运行的异步请求队列</p><p>runningAsyncCalls 正在运行的异步请求队列</p><p>runningSyncCalls 正在运行的同步请求队列</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@get:Synchronized</span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;executorService&quot;</span>) <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">      executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>executorService 的 get 方法返回一个 ThreadPoolExecutor，它的核心线程数是 0，最大线程数是 Int.MAX_VALUE，线程等待时间是 60 秒，任务队列是 SynchronousQueue。</p><p>之前说过 RealCall 的 enqueue 和 execute 实际上是调用的 Dispatcher 的 enqueue 和 execute 。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">    <span class="comment">// the same host.</span></span><br><span class="line">    <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">      <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueue 方法主要由以下 3 步：</p><ol><li><p>Dispatcher 的 enqueue 方法先将 AsyncCall 加入到 readyAsyncCalls 队列。</p></li><li><p>如果入队的 call 不是 websocket，那么查找任务准备队列（readyAsyncCalls）和任务执行队列（runningAsyncCalls），看里面是不是存在相同主机（host）的请求。如果存在，就把当前的 call 的主机访问数量设为已经存在的相同主机的 call 数量。这个操作保证每个主机的请求数不超过设定值。在后面的 promoteAndExecute 会被用到。</p></li><li><p>promoteAndExecute 方法会从 readyAsyncCalls 队列中筛选出符合条件的 call，然后调用 call 的 executeOn(executorService) 执行。</p></li></ol><p>promoteAndExecute 代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove()</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">    <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealCall 的 executeOn 方法有个 success 局部变量。正常情况下，execute 走完，success 是 true，但是如果这个过程中抛出异常，那么 success 就还是 false。在最后的 finally 语句中可以发现，会调用 Dispatcher 的 finish 方法。finish 方法其实就是从 runningAsyncCalls 队列移除 call，然后再次调用 promoteAndExecute 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to enqueue this async call on [executorService]. This will attempt to clean up</span></span><br><span class="line"><span class="comment"> * if the executor has been shut down by reporting the call as failed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">  assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">  <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">    success = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">    <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">    ioException.initCause(e)</span><br><span class="line">    transmitter.noMoreExchanges(ioException)</span><br><span class="line">    responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ### Interceptor 拦截器### 缓存策略### 失败重连## OkHttp 的复用连接池 -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OkHttp-源码解析&quot;&gt;&lt;a href=&quot;#OkHttp-源码解析&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 源码解析&quot;&gt;&lt;/a&gt;OkHttp 源码解析&lt;/h1&gt;&lt;p&gt;本文主要从两个方面分析 OkHttp 源代码。&lt;/p&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</id>
    <published>2020-11-27T00:56:17.807Z</published>
    <updated>2020-11-27T00:56:17.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程的状态"><a href="#Java-线程的状态" class="headerlink" title="Java 线程的状态"></a>Java 线程的状态</h1><p>Java 线程在运行的生命周期中可能处于 6 种不同的状态：</p><ol><li>New 新创建的状态。线程被创建，但是没有调用 start 方法，在运行之前有一些基础工作要做，比如初始化操作。</li><li>Runnable 可运行状态。一旦调用了 start 方法，线程就处于 Runnable 状态。一个可运行的线程可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。</li><li>Blocked 阻塞状态。表示线程被阻塞，暂时不活动。比如线程正在请求锁。</li><li>Waiting 等待状态。线程暂时不活动，并且不允许任何代码，这消耗最少的资源，知道线程调度器重新激活它。</li><li>Timed waiting 超时等待状态。和等待状态的区别是超时等待可以在指定的时间自行返回。</li><li>Terminated 终止状态。表示当前线程执行完毕。可能有 2 种情况：第一种情况是 run 方法正常执行完毕退出。第二种情况是因为一个没有被捕获的异常而终止了 run 方法，导致线程进入终止状态。</li></ol><p>New 状态 Thread.start 后会进入 Runnable 状态。</p><p>Runnable 调用 Object.wait 或者 Thread.join 会进入 Waiting 状态。</p><p>Waiting 调用 Object.notify 或者 Object.notifyAll 会进入 Runnable 状态。</p><p>Runnable 调用 Thread.sleep(long)、Object.wait(long) 、 Thread.join(long) 会进入 Timed Waiting 状态。</p><p>Timed Waiting 调用 Object.notify 或者 Object.notifyAll 会进入 Runnable 状态。</p><p>Runnable 请求锁会进入 Blocked 状态。</p><p>Blocked 得到锁会进入 Runnable 状态。</p><p>Runnable 执行完毕或者异常退出会进入 Terminated 状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程的状态&quot;&gt;&lt;a href=&quot;#Java-线程的状态&quot; class=&quot;headerlink&quot; title=&quot;Java 线程的状态&quot;&gt;&lt;/a&gt;Java 线程的状态&lt;/h1&gt;&lt;p&gt;Java 线程在运行的生命周期中可能处于 6 种不同的状态：&lt;/p&gt;
&lt;ol</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-11-27T00:56:17.803Z</published>
    <updated>2020-11-27T00:56:17.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><p>线程的创建和消耗都需要一定的开销，如果每次执行一个异步任务都需要开一个线程去执行，则这些线程的创建和销毁将消耗大量的资源，而且线程都是各自为政，很难对其进行控制，更何况有一堆的线程在执行。这时就需要线程池对线程进行管理。</p><p>在 Java 1.5 中提供了 Executor 框架用于把任务的提交和执行解耦，任务的提交交给 Runnable 或者 Callable，而 Executor 框架用来处理任务。Executor 框架中最核心的成员就是 ThreadPoolExecutor，它是线程池的核心实现类</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>可以通过 ThreadPoolExecutor 来创建一个线程池，ThreadPoolExecutor 类一共有 4 个构造方法。其中，拥有最多参数的构造方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共有 7 个参数，这些参数的作用如下：</p><ul><li><p>corePoolSize 核心线程数。默认情况下线程池是空的，只有任务提交时才会创建线程。如果当前运行的线程数少于核心线程数，则创建新的线程来处理任务。如果等于或者多于核心线程数，则不再创建。如果调用线程池的 prestartAllCoreThreads 方法，线程池会提前创建并且启动所有的核心线程来等待任务。</p></li><li><p>maximumPoolSize 线程池允许创建的最大线程数。如果任务队列满了并且线程数小于 maximumPoolSize，则线程池仍旧会创建新的线程来处理任务。</p></li><li><p>keepAliveTime 非核心线程闲置的超时时间。如果超过这个时间就回收线程。如果任务很多，并且每个任务的执行时间很短，则可以调大 keepAliveTime 来提高线程的利用率。另外，如果设置 allowCoreThreadTimeout 为 true （通过 allowsCoreThreadTimeOut 方法），keepAliveTime 也会应用到核心线程上。</p></li><li><p>TimeUnit keepAliveTime 参数的时间单位。可选单位有天、小时、分钟、秒、毫秒等。</p></li><li><p>workQueue 任务队列。如果当前任务数大于核心线程数，则将任务添加到任务队列。这里的任务队列是阻塞队列（BlockingQueue）。</p></li><li><p>ThreadFactory 线程工厂。可以用线程工厂来给每个创建出来的线程设置名字。如果不设置会使用默认的线程工厂。</p></li><li><p>RejectedExecutionHandler 饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是 AbortPolicy，表示无法处理新任务，并抛出 RejectedExecutionException 异常。除此之外还有 3 中策略，它们分别如下：</p></li></ul><ol><li><p>CallerRunsPolicy 用调用者所在的线程处理任务。此任务提供简单的反馈控制机制，能够减缓新任务的提交速度。</p></li><li><p>DiscardPolicy 不能执行的任务，并将该任务删除。</p></li><li><p>DiscardOldestPolicy 丢弃队列最近的任务，并执行当前的任务。</p></li></ol><h2 id="线程池的处理流程和原理"><a href="#线程池的处理流程和原理" class="headerlink" title="线程池的处理流程和原理"></a>线程池的处理流程和原理</h2><p>线程池的处理流程主要可以分为 3 个步骤，如下所示：</p><ol><li><p>提交任务后，线程池先判断线程数是否达到了核心线程数 corePoolSize。如果未达到核心线程数，则创建核心线程处理任务。否则就执行下一步操作。</p></li><li><p>接着线程池判断任务队列是否满了。如果没满，则将任务添加到任务队列中；否则，就执行下一步操作。</p></li><li><p>如果任务队列满了，线程池就判断线程数是否达到了最大线程数。如果未达到，则创建非核心线程处理任务；否则就执行饱和策略，默认会抛出 RejectedExecutionException 异常。</p></li></ol><p>如果我们执行 ThreadPoolExecutor 的 execute 方法，会遇到各种情况：</p><ol><li><p>如果线程池中的线程数未达到核心线程数，则创建核心线程处理任务。</p></li><li><p>如果线程数大于或者等于核心线程数，则将任务加入到任务队列，线程池中的空闲线程会不断地从任务队列中取出任务进行处理。</p></li><li><p>如果任务队列满了，并且线程数没有达到最大线程数，则创建非核心线程去处理任务。</p></li><li><p>如果线程数超过了最大线程数，则执行饱和策略。</p></li></ol><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p>通过直接或者间接地配置 ThreadPoolExecutor 的参数可以创建不同类型的 ThreadPoolExecutor，其中有几种线程池比较常用，它们分别是 FixedThreadPool、CachedThreadPool、SingleThreadExecutor、ScheduledThreadPool、ForkJoinPool。</p><ul><li>FixedThreadPool</li></ul><p>FixedThreadPool 是可重用固定线程数的线程池。在 Executors 类提供了创建 FixedThreadPool 的方法 newFixedThreadPool，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 的 corePoolSize 和 maximumPoolSize 都设置为创建 FixedThreadPool 指定的参数 nThreads，也就是说 FixedThreadPool 只有核心线程，并且数量是固定的，没有非核心线程。keekAliveTime 设置为 0L 意味者多余的线程会被立即终止。因为不会产生多余的线程，所以 keepAliveTime 是无效的参数。另外，任务队列采用了无界的阻塞队列 LinkedBlockingQueue。</p><p>当执行 FixedThreadPool 的 execute 方法时，如果当前运行的线程未达到 corePoolSize （核心线程数）时就创建核心线程来处理任务，如果达到了核心线程数则将任务添加到 LinkedBlockingQueue 中。FixedThreadPool 就是一个有固定数量核心线程的线程池，并且这些核心线程不会被回收。当线程数超过 corePoolSize 时，就将任务存储在任务队列中；当线程池有空闲线程时，则从任务队列中去取任务执行。</p><ul><li>CachedThreadPool</li></ul><p>CachedThreadPool 是一个根据需要创建线程的线程池，创建 CachedThreadPool 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 的 corePoolSize 是 0，maximumPoolSize 设置为 Integer.MAX_VALUE，这意味着 CachedThreadPool 没有核心线程，非核心线程是无界的。keepAliveTime 设置为 60L，则空闲线程等待新任务的最长时间为 60s。在此用了阻塞队列 SynchronousQueue，它是一个不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。</p><p>当执行 execute 方法时，首先会执行 SynchronousQueue 的 offer 方法来提交任务，并且查询线程池中是否有空闲的线程执行 SynchronousQueue 的 poll 方法来移除任务。如果有则配对成功，将任务交给这个空闲的线程处理；如果没有则配对失败，创建新的线程处理任务。当线程池中的线程空闲时，它会执行 SynchronousQueue 的 poll 方法，等待 SynchronousQueue 中新提交的任务。如果超过 60s 没有新任务提交到 SynchronousQueue，这个空闲线程将终止。</p><p>因为 maximumPoolSize 是无界的，所以如果提交的任务大于线程池中线程的处理速度，就会不断地创建新线程。另外，每次提交任务都会立即有线程去处理。所以，CachedThreadPool 比较适合有大量任务处理，但是每个任务耗时较少地情况。</p><ul><li>SingleThreadExecutor</li></ul><p>SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 都为 1，意味着 SingleThreadExecutor 只有一个核心线程，其他参数和 FixedThreadPool 一样。</p><p>但是 SingleThreadExecutor 使用 FinalizableDelegatedExecutorService 封装了一次，在封装类中只暴露了 ExecutorService 接口的方法，这意味着 ThreadPoolExecutor 里面的 public 方法对 SingleThreadExecutor 来说是无法调用的。也就是说 SingleThreadExecutor 是无法配置线程池的各个参数的，但是 FixedThreadPool 和 ThreadPoolExecutor 可以自由配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 execute 方法时，如果当前运行的线程数未达到核心线程数，也就是当前没有运行的线程，则创建一个新线程来处理任务。如果当前有运行的线程，则将任务添加到阻塞队列 LinkedBlockingQueue 中。因此，SingleThreadExecutor 能确保所有的任务在一个线程中按照顺序执行。</p><ul><li>ScheduledThreadPool</li></ul><p>ScheduledThreadPool 是一个能实现定时和周期性任务的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 继承了 ThreadPoolExecutor 并且实现了 ScheduledExecutorService 接口。它主要用于给定延时之后的运行任务或者定期处理任务。</p><p>ScheduledThreadPoolExecutor 的构造方法调用了 ThreadPoolExecutor 的构造方法。corePoolSize 是传进来固定的数值，maximumPoolSize 的值是 Integer.MAX_VALUE。因 为 DelayedWorkQueue 是无界的，所以 Integer.MAX_VALUE 是无效的，总是用核心线程处理阻塞队列的任务。</p><p>当执行 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate 或者 scheduleWithFixedDelay 方法时，会向 DelayedWorkQueue 添加一个 ScheduledFutureTask，并检查运行的线程是否达到 corePoolSize。如果没有则创建新线程并启动它，但是并不是立即去执行任务，而是去 DelayedWorkQueue 中取 ScheduledFutureTask，然后去执行任务。如果运行的线程达到了 corePoolSize 时，则将任务添加到 DelayedWorkQueue 中。DelayedWorkQueue 会将任务进行排序，先要执行的任务放在队列的前面。与此前介绍的线程池不同的是，当执行完任务后，会将 ScheduledFutureTask 中的 time 变量改为下次要执行的时间，并且放回到 DelayedWorkQueue 中。</p><ul><li>ForkJoinPool</li></ul><p>Executors 中的 newWorkStealingPool 方法提供了工作窃取线程池，它是一个 ForkJoinPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 newWorkStealingPool 构造了一个与 CPU 处理器核数相同的 ForkJoinPool，它适合多核并行计算的场景。</p><p>与其他线程池不同，ForkJoinPool 没有使用或者继承 ThreadPoolExecutor。它继承了 AbstractExecutorService。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>java.util.concurrent 包中的 CompletableFuture 就用到了 ForkJoinPool。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_COMMON_POOL =</span><br><span class="line">    (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class="line"><span class="comment"> * support parallelism.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor ASYNC_POOL = USE_COMMON_POOL ?</span><br><span class="line">    ForkJoinPool.commonPool() : <span class="keyword">new</span> ThreadPerTaskExecutor();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出如果机器 CPU 支持并行计算就会使用 ForkJoinPool。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程池&quot;&gt;&lt;a href=&quot;#Java-线程池&quot; class=&quot;headerlink&quot; title=&quot;Java 线程池&quot;&gt;&lt;/a&gt;Java 线程池&lt;/h1&gt;&lt;p&gt;线程的创建和消耗都需要一定的开销，如果每次执行一个异步任务都需要开一个线程去执行，则这些线程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BB%93%E5%90%88%20OkHttp%20%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BB%93%E5%90%88%20OkHttp%20%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C/</id>
    <published>2020-11-27T00:56:17.802Z</published>
    <updated>2020-11-27T00:56:17.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJava-结合-OkHttp-访问网络"><a href="#RxJava-结合-OkHttp-访问网络" class="headerlink" title="RxJava 结合 OkHttp 访问网络"></a>RxJava 结合 OkHttp 访问网络</h1><p>这里以访问 Github api 为例。</p><h2 id="创建-Observable"><a href="#创建-Observable" class="headerlink" title="创建 Observable"></a>创建 Observable</h2><p>首先使用 create 方法创建 Observable，在回调方法中使用 OkHttp 异步请求网络，然后将返回结果发送给 emitter 的 onNext 方法。同时实现 emitter 的 onError 和 onComplete。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;String&gt; <span class="title">getObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(emitter -&gt; &#123;</span><br><span class="line">            OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">            Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                    .url(<span class="string">&quot;https://api.github.com/users/flutter&quot;</span>)</span><br><span class="line">                    .get()</span><br><span class="line">                    .build();</span><br><span class="line">            Call call = okHttpClient.newCall(request);</span><br><span class="line">            call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> IOException e)</span> </span>&#123;</span><br><span class="line">                    emitter.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="meta">@NotNull</span> Call call, <span class="meta">@NotNull</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String str = response.body().string();</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;onResponse:&quot;</span> + response + <span class="string">&quot;, body:&quot;</span> + str);</span><br><span class="line">                    emitter.onNext(str);</span><br><span class="line">                    emitter.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="订阅观察者-Observer"><a href="#订阅观察者-Observer" class="headerlink" title="订阅观察者 Observer"></a>订阅观察者 Observer</h2><p>观察者订阅代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAsyncHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable&lt;String&gt; observable = getObservable();</span><br><span class="line">    observable.subscribeOn(Schedulers.io())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(str -&gt; Toast.makeText(getApplicationContext(), <span class="string">&quot;load success:&quot;</span> + str, Toast.LENGTH_LONG).show(),</span><br><span class="line">                    throwable -&gt; Log.e(TAG, <span class="string">&quot;onError:&quot;</span> + throwable.getMessage()), () -&gt; Log.d(TAG, <span class="string">&quot;onCompleted&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者收到 onNext 消息后发送 Toast。因为使用了 observeOn 方法运行在 Android 主线程，所以可以做 UI 操作。</p><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RxJavaActivity: onResponse:Response&#123;protocol&#x3D;http&#x2F;1.1, code&#x3D;200, message&#x3D;OK, url&#x3D;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;flutter&#125;, body:&#123;&quot;login&quot;:&quot;flutter&quot;,&quot;id&quot;:14101776, ...</span><br></pre></td></tr></table></figure><h2 id="添加网络权限"><a href="#添加网络权限" class="headerlink" title="添加网络权限"></a>添加网络权限</h2><p>网络请求需要在 AndroidManifest 添加网络权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>如果是 P 版本以上的非 Https 请求，需要在 application 节点配置允许明文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:networkSecurityConfig&#x3D;&quot;@xml&#x2F;network_security_config&quot;</span><br></pre></td></tr></table></figure><p>res/xml 目录的 network_security_config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">    &lt;base-config cleartextTrafficPermitted&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;network-security-config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RxJava-结合-OkHttp-访问网络&quot;&gt;&lt;a href=&quot;#RxJava-结合-OkHttp-访问网络&quot; class=&quot;headerlink&quot; title=&quot;RxJava 结合 OkHttp 访问网络&quot;&gt;&lt;/a&gt;RxJava 结合 OkHttp 访问网络&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/VirtualAPK%20%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.okclouder.cn/2020/11/27/VirtualAPK%20%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-27T00:56:17.802Z</published>
    <updated>2020-11-27T00:56:17.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VirtualAPK-插件化框架介绍"><a href="#VirtualAPK-插件化框架介绍" class="headerlink" title="VirtualAPK 插件化框架介绍"></a>VirtualAPK 插件化框架介绍</h1><p><a href="https://github.com/didi/VirtualAPK">VirtualAPK</a> 是一个 Android 插件化框架。如果一个 APK 有很多功能，其中一些功能使用的场景比较少，那么可以在这些功能被使用的时候动态加载，而不是一次性打包在整个 APK 中。插件化不仅可以缩小 APK 体积，也方便各个插件特性的动态更新。</p><p>使用 VirtualAPK 需要对主 APK （宿主）和插件 APK（插件）做一些修改定制。这里以 VirtualAPK 0.9.8 版本为例。</p><h2 id="主-APK-配置"><a href="#主-APK-配置" class="headerlink" title="主 APK 配置"></a>主 APK 配置</h2><p>在主 APK 的项目 build.gradle 配置 VirtualAPK 的插件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ....</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:3.2.0&#39;</span><br><span class="line">        classpath &#39;com.didi.virtualapk:gradle:0.9.8.6&#39;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是 gradle:3.2.0 的插件，如果使用 3.5 版本的 gradle，会出现 android 的 gradle 插件和 VirtualAPK 插件不兼容的情况，具体可以看 VirtualAPK 在 github 的 issue。</p><p>如果主 APK 使用了 AndroidX，也建议 android 的 gradle 插件版本在 3.2.0 以上，这样才能将 VirtualAPK 源码中对应 support 包的引用自动转换为 AndroidX。</p><p>然后配置主模块 app 的 build.gradle：</p><p>配置插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.didi.virtualapk.host&#39;</span><br></pre></td></tr></table></figure><p>配置依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; virtualapk</span><br><span class="line">    implementation &#39;com.didi.virtualapk:core:0.9.8&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 proguard 混淆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.didi.virtualapk.internal.VAInstrumentation &#123; *; &#125;</span><br><span class="line">-keep class com.didi.virtualapk.internal.PluginContentResolver &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">-dontwarn com.didi.virtualapk.**</span><br><span class="line">-dontwarn android.**</span><br><span class="line">-keep class android.** &#123; *; &#125;</span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">最后在 Application 的 attachBaseContext 方法中初始化 VirtualAPK</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">@Override</span><br><span class="line">protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    PluginManager.getInstance(base).init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为宿主 APK 需要加载插件，所以需要读取外部存储的权限（READ_EXTERNAL_STORAGE）。同时在 AndroidManifest 声明权限如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>以宿主 APK 的 HostActivity 启动插件 APK 的 MainActivity（com.android.plugin.MainActivity）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQ_WRITE_STORAGE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line">            <span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, REQ_WRITE_STORAGE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                launchPlugin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            launchPlugin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launchPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;virtualapk:&quot;</span>, <span class="string">&quot;launchPlugin&quot;</span>);</span><br><span class="line">        String pluginPath = Environment.getExternalStorageDirectory().getAbsolutePath().concat(<span class="string">&quot;/Test.apk&quot;</span>);</span><br><span class="line">        File plugin = <span class="keyword">new</span> File(pluginPath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">            intent.setClassName(<span class="string">&quot;com.android.plugin&quot;</span>, <span class="string">&quot;com.android.plugin.MainActivity&quot;</span>);</span><br><span class="line">            LoadedPlugin loadedPlugin = PluginManager.getInstance(<span class="keyword">this</span>).getLoadedPlugin(intent);</span><br><span class="line">            <span class="keyword">if</span> (loadedPlugin == <span class="keyword">null</span>) &#123;</span><br><span class="line">                PluginManager.getInstance(<span class="keyword">this</span>).loadPlugin(plugin);</span><br><span class="line">            &#125;</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;virtualapk:&quot;</span>, <span class="string">&quot;e:&quot;</span> + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQ_WRITE_STORAGE) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launchPlugin 首先从外部存储中加载插件 APK，如果插件 APK 已经加载过了，就直接跳转，否则先调用 loadPlugin 方法加载插件。</p><p>如果正常运行，宿主 APK 会先启动 HostActivity，然后立即跳转到插件 APK 的 MainActivity，显示插件 APK 的内容。</p><h2 id="插件-APK-配置"><a href="#插件-APK-配置" class="headerlink" title="插件 APK 配置"></a>插件 APK 配置</h2><p>在插件 APK 的项目 build.gradle 配置 VirtualAPK 的插件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:3.1.0&#39;</span><br><span class="line">        classpath &#39;com.didi.virtualapk:gradle:0.9.8.6&#39;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着配置 app 模块的 build.gradle：</p><p>配置插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;com.didi.virtualapk.plugin&#39;</span><br></pre></td></tr></table></figure><p>可以看出插件 APK 只需要配置 com.didi.virtualapk.plugin，而不用配置依赖，因为插件 APK 这时只是作为被依赖的。</p><p>最后需要配置 virtualApk 的定制配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtualApk &#123;</span><br><span class="line">    packageId &#x3D; 0x6f             &#x2F;&#x2F; The package id of Resources.</span><br><span class="line">    targetHost&#x3D;&#39;C:&#x2F;Users&#x2F;m&#x2F;AndroidStudioProjects&#x2F;AndroidSample&#x2F;app&#39; &#x2F;&#x2F; The path of application module in host project.</span><br><span class="line">    applyHostMapping &#x3D; true      &#x2F;&#x2F; [Optional] Default value is true.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是第二项配置，targetHost 表示主 APK 的 app 模块的路径，可以是绝对路径，可以是相对路径。这里用的是绝对路径。</p><p>如果插件 APK 的资源和主 APK 的资源名称相同，建议修改为其他名称和主 APK 的命名区分开。</p><p>比如 R.layout.activity_main 改名为 R.layout.activity_plugin_main</p><p>最后编译插件 APK 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean assemblePlugin</span><br></pre></td></tr></table></figure><p>注意插件 APK 必须要先配置好签名，不能用 debug 模式编译。</p><p>生成的插件 APK 位于 Plugin\app\build\outputs\plugin\release 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.plugin_20190921151552.apk</span><br></pre></td></tr></table></figure><p>然后将插件 APK 重命名为 Test.apk push 到手机的 /mnt/sdcard/ 目录，方便主 APK 从外部存储加载插件 APK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>VirtualAPK 是一个 Android 插件化框架，它支持四大组件以及资源的插件化。同时 VirtualAPK 有它自己的 Gradle 插件，宿主 APK 和 插件 APK 需要用 VirtualAPK 的 Gradle 插件编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VirtualAPK-插件化框架介绍&quot;&gt;&lt;a href=&quot;#VirtualAPK-插件化框架介绍&quot; class=&quot;headerlink&quot; title=&quot;VirtualAPK 插件化框架介绍&quot;&gt;&lt;/a&gt;VirtualAPK 插件化框架介绍&lt;/h1&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Dart%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>https://www.okclouder.cn/2020/11/27/Dart%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-27T00:56:17.800Z</published>
    <updated>2020-11-27T00:56:17.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart-语法简介"><a href="#Dart-语法简介" class="headerlink" title="Dart 语法简介"></a>Dart 语法简介</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>int 整数（-2^63 ~ 2^63-1）</p><p>double 双精度浮点数</p><p>num 既可以表示整数，也可以表示浮点数</p><p>String 字符串，采用 UTF-16 编码</p><p>bool 布尔值</p><p>List 列表</p><p>Set 集合</p><p>Map 键值对</p><p>Runes 表示采用 UTF-32 的字符串</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>?? 操作符</p><p>a ?? b 表示如果 a 是 null，那么表达式返回 b，否则返回 a。<br>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (a &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return b;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>??= 操作符</p><p>a ??= b 等价于 a = a ?? b</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是对象，它的类型是 Function。</p><p>返回值 函数名（参数） {</p><p>}</p><p>=&gt; 箭头函数</p><p>=&gt; 后面只能跟表达式，不能跟多个语句。表达式可以是函数或者值。</p><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">    return expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>每个对象都是类的实例。所有类都继承自 Object 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dart-语法简介&quot;&gt;&lt;a href=&quot;#Dart-语法简介&quot; class=&quot;headerlink&quot; title=&quot;Dart 语法简介&quot;&gt;&lt;/a&gt;Dart 语法简介&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-11-27T00:56:17.799Z</published>
    <updated>2020-11-27T00:56:17.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-知识路线"><a href="#Android-知识路线" class="headerlink" title="Android 知识路线"></a>Android 知识路线</h1><h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><h3 id="Android-四大组件"><a href="#Android-四大组件" class="headerlink" title="Android 四大组件"></a>Android 四大组件</h3><p>Activity</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774856">Activity 难点</a></p><p>Service</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774909">Service 难点</a></p><p>ContentProvider</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774994">ContentProvider 难点</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100718356">ContentProvider 的 query 流程分析</a></p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View 的绘制</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774749">View 的绘制流程</a></p><p>事件分发</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774628">View 的绘制流程</a></p><p>RemoteViews<br><a href="https://blog.csdn.net/caoshen2014/article/details/99775098">Android RemoveViews</a></p><p>Window 和 ViewRootImpl</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99775159">Android Window</a></p><h3 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h3><p>Binder</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710327">Binder 笔记</a></p><p>AIDL</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710365">AIDL</a></p><p>多进程</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99710355">Android 中的 IPC 方式</a></p><h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><p>消息队列 </p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99774788">Android 消息机制</a></p><p>AsyncTask 原理</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782462">AsyncTask 异步任务</a></p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>AMS</p><p>WMS</p><p>PMS</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100753666">Android setPackagesSuspended 暂停应用</a></p><h2 id="开源库原理"><a href="#开源库原理" class="headerlink" title="开源库原理"></a>开源库原理</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>OkHttp</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782656">Okhttp 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782712">OkHttp 源码解析</a></p><p>Retrofit</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782769">Retrofit 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782825">Retrofit 源码分析</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Glide</p><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>Rxjava</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/99782892">Android RxJava 基本用法</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100088147">RxJava 操作符介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100111136">RxJava 线程控制</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100129281">RxJava 结合 OkHttp 访问网络</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100181182">RxJava 结合 Retrofit 访问网络</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100188837">用 RxJava 实现 RxBus</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100603080">RxJava 线程切换过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100436237">RxJava 订阅过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100548442">RxJava 的 Map 变换过程解析</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100603080">RxJava 线程切换过程解析</a></p><h3 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h3><p>ButterKnife</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100831887">ButterKnife View 注解框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/100852352">ButterKnife View 注解框架原理解析</a></p><p>Dagger2</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101002939">Dagger2 依赖注入框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101042600">Dagger2 依赖注入的原理分析</a></p><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><p>Groovy</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102426429">Groovy 语法简介</a></p><p>Gradle 插件基础</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102493114">Gradle 脚本的执行时序</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102512720">Gradle 自定义 task</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102528973">Gradle 插件基础</a></p><h2 id="初级架构"><a href="#初级架构" class="headerlink" title="初级架构"></a>初级架构</h2><p>设计模式</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/102596842">Java 设计模式基本原则</a></p><p>MVC、MVP、MVVM</p><p>组件化</p><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><p>JNI 基础</p><p>NDK 基础</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>dalvik 沙盒机制</p><p>逆向工具：dex2jar jadx jd-gui</p><p>smali &amp; apktool</p><h2 id="动态化"><a href="#动态化" class="headerlink" title="动态化"></a>动态化</h2><p>热修复：Tinker</p><p>插件化：VirtualAPK</p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101108723">VirtualAPK 插件化框架介绍</a></p><p><a href="https://blog.csdn.net/caoshen2014/article/details/101401674">VirtualAPK 插件化原理分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-知识路线&quot;&gt;&lt;a href=&quot;#Android-知识路线&quot; class=&quot;headerlink&quot; title=&quot;Android 知识路线&quot;&gt;&lt;/a&gt;Android 知识路线&lt;/h1&gt;&lt;h2 id=&quot;核心知识点&quot;&gt;&lt;a href=&quot;#核心知识点&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Flutter%20TabBar%20%E6%A0%87%E7%AD%BE/"/>
    <id>https://www.okclouder.cn/2020/11/27/Flutter%20TabBar%20%E6%A0%87%E7%AD%BE/</id>
    <published>2020-11-27T00:56:17.798Z</published>
    <updated>2020-11-27T00:56:17.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-TabBar-标签"><a href="#Flutter-TabBar-标签" class="headerlink" title="Flutter TabBar 标签"></a>Flutter TabBar 标签</h1><p>Flutter 实现标签左右滑动切换，可以使用 TabBar 和 TabBarView。TabBar 和 TabBarView 分别表示标签和标签对应的内容页面。</p><h2 id="TabBar"><a href="#TabBar" class="headerlink" title="TabBar"></a>TabBar</h2><p>TabBar 需要指定一个 TabController 才能使用，TabController 用来控制 TabBar 的切换。</p><p>unselectedLabelColor： 未选中的标签的颜色。</p><p>labelColor：选中的标签的颜色。</p><p>indicatorColor：标签下方指示器线条的颜色。</p><p>indicatorSize：标签下方指示器线条的长度。如果是 label，表示和标签内容长度一样，如果是 tab，表示和整个标签长度一样长，即上一个标签的右边到下一个标签左边的长度。</p><p>tabs：表示每个标签的 widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  constraints: BoxConstraints.expand(height: <span class="number">50</span>),</span><br><span class="line">  child: TabBar(</span><br><span class="line">      controller: _controller,</span><br><span class="line">      unselectedLabelColor: Colors.black,</span><br><span class="line">      labelColor: Colors.blue,</span><br><span class="line">      indicatorColor: Colors.blue,</span><br><span class="line">      indicatorSize: TabBarIndicatorSize.label,</span><br><span class="line">      tabs: [</span><br><span class="line">        Tab(text: <span class="string">&quot;未结束&quot;</span>),</span><br><span class="line">        Tab(text: <span class="string">&quot;已结束&quot;</span>),</span><br><span class="line">        Tab(text: <span class="string">&quot;我的比赛&quot;</span>)</span><br><span class="line">      ]),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="TabBarView"><a href="#TabBarView" class="headerlink" title="TabBarView"></a>TabBarView</h2><p>TabBarView 指的是每个标签对应的内容界面，这个设置成 Expanded 可以扩展到整个内容区域。</p><p>TabBarView 也需要指定 TabController 和 每个标签下的 widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Expanded(</span><br><span class="line">  child: TabBarView(controller: _controller, children: [</span><br><span class="line">    ScoreListWidget(_isLoaded, _unFinishedMatches),</span><br><span class="line">    ScoreListWidget(_isLoaded, _finishedMatches),</span><br><span class="line">    Center(child: Text(<span class="string">&quot;我的比赛&quot;</span>))</span><br><span class="line">  ]),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="TabController"><a href="#TabController" class="headerlink" title="TabController"></a>TabController</h2><p>TabController 用来控制内容切换，可以将 TabBar 和 TabBarView 嵌套在一个 DefaultTabController 中。也可以使用自定义的 TabController。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_controller = TabController(length: <span class="number">3</span>, vsync: ScrollableState());</span><br><span class="line">_controller.addListener(() =&gt; &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_controller.index == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>TabController 通过 length 指定标签的个数。addListener 可以添加标签的滑动监听。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Flutter-TabBar-标签&quot;&gt;&lt;a href=&quot;#Flutter-TabBar-标签&quot; class=&quot;headerlink&quot; title=&quot;Flutter TabBar 标签&quot;&gt;&lt;/a&gt;Flutter TabBar 标签&lt;/h1&gt;&lt;p&gt;Flutter 实现</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20setPackagesSuspended%20%E6%9A%82%E5%81%9C%E5%BA%94%E7%94%A8/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20setPackagesSuspended%20%E6%9A%82%E5%81%9C%E5%BA%94%E7%94%A8/</id>
    <published>2020-11-27T00:56:17.797Z</published>
    <updated>2020-11-27T00:56:17.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-setPackagesSuspended-暂停应用"><a href="#Android-setPackagesSuspended-暂停应用" class="headerlink" title="Android setPackagesSuspended 暂停应用"></a>Android setPackagesSuspended 暂停应用</h1><p>setPackagesSuspended 是 PackageManager 的一个 public 方法，它可以用来暂停应用。<br>应用被暂停之后会进入 Suspended 状态，无法点击打开，会弹出一个系统对话框，提示应用已被暂停。应用的后台活动比如播放音乐也会被暂停。<br>Android 数字健康（com.google.android.apps.wellbeing)就是利用 setPackagesSuspended 方法暂停应用，达到限制应用使用的效果。</p><h2 id="setPackagesSuspended"><a href="#setPackagesSuspended" class="headerlink" title="setPackagesSuspended"></a>setPackagesSuspended</h2><p>setPackagesSuspended 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission(Manifest.permission.SUSPEND_APPS)</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspended(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        <span class="meta">@Nullable</span> PersistableBundle appExtras, <span class="meta">@Nullable</span> PersistableBundle launcherExtras,</span><br><span class="line">        String dialogMessage) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;setPackagesSuspended not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 setPackagesSuspended 是系统 api 方法，而且需要在 manifest 定义权限 Manifest.permission.SUSPEND_APPS。<br>Manifest.permission.SUSPEND_APPS 权限也是系统级别的。普通应用没有权限，只用系统应用可以使用 setPackagesSuspended。同时 setPackagesSuspended 也是 hide 方法。</p><p>setPackagesSuspended 的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPackageManager().setPackagesSuspended(packageNames, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, dialogMessage);</span><br></pre></td></tr></table></figure><p>getPackageManager 是 Context 类的抽象方法，本质上是调用了 ContextImpl 的 getPackageManager 方法。</p><p>getPackageManager() 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPackageManager pm = ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn&#x27;t matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> ApplicationPackageManager(<span class="keyword">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出构造了一个 ApplicationPackageManager，传入 context 和 IPackageManager。IPackageManager 是一个 binder 接口，从 ServiceManager 通过 getService 获取。</p><h2 id="ApplicationPackageManager-setPackagesSuspended"><a href="#ApplicationPackageManager-setPackagesSuspended" class="headerlink" title="ApplicationPackageManager setPackagesSuspended"></a>ApplicationPackageManager setPackagesSuspended</h2><p>查看 ApplicationPackageManager 的 setPackagesSuspended 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspended(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        PersistableBundle appExtras, PersistableBundle launcherExtras,</span><br><span class="line">        String dialogMessage) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPM.setPackagesSuspendedAsUser(packageNames, suspended, appExtras,</span><br><span class="line">                launcherExtras, dialogMessage, mContext.getOpPackageName(),</span><br><span class="line">                mContext.getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出远程调用了 PMS 的 setPackagesSuspendedAsUser，传入了应用自身的包名和 uid。</p><h2 id="PMS-的-setPackagesSuspendedAsUser"><a href="#PMS-的-setPackagesSuspendedAsUser" class="headerlink" title="PMS 的 setPackagesSuspendedAsUser"></a>PMS 的 setPackagesSuspendedAsUser</h2><p>PMS 的 setPackagesSuspendedAsUser 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] setPackagesSuspendedAsUser(String[] packageNames, <span class="keyword">boolean</span> suspended,</span><br><span class="line">        PersistableBundle appExtras, PersistableBundle launcherExtras,</span><br><span class="line">        SuspendDialogInfo dialogInfo, String callingPackage, <span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packageNames.length; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            pkgSetting.setSuspended(suspended, callingPackage, dialogInfo, appExtras,</span><br><span class="line">                    launcherExtras, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!changedPackagesList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] changedPackages = changedPackagesList.toArray(</span><br><span class="line">                <span class="keyword">new</span> String[changedPackagesList.size()]);V</span><br><span class="line">        sendPackagesSuspendedForUser(</span><br><span class="line">                changedPackages, changedUids.toArray(), userId, suspended, launcherExtras);</span><br><span class="line">        sendMyPackageSuspendedOrUnsuspended(changedPackages, suspended, appExtras, userId);</span><br><span class="line">        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">            scheduleWritePackageRestrictionsLocked(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unactionedPackages.toArray(<span class="keyword">new</span> String[unactionedPackages.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码调用了 pkgSetting.setSuspended，然后调用了 sendPackagesSuspendedForUser、sendMyPackageSuspendedOrUnsuspended。<br>setPackagesSuspendedAsUser 返回了 unactionedPackages，也就是没有被 suspend 的应用。</p><p>pkgSetting 的 setSuspended 方法其实就是 PackageSettingBase 的 setSuspended。</p><p>PackageSettingBase 的 setSuspended 方法会将 PackageUserState 的 suspended 改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">existingUserState.suspended = suspended;</span><br></pre></td></tr></table></figure><p>在 PackageParser 的 updateApplicationInfo 会更新应用的 applicationInfo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state.suspended) &#123;</span><br><span class="line">    ai.flags |= ApplicationInfo.FLAG_SUSPENDED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ai.flags &amp;= ~ApplicationInfo.FLAG_SUSPENDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出会根据 PackageUserState 的 suspended 属性添加或者删除 ApplicationInfo.FLAG_SUSPENDED。</p><p>FWK 中的其他地方判断一个应用是否被暂停了就是依靠这个 ApplicationInfo.FLAG_SUSPENDED 标记。</p><p>比如 ActivityStartInterceptor 应用启动拦截的 interceptSuspendedPackageIfNeeded 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do not intercept if the package is not suspended</span></span><br><span class="line"><span class="keyword">if</span> (mAInfo == <span class="keyword">null</span> || mAInfo.applicationInfo == <span class="keyword">null</span> ||</span><br><span class="line">        (mAInfo.applicationInfo.flags &amp; FLAG_SUSPENDED) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果应用没有 ApplicationInfo.FLAG_SUSPENDED（mAInfo.applicationInfo.flags &amp; FLAG_SUSPENDED），说明它没有被暂停，不要拦截它的启动。</p><h2 id="sendPackagesSuspendedForUser"><a href="#sendPackagesSuspendedForUser" class="headerlink" title="sendPackagesSuspendedForUser"></a>sendPackagesSuspendedForUser</h2><p>sendPackagesSuspendedForUser 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendPackagesSuspendedForUser</span><span class="params">(String[] pkgList, <span class="keyword">int</span>[] uidList, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> suspended, PersistableBundle launcherExtras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bundle extras = <span class="keyword">new</span> Bundle(<span class="number">3</span>);</span><br><span class="line">        extras.putStringArray(Intent.EXTRA_CHANGED_PACKAGE_LIST, pkgList);</span><br><span class="line">        extras.putIntArray(Intent.EXTRA_CHANGED_UID_LIST, uidList);</span><br><span class="line">        <span class="keyword">if</span> (launcherExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            extras.putBundle(Intent.EXTRA_LAUNCHER_EXTRAS,</span><br><span class="line">                    <span class="keyword">new</span> Bundle(launcherExtras.deepCopy()));</span><br><span class="line">        &#125;</span><br><span class="line">        sendPackageBroadcast(</span><br><span class="line">                suspended ? Intent.ACTION_PACKAGES_SUSPENDED</span><br><span class="line">                        : Intent.ACTION_PACKAGES_UNSUSPENDED,</span><br><span class="line">                <span class="keyword">null</span>, extras, Intent.FLAG_RECEIVER_REGISTERED_ONLY, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;userId&#125;, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出以上代码将参数封装到 bundle 中，然后发送了广播。广播 Action 是 Intent.ACTION_PACKAGES_SUSPENDED 或者 Intent.ACTION_PACKAGES_UNSUSPENDED。</p><p>sendPackageBroadcast 会调用 doSendBroadcast，然后调用 AMS 的 broadcastIntent。</p><h2 id="sendMyPackageSuspendedOrUnsuspended"><a href="#sendMyPackageSuspendedOrUnsuspended" class="headerlink" title="sendMyPackageSuspendedOrUnsuspended"></a>sendMyPackageSuspendedOrUnsuspended</h2><p>sendMyPackageSuspendedOrUnsuspended 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMyPackageSuspendedOrUnsuspended</span><span class="params">(String[] affectedPackages, <span class="keyword">boolean</span> suspended,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle appExtras, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">        action = Intent.ACTION_MY_PACKAGE_SUSPENDED;</span><br><span class="line">        <span class="keyword">if</span> (appExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Bundle bundledAppExtras = <span class="keyword">new</span> Bundle(appExtras.deepCopy());</span><br><span class="line">            intentExtras.putBundle(Intent.EXTRA_SUSPENDED_PACKAGE_EXTRAS, bundledAppExtras);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action = Intent.ACTION_MY_PACKAGE_UNSUSPENDED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendMyPackageSuspendedOrUnsuspended 也是发送广播，只不过它发送了 Intent.ACTION_MY_PACKAGE_SUSPENDED 和 Intent.ACTION_MY_PACKAGE_UNSUSPENDED。<br>被暂停的应用可以通过注册这两个 Action 的广播来通知自己是否被暂停了。另外被暂停的应用也可以使用 isPackageSuspended 方法判断自己是否处于暂停状态。</p><h2 id="ACTION-PACKAGES-SUSPENDED-广播接收"><a href="#ACTION-PACKAGES-SUSPENDED-广播接收" class="headerlink" title="ACTION_PACKAGES_SUSPENDED 广播接收"></a>ACTION_PACKAGES_SUSPENDED 广播接收</h2><p>查看 AMS 的 broadcastIntentLocked 方法，里面对 ACTION_PACKAGES_SUSPENDED 广播做了处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line"><span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">            intent.getAction());</span><br><span class="line">    <span class="keyword">final</span> String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">            Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userHandle = intent.getIntExtra(</span><br><span class="line">            Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">    mAtmInternal.onPackagesSuspendedChanged(packageNames, suspended,</span><br><span class="line">            userHandle);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以看出以上代码调用了 mAtmInternal.onPackagesSuspendedChanged 方法。</p><p>mAtmInternal 是ActivityTaskManagerService (ATMS)，它调用了 RecentTasks 的 onPackagesSuspendedChanged 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPackagesSuspendedChanged</span><span class="params">(String[] packages, <span class="keyword">boolean</span> suspended, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        mRecentTasks.onPackagesSuspendedChanged(packages, suspended, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecentTasks 的 onPackagesSuspendedChanged 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPackagesSuspendedChanged</span><span class="params">(String[] packages, <span class="keyword">boolean</span> suspended, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">            <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">                mSupervisor.removeTaskByIdLocked(tr.taskId, <span class="keyword">false</span>,</span><br><span class="line">                        REMOVE_FROM_RECENTS, <span class="string">&quot;suspended-package&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果应用被暂停，它会从 tasks 中移除。</p><p>除了 AMS， NMS（NotificationManagerService）、WMS（WindowManagerService）和其他一些地方也注册了 ACTION_PACKAGES_SUSPENDED 广播。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>PacakgeManager 的 setPackagesSuspended 方法可以暂停或者恢复应用。</li><li>setPackagesSuspended 通过 PMS 改变 ApplicationInfo 的 FLAG_SUSPENDED 标记和发送 ACTION_PACKAGES_SUSPENDED、ACTION_MY_PACKAGE_SUSPENDED 通知 FWK 的其他服务（AMS 等）实现应用暂停的效果。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-setPackagesSuspended-暂停应用&quot;&gt;&lt;a href=&quot;#Android-setPackagesSuspended-暂停应用&quot; class=&quot;headerlink&quot; title=&quot;Android setPackagesSuspend</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Dagger2%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.okclouder.cn/2020/11/27/Dagger2%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-11-27T00:56:17.796Z</published>
    <updated>2020-11-27T00:56:17.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dagger2-依赖注入框架介绍"><a href="#Dagger2-依赖注入框架介绍" class="headerlink" title="Dagger2 依赖注入框架介绍"></a>Dagger2 依赖注入框架介绍</h1><p>Dagger2 是一个标准的依赖注入框架。Dagger2 是 Dagger1（Square 公司开发）的分支，由谷歌接手开发。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>这里以 dagger 2.24 版本为例，在 app 的 build.gradle 添加 dagger 依赖如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Add Dagger dependencies</span><br><span class="line">dependencies &#123;</span><br><span class="line">  api &#39;com.google.dagger:dagger:2.24&#39;</span><br><span class="line">  annotationProcessor &#39;com.google.dagger:dagger-compiler:2.24&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Inject-和-Component"><a href="#Inject-和-Component" class="headerlink" title="@Inject 和 @Component"></a>@Inject 和 @Component</h2><p>假设由一个 Watch 类，需要调用 Watch 类的 work 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了注入 Watch 依赖，需要给它的构造方法添加 @Inject 注解，表明 dagger 使用 Watch 的构造方法构建对象。</p><p>接下来使用 @Component 注解来完成依赖注入。</p><p>定义 MainDaggerActivityComponent 接口如下，表示需要将依赖注入给 MainDaggerActivity。</p><p>定义的接口通常为类名 + Component 的形式，dagger 会自动生成 Dagger + 类名 + Component 形式的辅助类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 MainDaggerActivity 调用编译生成的文件 DaggerMainDaggerActivityComponent，调用它的 inject 方法完成依赖注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Watch watch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        DaggerMainDaggerActivityComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">        watch.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码会调用 watch 对象的 work 方法。输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;dagger2: work</span><br></pre></td></tr></table></figure><h2 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a>@Module 和 @Provides</h2><p>如果在项目中使用了第三方开源框架，比如 Gson，那么不能直接对 Gson 使用 @Inject 注解。因为 Gson 没有一个被 @Inject 注解的构造方法。</p><p>具体报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: [Dagger&#x2F;MissingBinding] com.google.gson.Gson cannot be provided without an @Inject constructor or an @Provides-annotated method.</span><br></pre></td></tr></table></figure><p>所以需要一个工厂类来提供生成 Gson 对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gson <span class="title">providesGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Module 标注的类是一个工厂类。@Provides 标记的方法是一个工厂方法，用来生成各种类的对象。</p><p>在 Component 接口定义中新增 modules 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = GsonModule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码说明 inject 注入时，可以使用 GsonModule 来提供注入对象。</p><p>最后在 MainDaggerActivity 注入 Gson 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Watch watch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        DaggerMainDaggerActivityComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">        String jsonD = <span class="string">&quot;&#123;&#x27;name&#x27;: &#x27;zhangwuji&#x27;, &#x27;age&#x27;: 20&#125;&quot;</span>;</span><br><span class="line">        Man man = gson.fromJson(jsonD, Man.class);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;man:&quot;</span> + man);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Man&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;dagger2: man:Man&#123;name&#x3D;&#39;zhangwuji&#39;, age&#x3D;20&#125;</span><br></pre></td></tr></table></figure><p>类似的，如果需要注入的对象是抽象类，@Inject 注解也无法被使用，因为抽象类不能被实例化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了 Engine 抽象类，接着定义它的实现类 GasolineEngine:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasolineEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GasolineEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GasolineEngine: work&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 Car 类引用 Engine：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 MainDaggerActivity 注入 Car 对象，编译会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Car car;</span><br></pre></td></tr></table></figure><p>具体报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: [Dagger&#x2F;MissingBinding] com.caoshen.androidsample.dagger.Engine cannot be provided without an @Provides-annotated method.</span><br></pre></td></tr></table></figure><p>因为 Car 的构造方法传入的是抽象类 Engine，Engine 类没有构造方法。</p><p>这时可以使用 @Module 和 @Provides 注解提供工厂方法。</p><p>编写 GasolineEngine 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasolineEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GasolineEngine: work&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 EngineModule 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GasolineEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 MainDaggerActivityComponent 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;GsonModule.class, EngineModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 Car 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Car car;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        DaggerMainDaggerActivityComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;car:&quot;</span> + car.run());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;dagger2: car:GasolineEngine: work</span><br></pre></td></tr></table></figure><h2 id="Named-和-Qualifier"><a href="#Named-和-Qualifier" class="headerlink" title="@Named 和 @Qualifier"></a>@Named 和 @Qualifier</h2><p>@Qualifier 是限定符，@Named 则是 @Qualifier 的一种实现。当有两个相同的依赖时，它们都继承同一个父类或者均实现同一个接口。当它们被提供给 Component 时，就会不知道要提供哪一个依赖对象。</p><p>假设提供了新的 Engine：DieselEngine。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieselEngine</span> <span class="keyword">extends</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DieselEngine: work&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 EngineModule 提供如下 2 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesGasoline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GasolineEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesDiesel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DieselEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: [Dagger&#x2F;DuplicateBindings] com.caoshen.androidsample.dagger.Engine is bound multiple times:</span><br><span class="line">@Provides com.caoshen.androidsample.dagger.Engine com.caoshen.androidsample.dagger.EngineModule.providesDiesel()</span><br><span class="line">@Provides com.caoshen.androidsample.dagger.Engine com.caoshen.androidsample.dagger.EngineModule.providesGasoline()</span><br></pre></td></tr></table></figure><p>编译错误表明 Engine 可能有多个实现，不知道用哪个构造方法。</p><p>这时可以使用 @Named 注解，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;Gasoline&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesGasoline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GasolineEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Named(&quot;Diesel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesDiesel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DieselEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Car 类指定依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="meta">@Named(&quot;Diesel&quot;)</span> Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;dagger2: car:DieselEngine: work</span><br></pre></td></tr></table></figure><p>以上的代码通过 @Named 来指定采用 provides 的方式来生成实例。也可以用 @Qualifier 来实现，@Qualifier 用来定义注解。</p><p>定义 Gasoline 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Gasoline &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Diesel 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Diesel &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 EngineModule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EngineModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Gasoline</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesGasoline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GasolineEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Diesel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">providesDiesel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DieselEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 Diesel 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(<span class="meta">@Diesel</span> Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dagger2: car:DieselEngine: work</span><br></pre></td></tr></table></figure><h2 id="Singleton-和-Scope"><a href="#Singleton-和-Scope" class="headerlink" title="@Singleton 和 @Scope"></a>@Singleton 和 @Scope</h2><p>@Scope 是用来自定义注解的，而 @Singleton 则是用来配合实现局部单例和全局单例的。需要注意的是，@Singleton 本身并不具备创建单例的能力。</p><p>如果我们要使用两次 Gson，会这么做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Gson gson1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Gson gson2;</span><br></pre></td></tr></table></figure><p>由于 gson1 和 gson2 的内存地址不一样，所以是 2 个 Gson 对象。如果想让 Gson 是一个单例，可以在 GsonModule 中添加 @Singleton 标签。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gson <span class="title">providesGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Component 接口中添加 @Singleton：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;GsonModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MainDaggerActivity 打印日志如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Gson gson1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line">Gson gson2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_dagger);</span><br><span class="line">    DaggerMainDaggerActivityComponent.create().inject(<span class="keyword">this</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;dagger2&quot;</span>, gson1.equals(gson2) ? <span class="string">&quot;same&quot;</span> : <span class="string">&quot;different&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D&#x2F;dagger2: same</span><br></pre></td></tr></table></figure><p>可以看出 gson1 和 gson2 是同一个对象。</p><p>但是 gson1 和 gson2 只是在 MainDaggerActivity 相同，如果再创建一个 Activity2，Activity2 里面的 gson 就和 gson1、gson2 不同，也就是说 gson1 和 gson2 只能保证局部单例。</p><p>如果想实现全局单例，就需要保证对应的 Component 只有一个实例。</p><p>查看 @Singleton 注解的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看出 @Singleton 注解是被 @Scope 注解的。</p><p>为了实现 Gson 的全局单例，可以使用 @Scope 配合 Application。</p><p>首先定义 @ApplicationScope 注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ApplicationScope &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着再 GsonModule 中使用 @ApplicationScope 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApplicationScope</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gson <span class="title">providesGson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Component 中添加注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;GsonModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity2 activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 Application 继承 Application：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainDaggerActivityComponent activityComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        activityComponent = DaggerMainDaggerActivityComponent.builder().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SampleApplication <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SampleApplication) context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainDaggerActivityComponent <span class="title">getActivityComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Application 是单例的，所以保证了 MainDaggerActivityComponent 也是单例。</p><p>用同一个 MainDaggerActivityComponent 在 2 个 Activity inject 依赖如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        SampleApplication.get(<span class="keyword">this</span>).getActivityComponent().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;gson1: hashcode:&quot;</span> + gson1.hashCode());</span><br><span class="line"></span><br><span class="line">        launch2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">launch2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startActivity(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainDaggerActivity2.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity2</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        SampleApplication.get(<span class="keyword">this</span>).getActivityComponent().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;gson2: hashcode:&quot;</span> + gson2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志打印可以发现 activity1 的 gson1 和 activity2 的 gson2 是同一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-09-18 21:05:19.263 9575-9575&#x2F;com.caoshen.androidsample D&#x2F;dagger2: gson1: hashcode:133084731</span><br><span class="line">2019-09-18 21:05:19.868 9575-9575&#x2F;com.caoshen.androidsample D&#x2F;dagger2: gson2: hashcode:133084731</span><br></pre></td></tr></table></figure><p>通常来说一个应用会有很多 Component，为了管理这些 Component，可以使用自定义 Scope 注解。他可以更好地管理 Component 和 Module 之间的匹配关系。比如编译器会检查 Component 管理的 Module。如果发现 Module 创建实例的 Scope 注解和 Component 的 Scope 注解不一致就会编译报错。</p><h2 id="Component-的-dependencies"><a href="#Component-的-dependencies" class="headerlink" title="@Component 的 dependencies"></a>@Component 的 dependencies</h2><p>@Component 也可以用 dependencies 依赖其他 component。</p><p>定义 Swordman 类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swordman</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Swordman</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fighting&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Module 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwordmanModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Swordman <span class="title">providesSwordman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Swordman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Component 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(modules = SwordmanModule.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SwordmanComponent</span> </span>&#123;</span><br><span class="line">    <span class="function">Swordman <span class="title">getSwordman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MainDaggerActivityComponent 添加 Component 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="meta">@Component(modules = &#123;GsonModule.class&#125;, dependencies = SwordmanComponent.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainDaggerActivityComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity activity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainDaggerActivity2 activity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 application 中引入依赖的 Module</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    activityComponent = DaggerMainDaggerActivityComponent.builder()</span><br><span class="line">            .swordmanComponent(DaggerSwordmanComponent.builder().build())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 DaggerMainDaggerActivityComponent 构造时多了 DaggerSwordmanComponent 的构造过程。</p><p>最后在 activity 注入 Swordman 依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Swordman swordman;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        SampleApplication.get(<span class="keyword">this</span>).getActivityComponent().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;swordman:&quot;</span> + swordman.fight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dagger2: swordman:fighting</span><br></pre></td></tr></table></figure><p>可以看出依赖的 swordman Component 也注入成功。</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载模式即 @Inject 不初始化，使用时才初始化。改写上面的 swordman component 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainDaggerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Gson gson2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Lazy&lt;Swordman&gt; swordman;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_dagger);</span><br><span class="line">        SampleApplication.get(<span class="keyword">this</span>).getActivityComponent().inject(<span class="keyword">this</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;dagger2&quot;</span>, <span class="string">&quot;lazy swordman:&quot;</span> + swordman.get().fight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 @Inject 了 Lazy 对象，使用时需要先 get() 得到真正的 swordman 对象。</p><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/dagger2: lazy swordman:fighting</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dagger2 通过注解的方式构造实例对象，避免使用者在调用对象的时候一层层构造依赖。因为使用者不需要了解它所依赖的对象的细节，而只需要调用依赖的方法，所以可以通过注解的方式将依赖组建的构造方式交给 Dagger2 的 Component 去处理，避免了大量重复的构建工作。</p><p>常用的注解有 @Inject、@Component、@Module、@Provides、@Named、@Qualifier、@Singleton、@Scope 等，也可以使用 Lazy 懒加载的方式在使用时创建对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dagger2-依赖注入框架介绍&quot;&gt;&lt;a href=&quot;#Dagger2-依赖注入框架介绍&quot; class=&quot;headerlink&quot; title=&quot;Dagger2 依赖注入框架介绍&quot;&gt;&lt;/a&gt;Dagger2 依赖注入框架介绍&lt;/h1&gt;&lt;p&gt;Dagger2 是一个标准的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Android%20%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/"/>
    <id>https://www.okclouder.cn/2020/11/27/Android%20%E5%B4%A9%E6%BA%83%E4%BC%98%E5%8C%96/</id>
    <published>2020-11-27T00:56:17.794Z</published>
    <updated>2020-11-27T00:56:17.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-崩溃优化"><a href="#Android-崩溃优化" class="headerlink" title="Android 崩溃优化"></a>Android 崩溃优化</h1><h2 id="Android-的两种崩溃"><a href="#Android-的两种崩溃" class="headerlink" title="Android 的两种崩溃"></a>Android 的两种崩溃</h2><ol><li>Java 崩溃</li><li>Native 崩溃</li></ol><p>Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。</p><p>Native 崩溃一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-崩溃优化&quot;&gt;&lt;a href=&quot;#Android-崩溃优化&quot; class=&quot;headerlink&quot; title=&quot;Android 崩溃优化&quot;&gt;&lt;/a&gt;Android 崩溃优化&lt;/h1&gt;&lt;h2 id=&quot;Android-的两种崩溃&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/GitHub%20Pages%20%E5%BC%BA%E5%88%B6%20HTTPS/"/>
    <id>https://www.okclouder.cn/2020/11/27/GitHub%20Pages%20%E5%BC%BA%E5%88%B6%20HTTPS/</id>
    <published>2020-11-27T00:56:17.791Z</published>
    <updated>2020-11-27T00:56:17.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitHub-Pages-强制-HTTPS"><a href="#GitHub-Pages-强制-HTTPS" class="headerlink" title="GitHub Pages 强制 HTTPS"></a>GitHub Pages 强制 HTTPS</h1><ol><li>打开 <a href="https://github.com/yourname/yourproject/settings">https://github.com/yourname/yourproject/settings</a>, yourname 是 github 账号名，yourproject 是 github 项目名称。</li><li>找到 options -&gt; GitHub Pages, 勾选 Enforce HTTPS.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GitHub-Pages-强制-HTTPS&quot;&gt;&lt;a href=&quot;#GitHub-Pages-强制-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;GitHub Pages 强制 HTTPS&quot;&gt;&lt;/a&gt;GitHub Pages 强制 HTTPS&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2020-11-27T00:56:17.790Z</published>
    <updated>2020-11-27T00:56:17.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-设计模式基本原则"><a href="#Java-设计模式基本原则" class="headerlink" title="Java 设计模式基本原则"></a>Java 设计模式基本原则</h1><p>Java 设计模式有 6 个基本的原则：</p><ul><li>单一职责。一个类最好只负责一个功能的职责，避免多个功能混杂。</li><li>里氏替换。所有使用基类的地方都应该可以被它的子类替换。</li><li>依赖反转。抽象不应该依赖于细节，细节应该依赖于抽象。调用者不应该依赖于被调用者的构造细节。</li><li>接口隔离。接口的定义应该拆分最小化。</li><li>迪米特法则。一个类应该尽可能少地了解其他的类，与其他类的耦合降到最低。</li><li>开闭原则。一个类的功能应该对外扩展开放，对内修改关闭。</li></ul><p>评价一个设计是否良好有以下几个因素：</p><ol><li><p>开闭性是否良好。当前的设计是否考虑到未来一段时间的变动。如果每次修改都导致其他核心代码被修改，说明设计存在问题。</p></li><li><p>可维护性/可读性。如果一个设计过于晦涩难懂，后续代码将难以维护。设计的一个目的是让代码清晰易懂。</p></li><li><p>性能。好的设计需要考虑是否会带来性能问题。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-设计模式基本原则&quot;&gt;&lt;a href=&quot;#Java-设计模式基本原则&quot; class=&quot;headerlink&quot; title=&quot;Java 设计模式基本原则&quot;&gt;&lt;/a&gt;Java 设计模式基本原则&lt;/h1&gt;&lt;p&gt;Java 设计模式有 6 个基本的原则：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://www.okclouder.cn/2020/11/27/RxJava%20%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2020-11-27T00:56:17.790Z</published>
    <updated>2020-11-27T00:56:17.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxJava-线程切换过程解析"><a href="#RxJava-线程切换过程解析" class="headerlink" title="RxJava 线程切换过程解析"></a>RxJava 线程切换过程解析</h1><p>RxJava 可以配合 RxAndroid 使用 Schedulers 和 AndroidSchedulers 完成线程的切换。</p><h2 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribeOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Disposable disp = Observable</span><br><span class="line">            .create(emitter -&gt; &#123;</span><br><span class="line">                emitter.onNext(<span class="number">1</span>);</span><br><span class="line">                emitter.onComplete();</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribeOn(Schedulers.newThread())</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(i -&gt; Log.d(TAG, <span class="string">&quot;accept:&quot;</span> + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码首先调用 Observable.create 方法构造 Observable，然后调用 subscribeOn 方法在子线程执行，接着调用 observeOn 方法切换到主线程执行。最后调用 subscribe 方法打印订阅到的值。</p><h2 id="subscribeOn-流程解析"><a href="#subscribeOn-流程解析" class="headerlink" title="subscribeOn 流程解析"></a>subscribeOn 流程解析</h2><p>subscribeOn 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Observable 的其他方法类似，subscribeOn 方法构造了 ObservableSubscribeOn，然后由 RxJavaPlugins 的 onAssembly 调用。</p><p>ObservableSubscribeOn 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line"></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObservableSubscribeOn 的构造方法传入了 source 和 scheduler，分别是源 ObservableSource 和 调度器 scheduler。这里的 ObservableSource 是上一步 create 得到的 ObservableCreate 类，scheduler 是 Schedulers.newThread() 得到的 NewThreadScheduler，本质上是一个线程的 ScheduledThreadPoolExecutor。</p><p>ObservableSubscribeOn 的 subscribeActual 将 observer 封装成 SubscribeOnObserver。然后调用了 observer 的 onSubscribe 方法和 parent 的 setDisposable 方法。</p><p>这里主要看一下 parent.setDisposable 的参数 scheduler.scheduleDirect(new SubscribeTask(parent))。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscribeTask 实现了 Runnable 接口，在 run 方法调用 source.subscribe(parent)，也就是把上一步 create 的操作放到 Runnable 执行。</p><p>scheduler.scheduleDirect 对于 Schedulers.newThread() 调度器来说，就是 NewThreadWorker 的 scheduleDirect 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    ScheduledDirectTask task = <span class="keyword">new</span> ScheduledDirectTask(RxJavaPlugins.onSchedule(run));</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            f = executor.submit(task);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule(task, delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        task.setFuture(f);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前说过 scheduler 是 Schedulers.newThread() 得到的 NewThreadScheduler，本质上是一个线程的 ScheduledThreadPoolExecutor。这里的 scheduleDirect 方法本质上调用了 submit 方法（如果 delay &gt; 0，有延迟，则是 schedule 方法）。因此我们通过第一步 create 的 emitter.onNext(1) 发射数据的操作是在一个单线程池执行的。</p><h2 id="observeOn-流程解析"><a href="#observeOn-流程解析" class="headerlink" title="observeOn 流程解析"></a>observeOn 流程解析</h2><p>observeOn 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 observeOn 调用了 3 参数的 observeOn。</p><p>3 参数的 observeOn 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">&quot;bufferSize&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observeOn 方法构造了 ObservableObserveOn，然后由 RxJavaPlugins 的 onAssembly 调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出 subscribeActual 方法调用了 scheduler 的 createWorker，然后创建一个 ObserveOnObserver 作为真正的 observer 交给 source subscribe。</p><p>这里的 worker 就是 scheduler 创建的，而 scheduler 传入的是一个 AndroidSchedulers.mainThread() 得到的主线程调度器。最终会返回 AndroidSchedulers 的 MainHolder.DEFAULT 对象。</p><p>MainHolder.DEFAULT 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Android-specific Schedulers. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidSchedulers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT</span><br><span class="line">            = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可以看出 AndroidSchedulers.mainThread() 调度器本质上就是一个主线程的 Handler（由主线程的 Looper 构造的 Handler）。所有的订阅者事件都会被封装成主线程消息发送到主线程执行。</p><h2 id="subscribe-流程解析"><a href="#subscribe-流程解析" class="headerlink" title="subscribe 流程解析"></a>subscribe 流程解析</h2><p>在 Observable 的 create、subscribeOn、observeOn 方法之后，接下来调用了 Observable 的 subscribe 方法。</p><p>subcribe 方法有很多重载方法。这里以一个 Consumer 的方法为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它调用了 4 参数的 subscribe 方法，返回一个 Disposable 对象。</p><p>4 参数的 subscribe 方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></span><br><span class="line"><span class="function"><span class="params">        Action onComplete, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(onNext, <span class="string">&quot;onNext is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onError, <span class="string">&quot;onError is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onComplete, <span class="string">&quot;onComplete is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onSubscribe, <span class="string">&quot;onSubscribe is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    LambdaObserver&lt;T&gt; ls = <span class="keyword">new</span> LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span><br><span class="line"></span><br><span class="line">    subscribe(ls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对每个参数进行判空操作，然后用 4 个参数构造了LambdaObserver，LambdaObserver 实现了 Observer, Disposable 等接口。最后调用了 subscribe 方法。</p><p>subscribe 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">        ObjectHelper.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出实际上调用了当前 Observable 的 subscribeActual 方法。</p><p>而当前的 Observable 其实就是封装了 create、subscribeOn、observeOn 的 ObservableObserveOn 对象。</p><p>从 observeOn 流程解析可以看出，ObservableObserveOn 的 subscribeActual 方法构造了一个 Scheduler.Worker，然后将原始 observer 和 worker 封装为新的 ObserveOnObserver，交给 ObservableObserveOn 的上一级 source，也就是 ObservableSubscribeOn 的 subscribe 方法。</p><p>这里我们还是看下 ObservableObserveOn 的内部类 ObserveOnObserver。ObserveOnObserver 实现了 Runnable 接口，它的 schedule 方法就是把自己扔到 worker 中执行。</p><p>ObserveOnObserver 的 run 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">        drainFused();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下 outputFused 为 false，会调用 drainNormal。</p><p>drainNormal 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = downstream;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ...</span><br><span class="line">                        v = q.poll();</span><br><span class="line">                    ...</span><br><span class="line">                    a.onNext(v);</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看出 drainNormal 会调用 downstream 的 onNext 方法，就是下游 observer 的 onNext 方法。下游 observer 其实就是 LambdaObserver ，也就是说会调用 LambdaObserver 的 onNext，最后会 LambdaObserver 的 onNext 方法会调用示例代码中的 consumer，它调用了 accept 方法，将最终结果用 logcat 打印出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>通过 Observable 的 create 方法，可以将 ObservableOnSubscribe 转换为 ObservableCreate。</p></li><li><p>通过 Observable 的 subscribeOn 方法，可以将 ObservableCreate 转换为 ObservableSubscribeOn，第一步的发射数据操作会被封装成 Runnable 放入单线程池执行。</p></li><li><p>通过 Observable 的 observeOn 方法，可以将 ObservableSubscribeOn 转换为 ObservableObserveOn。传入的 AndroidSchedulers.mainThread() 调度器本质上就是一个主线程的 Handler。所有的订阅者事件都会被封装成主线程消息发送到主线程执行。</p></li><li><p>Observable 的 subscribe 方法会调用 ObservableObserveOn 的 subscribeActual，然后在 drainNormal 方法中会调用到 observer 的 onNext 方法，执行真正的订阅者操作。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RxJava-线程切换过程解析&quot;&gt;&lt;a href=&quot;#RxJava-线程切换过程解析&quot; class=&quot;headerlink&quot; title=&quot;RxJava 线程切换过程解析&quot;&gt;&lt;/a&gt;RxJava 线程切换过程解析&lt;/h1&gt;&lt;p&gt;RxJava 可以配合 RxAndr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%20Runnable%20%E4%B8%8E%20Callable/"/>
    <id>https://www.okclouder.cn/2020/11/27/Java%20%E7%BA%BF%E7%A8%8B%20Runnable%20%E4%B8%8E%20Callable/</id>
    <published>2020-11-27T00:56:17.789Z</published>
    <updated>2020-11-27T00:56:17.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程-Runnable-与-Callable"><a href="#Java-线程-Runnable-与-Callable" class="headerlink" title="Java 线程 Runnable 与 Callable"></a>Java 线程 Runnable 与 Callable</h1><p>如果想在新线程运行代码，可以使用 Thread 传递 Runnable 参数或者使用 Executor 调用 Callable 对象的方法。两者的区别主要在于 Callable 会返回一个 Future 对象，用来表示执行结果。</p><h2 id="Thread-和-Runnable"><a href="#Thread-和-Runnable" class="headerlink" title="Thread 和 Runnable"></a>Thread 和 Runnable</h2><p>运行 Thread 通常有 2 种方法:</p><ol><li>继承 Thread 类，复写它的 run 方法。</li><li>实现 Runnable 接口，作为 Thread 类的构造参数传递。</li></ol><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>自定义的 ExtendThread 继承 Thread 类，复写 run 方法，最后调用 start 启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;extend thread and override run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ExtendThread().start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个 super.run，它会调用 Thread 的 run 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>target 是 Thread 构造时传入的 runnable，因为构造 ExtendThread 时没有传递 runnable，所以不会调用到。</p><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>可以直接构造一个匿名 Runnable，然后作为构造参数传递给 Thread 类，最后调用 start 方法启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;just run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较推荐第二种方式，即实现 Runnable 接口优于继承 Thread 类（接口优于继承）。因为代码的主要逻辑都在 run 方法中，如果有新的任务需要在 Thread 执行，只需要替换 Runnable 即可，不用关心 Thread 的内部实现。自定义类继承 Thread 的方式重写了 run 方法，破坏了 Thread 的原有结构，如果有新的任务要执行就又要构造一个自定义 Thread。</p><h2 id="Callable-和-Future"><a href="#Callable-和-Future" class="headerlink" title="Callable 和 Future"></a>Callable 和 Future</h2><p>Callable 是 java.util.concurrent 的一个接口类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Callable 提供了返回值，或者抛出一个异常，而且支持泛型。</p><p>Callable 通常和 Executors 里面的线程池配合使用，返回一个 Future 类型表示执行结果。Future 的 get 方法用来获取执行结果，但是 get 会阻塞线程，直到 call 方法执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello callable&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Future&lt;String&gt; future = Executors.newSingleThreadExecutor().submit(callable);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>假设有 2 个 Callable 分别在执行，它们执行结束的时间可能不同，如果想要等待 2 者都执行完毕后再做一些事情，可以使用 CompletableFuture。</p><p>CompletableFuture 类实现了 Future 和 CompletionStage 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><p>supplyAsync 方法可以返回一个在 ForkJoinPool#commonPool() 执行的 CompletableFuture。</p><p>thenCombine 方法会把 2 个 CompletableFuture 联合执行，并且把它们的执行结果传递给一个二元方法，得到一个新的 CompletableFuture。</p><p>join 方法得到最终的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; supply1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello3&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; supply2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello5&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    String result = supply1.thenCombine(supply2, (s, s2) -&gt; s + s2).join();</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 5 秒后输出结果如下:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result:hello3hello5</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程-Runnable-与-Callable&quot;&gt;&lt;a href=&quot;#Java-线程-Runnable-与-Callable&quot; class=&quot;headerlink&quot; title=&quot;Java 线程 Runnable 与 Callable&quot;&gt;&lt;/a&gt;Java </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.okclouder.cn/2020/11/27/Retrofit%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://www.okclouder.cn/2020/11/27/Retrofit%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2020-11-27T00:56:17.789Z</published>
    <updated>2020-11-27T00:56:17.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit-基本用法"><a href="#Retrofit-基本用法" class="headerlink" title="Retrofit 基本用法"></a>Retrofit 基本用法</h1><h2 id="Retrofit-介绍"><a href="#Retrofit-介绍" class="headerlink" title="Retrofit 介绍"></a>Retrofit 介绍</h2><p>Retrofit 是 Square 开发的 Android 网络请求框架，它是基于 OkHttp 实现的。与其他网络框架不同，它使用运行时注解提供功能。</p><h2 id="Retrofit-依赖"><a href="#Retrofit-依赖" class="headerlink" title="Retrofit 依赖"></a>Retrofit 依赖</h2><p>在 build.gradle 配置依赖如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.squareup.retrofit2:retrofit:2.6.1&#39;</span><br><span class="line">implementation &#39;com.squareup.retrofit2:converter-gson:2.6.1&#39;</span><br></pre></td></tr></table></figure><p>第一行配置了 retrofit 依赖。第二行配置了 gson 转换依赖。</p><h2 id="Retrofit-注解分类"><a href="#Retrofit-注解分类" class="headerlink" title="Retrofit 注解分类"></a>Retrofit 注解分类</h2><p>Retrofit 有 3 类注解：</p><ol><li>请求方法注解；</li><li>标记类注解；</li><li>参数类注解。</li></ol><p>Http 请求方法注解有 8 种：GET、POST、PUT、DELETE、HEAD、PATCH、OPTIONS、HTTP。</p><p>标记类注解有 3 种：FormUrlEncoded、Multipart、Streaming。</p><p>参数类注解：Header、Headers、Body、Path、Field、FieldMap、Part、PartMap、Query 和 QueryMap 等。</p><h2 id="GET-请求访问网络"><a href="#GET-请求访问网络" class="headerlink" title="GET 请求访问网络"></a>GET 请求访问网络</h2><p>这里以淘宝 IP 库为例。<br>首先定义网络请求接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IpService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET(&quot;getIpInfo.php?ip=59.108.54.37&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;IpModel&gt; <span class="title">getIpMsg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过建造者模式构建 Retrofit，使用 Retrofit 动态代理获取定义的 Service 接口，并调用接口的 getIpMsg 方法获取 Call 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(url)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build();</span><br><span class="line">IpService ipService = retrofit.create(IpService.class);</span><br><span class="line">Call&lt;IpModel&gt; call = ipService.getIpMsg();</span><br></pre></td></tr></table></figure><p>然后使用 call.enqueue 方法异步请求网络。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;IpModel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;IpModel&gt; call, Response&lt;IpModel&gt; response)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;IpModel&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的 Callback 默认运行在 UI 线程。</p><p>如果想同步请求网络，使用 execute 方法。</p><p>如果想取消请求，使用 cancel 方法。</p><h2 id="POST-请求访问网络"><a href="#POST-请求访问网络" class="headerlink" title="POST 请求访问网络"></a>POST 请求访问网络</h2><p>首先用 @FormUrlEncoded 注解表示它是一个表单请求。然后再 getIpMsg 方法使用 @Field 注解表明参数 String 的键，从而组成一组键值对进行传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IpServicePost</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST(&quot;getIpInfo.php&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;IpModel&gt; <span class="title">getIpMsg</span><span class="params">(<span class="meta">@Field(&quot;ip&quot;)</span> String first)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Post 请求网络的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(IP_TAOBAO_SERVICE)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line">    IpServicePost ipServicePost = retrofit.create(IpServicePost.class);</span><br><span class="line">    Call&lt;IpModel&gt; call = ipServicePost.getIpMsg(IP);</span><br><span class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;IpModel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;IpModel&gt; call, Response&lt;IpModel&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;IpModel&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息报头-Header"><a href="#消息报头-Header" class="headerlink" title="消息报头 Header"></a>消息报头 Header</h2><p>在 HTTP 请求中，为了防止攻击或者过滤不安全的访问，或是添加特殊加密的访问标记时，会在消息报头携带特殊的消息头处理。</p><p>Retrofit 提供了 @Header 注解添加消息报头。有 2 种添加方式：</p><ol><li>静态添加；</li><li>动态添加。</li></ol><h3 id="静态方式"><a href="#静态方式" class="headerlink" title="静态方式"></a>静态方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeaderStaticService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;some/endpoint&quot;)</span></span><br><span class="line">    <span class="meta">@Headers(&quot;Accept-Encoding: application/json&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCarType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果添加多个消息报头，可以使用大括号{}。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeaderStaticMultiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;some/endpoint&quot;)</span></span><br><span class="line">    <span class="meta">@Headers(&#123;</span></span><br><span class="line"><span class="meta">            &quot;Accept-Encoding: application/json&quot;,</span></span><br><span class="line"><span class="meta">            &quot;User-Agent: MoonRetrofit&quot;</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCarType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态方式"><a href="#动态方式" class="headerlink" title="动态方式"></a>动态方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HeaderDynamicService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;some/endpoint&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCarType</span><span class="params">(<span class="meta">@Header(&quot;Location&quot;)</span> String location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @Header 注解，可以通过调用 getCarType 方法动态地添加消息报头。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Retrofit 使用注解的方式提供网络请求功能。使用 @GET 、@POST 方法访问网络，使用 @Header 添加消息报头。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Retrofit-基本用法&quot;&gt;&lt;a href=&quot;#Retrofit-基本用法&quot; class=&quot;headerlink&quot; title=&quot;Retrofit 基本用法&quot;&gt;&lt;/a&gt;Retrofit 基本用法&lt;/h1&gt;&lt;h2 id=&quot;Retrofit-介绍&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
</feed>
