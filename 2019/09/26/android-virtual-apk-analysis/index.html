<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>VirtualAPK 插件化原理分析 | caoshen</title><meta name="keywords" content="Android"><meta name="author" content="caoshen"><meta name="copyright" content="caoshen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="VirtualAPK 插件化原理分析这里以 VirtualAPK 0.9.8 版本为例，从三个方面介绍 VirtualAPK 的插件化原理。  VirtualAPK 如何加载插件 APK 的类 VirtualAPK 如何解决宿主 APK 和插件 APK 的冲突 VirtualAPK 如何支持四大组件  VirtualAPK 插件类的加载VirtualAPK 从外部存储读取到插件 APK 后，调用了">
<meta property="og:type" content="article">
<meta property="og:title" content="VirtualAPK 插件化原理分析">
<meta property="og:url" content="https://www.okclouder.cn/2019/09/26/android-virtual-apk-analysis/index.html">
<meta property="og:site_name" content="caoshen">
<meta property="og:description" content="VirtualAPK 插件化原理分析这里以 VirtualAPK 0.9.8 版本为例，从三个方面介绍 VirtualAPK 的插件化原理。  VirtualAPK 如何加载插件 APK 的类 VirtualAPK 如何解决宿主 APK 和插件 APK 的冲突 VirtualAPK 如何支持四大组件  VirtualAPK 插件类的加载VirtualAPK 从外部存储读取到插件 APK 后，调用了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-7ee85967b49666200f68099e057ccfdf_720w.jpeg">
<meta property="article:published_time" content="2019-09-25T17:16:54.000Z">
<meta property="article:modified_time" content="2020-12-08T15:46:39.132Z">
<meta property="article:author" content="caoshen">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-7ee85967b49666200f68099e057ccfdf_720w.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.okclouder.cn/2019/09/26/android-virtual-apk-analysis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-08 23:46:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="caoshen" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://avatars2.githubusercontent.com/u/3806787?s=460&amp;u=ee280a9fc6c98bc591f30ffbf10360a9ac3822ff&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">145</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic1.zhimg.com/80/v2-7ee85967b49666200f68099e057ccfdf_720w.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">caoshen</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">VirtualAPK 插件化原理分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-09-25T17:16:54.000Z" title="发表于 2019-09-26 01:16:54">2019-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-08T15:46:39.132Z" title="更新于 2020-12-08 23:46:39">2020-12-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="VirtualAPK-插件化原理分析"><a href="#VirtualAPK-插件化原理分析" class="headerlink" title="VirtualAPK 插件化原理分析"></a>VirtualAPK 插件化原理分析</h1><p>这里以 VirtualAPK 0.9.8 版本为例，从三个方面介绍 VirtualAPK 的插件化原理。</p>
<ol>
<li>VirtualAPK 如何加载插件 APK 的类</li>
<li>VirtualAPK 如何解决宿主 APK 和插件 APK 的冲突</li>
<li>VirtualAPK 如何支持四大组件</li>
</ol>
<h2 id="VirtualAPK-插件类的加载"><a href="#VirtualAPK-插件类的加载" class="headerlink" title="VirtualAPK 插件类的加载"></a>VirtualAPK 插件类的加载</h2><p>VirtualAPK 从外部存储读取到插件 APK 后，调用了 PluginManager 的 loadPlugin 的方法加载插件 APK。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File plugin = <span class="keyword">new</span> File(pluginPath);</span><br><span class="line">PluginManager.getInstance(<span class="keyword">this</span>).loadPlugin(plugin);</span><br></pre></td></tr></table></figure>

<p>PluginManager 的 loadPlugin 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPlugin</span><span class="params">(File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">        LoadedPlugin plugin = createLoadedPlugin(apk);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == plugin) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t load plugin which is invalid: &quot;</span> + apk.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出loadPlugin 会调用 createLoadedPlugin 方法得到一个 LoadedPlugin。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadedPlugin <span class="title">createLoadedPlugin</span><span class="params">(File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadedPlugin(<span class="keyword">this</span>, <span class="keyword">this</span>.mContext, apk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 createLoadedPlugin 调用了 LoadedPlugin 的构造方法，将 PluginManager、context、插件 APK 作为参数传递给了构造方法。</p>
<p>LoadedPlugin 的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadedPlugin</span><span class="params">(PluginManager pluginManager, Context context, File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPluginManager = pluginManager;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.mPackage = PackageParserCompat.parsePackage(context, apk, PackageParser.PARSE_MUST_BE_APK);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.mResources = createResources(context, getPackageName(), apk);</span><br><span class="line">        <span class="keyword">this</span>.mClassLoader = createClassLoader(context, apk, <span class="keyword">this</span>.mNativeLibDir, context.getClassLoader());</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Cache instrumentations</span></span><br><span class="line">        Map&lt;ComponentName, InstrumentationInfo&gt; instrumentations = <span class="keyword">new</span> HashMap&lt;ComponentName, InstrumentationInfo&gt;();</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Cache activities</span></span><br><span class="line">        Map&lt;ComponentName, ActivityInfo&gt; activityInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache services</span></span><br><span class="line">        Map&lt;ComponentName, ServiceInfo&gt; serviceInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ServiceInfo&gt;();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache providers</span></span><br><span class="line">        Map&lt;String, ProviderInfo&gt; providers = <span class="keyword">new</span> HashMap&lt;String, ProviderInfo&gt;();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register broadcast receivers dynamically</span></span><br><span class="line">        Map&lt;ComponentName, ActivityInfo&gt; receivers = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// try to invoke plugin&#x27;s application</span></span><br><span class="line">        invokeApplication();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 LoadedPlugin 的构造方法会解析 APK 包，加载插件资源，加载插件类，解析 Instrumentation 和四大组件，最后调用插件的 application。</p>
<p>使用 PackageParserCompat.parsePackage 解析 APK 包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mPackage = PackageParserCompat.parsePackage(context, apk, PackageParser.PARSE_MUST_BE_APK);</span><br></pre></td></tr></table></figure>

<p>使用 createResources 加载插件资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mResources = createResources(context, getPackageName(), apk);</span><br></pre></td></tr></table></figure>

<p>使用 createClassLoader 加载插件类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mClassLoader = createClassLoader(context, apk, <span class="keyword">this</span>.mNativeLibDir, context.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>从 PackageParser.Package 解析 Instrumentation 和四大组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cache activities</span></span><br><span class="line">Map&lt;ComponentName, ActivityInfo&gt; activityInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line"><span class="keyword">for</span> (PackageParser.Activity activity : <span class="keyword">this</span>.mPackage.activities) &#123;</span><br><span class="line">    activity.info.metaData = activity.metaData;</span><br><span class="line">    activityInfos.put(activity.getComponentName(), activity.info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.mActivityInfos = Collections.unmodifiableMap(activityInfos);</span><br><span class="line"><span class="keyword">this</span>.mPackageInfo.activities = activityInfos.values().toArray(<span class="keyword">new</span> ActivityInfo[activityInfos.size()]);</span><br></pre></td></tr></table></figure>

<p>最后调用了 invokeApplication 方法运行插件 APK 的 application。</p>
<p>插件类的加载 createClassLoader 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(Context context, File apk, File libsDir, ClassLoader parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File dexOutputDir = getDir(context, Constants.OPTIMIZE_DIR);</span><br><span class="line">    String dexOutputPath = dexOutputDir.getAbsolutePath();</span><br><span class="line">    DexClassLoader loader = <span class="keyword">new</span> DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Constants.COMBINE_CLASSLOADER) &#123;</span><br><span class="line">        DexUtil.insertDex(loader, parent, libsDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 createClassLoader 构造了 DexCloader 并且把宿主 APK 的 classLoader 传递给了插件 APK 的 DexClassLoader。因此 VirtualAPK 的插件可以调用宿主的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader loader = <span class="keyword">new</span> DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);</span><br></pre></td></tr></table></figure>

<p>在 createClassLoader 方法里面也判断了 Constants.COMBINE_CLASSLOADER 是否为 true，如果为 true 就调用 insertDex 方法。</p>
<p>insertDex 方法把插件 APK 的 Dex 和宿主 APK 的 Dex 合并，然后把插件 APK 的 Dex 排在宿主 APK 后面，这样就在宿主 APK 包含了所有的 Dex，宿主可以加载插件 APK 的类。</p>
<p>合并宿主 APK 和 插件 APK 的 dex 的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertDex</span><span class="params">(DexClassLoader dexClassLoader, ClassLoader baseClassLoader, File nativeLibsDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object baseDexElements = getDexElements(getPathList(baseClassLoader));</span><br><span class="line">    Object newDexElements = getDexElements(getPathList(dexClassLoader));</span><br><span class="line">    Object allDexElements = combineArray(baseDexElements, newDexElements);</span><br><span class="line">    Object pathList = getPathList(baseClassLoader);</span><br><span class="line">    Reflector.with(pathList).field(<span class="string">&quot;dexElements&quot;</span>).set(allDexElements);</span><br><span class="line"></span><br><span class="line">    insertNativeLibrary(dexClassLoader, baseClassLoader, nativeLibsDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 Constants.COMBINE_CLASSLOADER 这个常量应该始终为 true。否则宿主 APK 就不会包含插件 APK 的 dex，也就加载不了插件的类。</p>
<h2 id="VirtualAPK-资源加载和冲突"><a href="#VirtualAPK-资源加载和冲突" class="headerlink" title="VirtualAPK 资源加载和冲突"></a>VirtualAPK 资源加载和冲突</h2><h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>LoadedPlugin 类的构造方法调用了 createResources 方法来构造资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mResources = createResources(context, getPackageName(), apk);</span><br></pre></td></tr></table></figure>

<p>createResources 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Resources <span class="title">createResources</span><span class="params">(Context context, String packageName, File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.COMBINE_RESOURCES) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResourcesManager.createResources(context, packageName, apk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Resources hostResources = context.getResources();</span><br><span class="line">        AssetManager assetManager = createAssetManager(context, apk);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到如果 Constants.COMBINE_RESOURCES 为 true，那么 createResources 会合并宿主 APK 和插件 APK 的资源，否则只返回插件 APK 的资源。</p>
<p>ResourcesManager 的 createResources 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Resources <span class="title">createResources</span><span class="params">(Context hostContext, String packageName, File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        <span class="keyword">return</span> createResourcesForN(hostContext, packageName, apk);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Resources resources = ResourcesManager.createResourcesSimple(hostContext, apk.getAbsolutePath());</span><br><span class="line">    ResourcesManager.hookResources(hostContext, resources);</span><br><span class="line">    <span class="keyword">return</span> resources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 N 版本以上 SDK，会调用 createResourcesForN 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use System Apis to update all existing resources.</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * 1. Update ApplicationInfo.splitSourceDirs and LoadedApk.mSplitResDirs</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * 2. Replace all keys of ResourcesManager.mResourceImpls to new ResourcesKey</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * 3. Use ResourcesManager.appendLibAssetForMainAssetPath(appInfo.publicSourceDir, &quot;$&#123;packageName&#125;.vastub&quot;) to update all existing resources.</span></span><br><span class="line"><span class="comment">     * &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * see android.webkit.WebViewDelegate.addWebViewAssetPath(Context)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.N)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Resources <span class="title">createResourcesForN</span><span class="params">(Context context, String packageName, File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">        LoadedApk loadedApk = Reflector.with(context).field(<span class="string">&quot;mPackageInfo&quot;</span>).get();</span><br><span class="line">    </span><br><span class="line">        Reflector rLoadedApk = Reflector.with(loadedApk).field(<span class="string">&quot;mSplitResDirs&quot;</span>);</span><br><span class="line">        String[] splitResDirs = rLoadedApk.get();</span><br><span class="line">        rLoadedApk.set(append(splitResDirs, newAssetPath));</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// lastly, sync all LoadedPlugin to newResources</span></span><br><span class="line">        <span class="keyword">for</span> (LoadedPlugin plugin : PluginManager.getInstance(context).getAllLoadedPlugins()) &#123;</span><br><span class="line">            plugin.updateResources(newResources);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">return</span> newResources;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过方法注释可以看出 createResourcesForN 方法更新了宿主 ApplicationInfo 的 splitSourceDirs、宿主 LoadedApk 的 mSplitResDirs、ResourcesManager.mResourceImpls 的 key 值、ResourcesManager 的 assetPath，最后把得到的新 Resources 更新给了每个插件的 LoadedPlugin。所以宿主 APK 和 插件 APK 可以相互共享资源。</p>
<h3 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h3><p>如果插件资源和宿主资源重复，比如引用了同一个 support 包，那么 virtualAPK 会过滤掉插件 APK 引用的 support 包。</p>
<p>使用 virtualAPK 是有 2 个有关资源的问题：</p>
<ol>
<li>如果插件依赖宿主 1.0 版本编译，宿主出了 2.0 版本，插件找不到 1.0 的资源 id 怎么办？ </li>
<li>怎么解决插件和宿主资源同名但是不同内容的问题？比如两者都有一个叫做 about 的字符串，关于的内容不一样。</li>
</ol>
<p>对于第一个问题，如果宿主出了 2.0 版本，那么插件也会出 2.0 版本，保持一致。</p>
<p>对于第二个问题，同名的资源在构建的时候 gradle 会报错，提示 duplicate resources entry，从 Android 开发的角度来看，资源不能重复，否则 merge 的时候就会报错。因此需要保证资源不同名。</p>
<h2 id="VirtualAPK-四大组件的支持"><a href="#VirtualAPK-四大组件的支持" class="headerlink" title="VirtualAPK 四大组件的支持"></a>VirtualAPK 四大组件的支持</h2><h3 id="Activity-的支持"><a href="#Activity-的支持" class="headerlink" title="Activity 的支持"></a>Activity 的支持</h3><p>Activity 的支持可以使用“欺上瞒下”来概括。</p>
<p>“欺上”是指启动一个 StubActivity 来欺骗 AMS，让 AMS 认为 Activity 已经在 AndroidManifest 注册，但是实际注册的 VirtualAPK 的 core aar 里面的 AndroidManifest 的占坑 Activity，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Stub Activities --&gt;</span><br><span class="line">&lt;activity</span><br><span class="line">    android:name&#x3D;&quot;com.didi.virtualapk.core.A$1&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:launchMode&#x3D;&quot;standard&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>“瞒下”是指 ActivityThread 在 performLaunchActivity 方法中启动 Activity 会调用 Instrumentation 的 newActivity 创建 Activity，此时创建的不是占坑的 StubActivity，而是真正需要启动的插件 Activity。</p>
<p>VirtualAPK 的“欺上瞒下”是通过 hook 替换原始 Instrumentation，改为自己的 VAInstrumentation。</p>
<p>VAInstrumentation 构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VAInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VAInstrumentation</span><span class="params">(PluginManager pluginManager, Instrumentation base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPluginManager = pluginManager;</span><br><span class="line">        <span class="keyword">this</span>.mBase = base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出真正的 Instrumentation 作为了 mBase 变量，有点类似 ContextImpl。</p>
<p>VAInstrumentation 主要做 2 件事：</p>
<ol>
<li>启动时替换原始 intent 为占坑 intent</li>
<li>构造 Activity 时还原占坑 intent 为原始 intent</li>
</ol>
<p>启动时替换原始 intent 为占坑 intent，这一步依靠 injectIntent 来完成，注入 Intent 后还是调用 Instrumentation 类启动 Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    injectIntent(intent);</span><br><span class="line">    <span class="keyword">return</span> mBase.execStartActivity(who, contextThread, token, target, intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>injectIntent 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">injectIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// null component is an implicitly intent</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// resolve intent with Stub Activity if needed</span></span><br><span class="line">        <span class="keyword">this</span>.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出调用了 markIntentIfNeeded 来转换为 StubActivity。</p>
<p>markIntentIfNeeded 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markIntentIfNeeded</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String targetPackageName = intent.getComponent().getPackageName();</span><br><span class="line">    String targetClassName = intent.getComponent().getClassName();</span><br><span class="line">    <span class="comment">// search map and return specific launchmode stub activity</span></span><br><span class="line">    <span class="keyword">if</span> (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Constants.KEY_IS_PLUGIN, <span class="keyword">true</span>);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);</span><br><span class="line">        dispatchStubActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>markIntentIfNeeded 会把原始 intent 的包名和类名存入 intent 的 extra 中，然后调用 dispatchStubActivity 启动 StubActivity。</p>
<p>dispatchStubActivity 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStubActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    ComponentName component = intent.getComponent();</span><br><span class="line">    String targetClassName = intent.getComponent().getClassName();</span><br><span class="line">    ...</span><br><span class="line">    String stubActivity = mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj);</span><br><span class="line">    ...</span><br><span class="line">    intent.setClassName(mContext, stubActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 dispatchStubActivity 根据类名、启动模式、主题来选择合适的占坑 Activity，最后用 setClassName 改写原始 Activity 为占坑 Activity。</p>
<p>VAInstrumentation 的 newActivity 用来构造 Activity ，还原占坑 intent 为原始 intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.loadClass(className);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        ComponentName component = PluginUtil.getComponent(intent);</span><br><span class="line">        ...</span><br><span class="line">        Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> newActivity(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newActivity(mBase.newActivity(cl, className, intent));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newActivity 中先判断用宿主的 classLoader 能否加载启动的类，如果能加载说明时宿主的 Activity，直接启动。否则调用 PluginUtil.getComponent 得到原始的插件 Intent，然后使用插件的 ClassLoader 来加载原始的插件 Intent。</p>
<h3 id="Service-的支持"><a href="#Service-的支持" class="headerlink" title="Service 的支持"></a>Service 的支持</h3><p>Service 的支持也是采用“欺上瞒下”的方法，插件 Service 的启动实际上是通过 VirtualAPK 的代理 Service 启动的。</p>
<p>正常的 Service 启动会调用 ContextImpl 的 startServiceCommon 方法。</p>
<p>startServiceCommon 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), requireForeground,</span><br><span class="line">                        getOpPackageName(), user.getIdentifier());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 startServiceCommon 方法调用了 AMS 的 startService。</p>
<p>为了调用 VirtualAPK 的代理 Service，VirtualAPK 的 pluginManager hook 替换了 ActivityManager 为自定义的 ActivityManagerProxy。采用动态代理的方式在 AMS startService 之前修改了 intent。</p>
<p>PluginManager 的构造方法会调用 hookCurrentProcess 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    hookCurrentProcess();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookCurrentProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hookInstrumentationAndHandler();</span><br><span class="line">    hookSystemServices();</span><br><span class="line">    hookDataBindingUtil();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hookCurrentProcess 的第二步就是 hookSystemServices，它主要 hook 了 ActivityManager。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookSystemServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            defaultSingleton = Reflector.on(ActivityManager.class).field(<span class="string">&quot;IActivityManagerSingleton&quot;</span>).get();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        IActivityManager origin = defaultSingleton.get();</span><br><span class="line">        IActivityManager activityManagerProxy = (IActivityManager) Proxy.newProxyInstance(mContext.getClassLoader(), <span class="keyword">new</span> Class[] &#123; IActivityManager.class &#125;,</span><br><span class="line">            createActivityManagerProxy(origin));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook IActivityManager from ActivityManagerNative</span></span><br><span class="line">        Reflector.with(defaultSingleton).field(<span class="string">&quot;mInstance&quot;</span>).set(activityManagerProxy);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出使用 Proxy.newProxyInstance 生成了一个动态代理的 IActivityManager 对象。这样在调用 IActivityManager 的原始方法时，会转而调用 activityManagerProxy 代理的 invoke 方法。</p>
<p>createActivityManagerProxy 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ActivityManagerProxy <span class="title">createActivityManagerProxy</span><span class="params">(IActivityManager origin)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(<span class="keyword">this</span>, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createActivityManagerProxy 构造了一个 ActivityManagerProxy 对象，并传递原始的 ActivityManager。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;startService&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> startService(proxy, method, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Start service error&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 startService 方法会调用 ActivityManagerProxy 的 startService。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">startService</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> startDelegateServiceForTarget(target, resolveInfo.serviceInfo, <span class="keyword">null</span>, RemoteService.EXTRA_COMMAND_START_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startService 方法会先判断启动的是宿主的 Service 还是插件的 Service。如果是插件的 Service，直接调用 startDelegateServiceForTarget。startDelegateServiceForTarget 会启动代理 Service。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ComponentName <span class="title">startDelegateServiceForTarget</span><span class="params">(Intent target, ServiceInfo serviceInfo, Bundle extras, <span class="keyword">int</span> command)</span> </span>&#123;</span><br><span class="line">    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);</span><br><span class="line">    <span class="keyword">return</span> mPluginManager.getHostContext().startService(wrapperIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Intent <span class="title">wrapperTargetIntent</span><span class="params">(Intent target, ServiceInfo serviceInfo, Bundle extras, <span class="keyword">int</span> command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fill in service with ComponentName</span></span><br><span class="line">    target.setComponent(<span class="keyword">new</span> ComponentName(serviceInfo.packageName, serviceInfo.name));</span><br><span class="line">    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start delegate service to run plugin service inside</span></span><br><span class="line">    <span class="keyword">boolean</span> local = PluginUtil.isLocalService(serviceInfo);</span><br><span class="line">    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setClass(mPluginManager.getHostContext(), delegate);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_TARGET, target);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_COMMAND, command);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);</span><br><span class="line">    <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtras(extras);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 startDelegateServiceForTarget 修改了 intent，它将原始 intent 作为参数直接传递给了新 intent。注意到 intent 本身实现了 Parcelable 接口，它可以作为参数传递。</p>
<p>如果是本地 Service，就启动 LocalService 作为代理。如果是多进程 Service，就启动 RemoteService 作为代理。</p>
<p>查看 VirtualAPK 的 manifest。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Local Service running in main process --&gt;</span><br><span class="line">&lt;service</span><br><span class="line">    android:name&#x3D;&quot;com.didi.virtualapk.delegate.LocalService&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Daemon Service running in child process --&gt;</span><br><span class="line">&lt;service</span><br><span class="line">    android:name&#x3D;&quot;com.didi.virtualapk.delegate.RemoteService&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:process&#x3D;&quot;:daemon&quot; &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;$&#123;applicationId&#125;.intent.ACTION_DAEMON_SERVICE&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出 LocalService 运行在主进程，RemoteService 运行在 daemon 新进程。</p>
<p>LocalService 的 onStartCommand 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> command = intent.getIntExtra(EXTRA_COMMAND, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">            <span class="keyword">case</span> EXTRA_COMMAND_START_SERVICE: &#123;</span><br><span class="line">                ...</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();</span><br><span class="line">...</span><br><span class="line">                        attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);</span><br><span class="line">                        service.onCreate();</span><br><span class="line">                        <span class="keyword">this</span>.mPluginManager.getComponentsHandler().rememberService(component, service);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                service.onStartCommand(target, <span class="number">0</span>, <span class="keyword">this</span>.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 LocalService 在 onStartCommand 时会从 intent 取出 command，代表需要执行哪些操作。比如 startService 会调用 classloader 加载 Service 的 class，然后依次调用 service 的 attach、onCreate、onStartCommand 方法，完成插件 Service 的启动。</p>
<h2 id="ContentProvider-的支持"><a href="#ContentProvider-的支持" class="headerlink" title="ContentProvider 的支持"></a>ContentProvider 的支持</h2><p>和 StubActivity、LocalService 一样，VirtualAPK 在 AndroidManifest 提供了一个代理 ContentProvider，即 RemoteContentProvider。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;com.didi.virtualapk.delegate.RemoteContentProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.VirtualAPK.Provider&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:process&#x3D;&quot;:daemon&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>正常流程下通过 getContentResolver 查询 ContentProvider 时，实际上调用了 ContextImpl 的 ApplicationContentResolver 去查询。</p>
<p>VirtualAPK 在加载插件时，会产生一个 LoadedPlugin，并且为 LoadedPlugin 创建 pluginContext，pluginContext 的 getContentResolver 方法会构造一个 PluginContentResolver。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PluginContentResolver(getHostContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常流程下 ApplicationContentResolver 查询时会调用 ActivityThread 的 acquireProvider 方法。</p>
<p>在插件的 PluginContentResolver 中会调用 PluginManager 的 getIContentProvider 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPluginManager.resolveContentProvider(auth, <span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPluginManager.getIContentProvider();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.acquireProvider(context, auth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PluginManager 的 getIContentProvider 方法调用了 hookIContentProviderAsNeeded。 hookIContentProviderAsNeeded 会 hook ActivityThread 中的 IContentProvider.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> IContentProvider <span class="title">getIContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIContentProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        hookIContentProviderAsNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mIContentProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hookIContentProviderAsNeeded 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookIContentProviderAsNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(RemoteContentProvider.getUri(mContext));</span><br><span class="line">    mContext.getContentResolver().call(uri, <span class="string">&quot;wakeup&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread activityThread = ActivityThread.currentActivityThread();</span><br><span class="line">        Map providerMap = Reflector.with(activityThread).field(<span class="string">&quot;mProviderMap&quot;</span>).get();</span><br><span class="line">        Iterator iter = providerMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (auth.equals(RemoteContentProvider.getAuthority(mContext))) &#123;</span><br><span class="line">                ...</span><br><span class="line">                IContentProvider rawProvider = (IContentProvider) provider.get(val);</span><br><span class="line">                IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider);</span><br><span class="line">                mIContentProvider = proxy;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;hookIContentProvider succeed : &quot;</span> + mIContentProvider);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.w(TAG, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 hookIContentProviderAsNeeded 首先解析得到占坑的代理 Provider，即 RemoteContentProvider 的 Uri，然后立即 call 了占坑的 RemoteContentProvider。接着从 ActivityThread 的 mProviderMap 中查找对应 auth 的 provider。如果存在和 RemoteContentProvider 相同 auth 的 provider，就采用动态代理的方式 hook 掉这个 provider，替换为自己的 IContentProviderProxy 类。</p>
<p>IContentProviderProxy 是一个代理接口，它实现了 InvocationHandler，直接看它的 invoke 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Log.v(TAG, method.toGenericString() + <span class="string">&quot; : &quot;</span> + Arrays.toString(args));</span><br><span class="line">    wrapperUri(method, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(mBase, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 invoke 方法封装了 method、args，然后调用原始 IContentProvider 的方法。</p>
<p>wrapperUri 会调用 PluginContentResolver 的 wrapperUri 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Keep</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Uri <span class="title">wrapperUri</span><span class="params">(LoadedPlugin loadedPlugin, Uri pluginUri)</span> </span>&#123;</span><br><span class="line">    String pkg = loadedPlugin.getPackageName();</span><br><span class="line">    String pluginUriString = Uri.encode(pluginUri.toString());</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(RemoteContentProvider.getUri(loadedPlugin.getHostContext()));</span><br><span class="line">    builder.append(<span class="string">&quot;/?plugin=&quot;</span> + loadedPlugin.getLocation());</span><br><span class="line">    builder.append(<span class="string">&quot;&amp;pkg=&quot;</span> + pkg);</span><br><span class="line">    builder.append(<span class="string">&quot;&amp;uri=&quot;</span> + pluginUriString);</span><br><span class="line">    Uri wrapperUri = Uri.parse(builder.toString());</span><br><span class="line">    <span class="keyword">return</span> wrapperUri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrapperUri 将插件的存放位置、包名、uri 三者作为参数成为新的 uri。它的作用是在代理 RemoteContentProvider 分发增删改查操作时，再把这些信息提取出来。</p>
<p>这里以 RemoteContentProvider 的 query 方法为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">    ContentProvider provider = getContentProvider(uri);</span><br><span class="line">    Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI));</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.query(pluginUri, projection, selection, selectionArgs, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 RemoteContentProvider 的 query，首先调用了 getContentProvider 找到真正的插件 Provider。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProvider <span class="title">getContentProvider</span><span class="params">(<span class="keyword">final</span> Uri uri)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (sCachedProviders) &#123;</span><br><span class="line">        LoadedPlugin plugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));</span><br><span class="line">        <span class="keyword">if</span> (plugin == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pluginManager.loadPlugin(<span class="keyword">new</span> File(uri.getQueryParameter(KEY_PLUGIN)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.w(TAG, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ProviderInfo providerInfo = pluginManager.resolveContentProvider(auth, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (providerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RunUtil.runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        LoadedPlugin loadedPlugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));</span><br><span class="line">                        ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance();</span><br><span class="line">                        contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);</span><br><span class="line">                        sCachedProviders.put(auth, contentProvider);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Log.w(TAG, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> sCachedProviders.get(auth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 getContentProvider 方法把之前组合好的 uri 通过 getQueryParameter 的方式查到里面携带的信息参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pluginManager.loadPlugin(<span class="keyword">new</span> File(uri.getQueryParameter(KEY_PLUGIN)));</span><br></pre></td></tr></table></figure>

<p>比如用来从指定地址加载插件。</p>
<p>然后用 Class.forName 构造了 ContentProvider，attach 了 providerInfo，并且做了 provider 缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance();</span><br><span class="line">contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);</span><br></pre></td></tr></table></figure>

<p>至此分发到了插件的 ContentProvider 并调用了插件 Provider 的方法。</p>
<h3 id="BroadcastReceiver-的支持"><a href="#BroadcastReceiver-的支持" class="headerlink" title="BroadcastReceiver 的支持"></a>BroadcastReceiver 的支持</h3><p>BroadcastReceiver 的支持比较简单，直接将插件 AndroidManifest 中的静态广播转为动态广播，插件原有的动态广播放入宿主动态注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadedPlugin</span><span class="params">(PluginManager pluginManager, Context context, File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Register broadcast receivers dynamically</span></span><br><span class="line">    Map&lt;ComponentName, ActivityInfo&gt; receivers = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Activity receiver : <span class="keyword">this</span>.mPackage.receivers) &#123;</span><br><span class="line">        receivers.put(receiver.getComponentName(), receiver.info);</span><br><span class="line"></span><br><span class="line">        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());</span><br><span class="line">        <span class="keyword">for</span> (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mHostContext.registerReceiver(br, aii);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这一步是在 LoadedPlugin 的构造方法中解析 BroadcastReceiver 完成的。</p>
<p>可以看出，对于插件 APK 静态注册的某些广播，比如开机广播，宿主 APK 是无法实现其功能的，因为它们被转换为了动态广播，手机开机时，应用进程没有被拉起，无法动态监听开机广播。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>VirtualAPK 加载插件后会得到一个 LoadedPlugin，它是插件的核心类，类似于 Android 自身的 LoadedApk。LoadedPlugin 通过 insertDex 方法把插件 APK 的 Dex 和宿主 APK 的 Dex 合并，这样宿主 APK 包含了所有的 Dex，宿主可以加载插件 APK 的类。 同时 LoadedPlugin 的 DexClassLoader 在构造时传入了宿主的 classLoader，所以插件可以加载宿主的类。</p>
</li>
<li><p>VirtualAPK 将宿主的 resource 和插件的 resource 合并，最后把得到的新 Resources 更新给了每个插件的 LoadedPlugin。所以宿主 APK 和 插件 APK 可以相互共享资源。</p>
</li>
<li><p>VirtualAPK 通过“欺上瞒下”的方式分别 hook 了 Instrumentation、ActivityManager、IContentProvider，并将原始的调用 hook 为对占坑的 StubActivity、LocalService、RemoteContentProvider 的调用，在重新分发的过程中又解析了 intent 和 uri，并且加载了插件中的对应组件，调用原始组件的方法。BroadcastReceiver 和其他三个组件的方式有所不同，采用了静态广播转动态广播的方法。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">caoshen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.okclouder.cn/2019/09/26/android-virtual-apk-analysis/">https://www.okclouder.cn/2019/09/26/android-virtual-apk-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.okclouder.cn" target="_blank">caoshen</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/80/v2-7ee85967b49666200f68099e057ccfdf_720w.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/09/27/java-thread-state/"><img class="prev-cover" src="https://pic1.zhimg.com/80/v2-f35173d481bfa0b7fbb5d143cfdd9c24_720w.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 线程的状态</div></div></a></div><div class="next-post pull-right"><a href="/2019/09/21/android-virtual-apk-introduction/"><img class="next-cover" src="https://pic4.zhimg.com/80/v2-99278df8a75a8ea34b0ad593639aa64f_720w.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VirtualAPK 插件化框架介绍</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/08/20/android-asyncTask/" title="AsyncTask 异步任务"><img class="cover" src="https://pic1.zhimg.com/80/v2-7ee85967b49666200f68099e057ccfdf_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-20</div><div class="title">AsyncTask 异步任务</div></div></a></div><div><a href="/2019/10/07/android-sharedpreference-principle/" title="Android SharedPreferences 实现原理"><img class="cover" src="https://pic1.zhimg.com/80/v2-1cdcdbb5a4e88b22dcf70254bd304cf4_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-07</div><div class="title">Android SharedPreferences 实现原理</div></div></a></div><div><a href="/2019/09/21/android-virtual-apk-introduction/" title="VirtualAPK 插件化框架介绍"><img class="cover" src="https://pic4.zhimg.com/80/v2-99278df8a75a8ea34b0ad593639aa64f_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-21</div><div class="title">VirtualAPK 插件化框架介绍</div></div></a></div><div><a href="/2019/08/19/android-window/" title="Android Window"><img class="cover" src="https://pic1.zhimg.com/80/v2-f35173d481bfa0b7fbb5d143cfdd9c24_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-19</div><div class="title">Android Window</div></div></a></div><div><a href="/2019/08/20/okhttp-analysis/" title="OkHttp 源码解析"><img class="cover" src="https://pic1.zhimg.com/80/v2-0abf538399b88f11cd3864acd01217b0_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-20</div><div class="title">OkHttp 源码解析</div></div></a></div><div><a href="/2019/08/20/okhttp-usage/" title="Okhttp 基本用法"><img class="cover" src="https://pic4.zhimg.com/80/v2-e8217349951412b8a73bcf5956cf99de_720w.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-20</div><div class="title">Okhttp 基本用法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://avatars2.githubusercontent.com/u/3806787?s=460&amp;u=ee280a9fc6c98bc591f30ffbf10360a9ac3822ff&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">caoshen</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">145</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caoshen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/caoshen" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">hello</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#VirtualAPK-%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">VirtualAPK 插件化原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#VirtualAPK-%E6%8F%92%E4%BB%B6%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.</span> <span class="toc-text">VirtualAPK 插件类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VirtualAPK-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.</span> <span class="toc-text">VirtualAPK 资源加载和冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">资源加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">资源冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VirtualAPK-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.3.</span> <span class="toc-text">VirtualAPK 四大组件的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">Activity 的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">Service 的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContentProvider-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.</span> <span class="toc-text">ContentProvider 的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BroadcastReceiver-%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">BroadcastReceiver 的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/31/summary-2020/" title="2020年终总结"><img src="https://pic4.zhimg.com/80/v2-99278df8a75a8ea34b0ad593639aa64f_720w.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2020年终总结"/></a><div class="content"><a class="title" href="/2020/12/31/summary-2020/" title="2020年终总结">2020年终总结</a><time datetime="2020-12-31T14:38:51.000Z" title="发表于 2020-12-31 22:38:51">2020-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/10/android-room-with-a-view/" title="Android Jetpack 之使用 Room 操作数据库"><img src="https://pic1.zhimg.com/80/v2-ce97917245cff618aa5ed0f75d678d9b_720w.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android Jetpack 之使用 Room 操作数据库"/></a><div class="content"><a class="title" href="/2020/12/10/android-room-with-a-view/" title="Android Jetpack 之使用 Room 操作数据库">Android Jetpack 之使用 Room 操作数据库</a><time datetime="2020-12-10T11:22:00.000Z" title="发表于 2020-12-10 19:22:00">2020-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/08/lancet-analysis/" title="Android AOP 框架 Lancet 应用与解析"><img src="https://pic1.zhimg.com/80/v2-9efeac87d85d51af8ec3470d8b31d80f_720w.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android AOP 框架 Lancet 应用与解析"/></a><div class="content"><a class="title" href="/2020/12/08/lancet-analysis/" title="Android AOP 框架 Lancet 应用与解析">Android AOP 框架 Lancet 应用与解析</a><time datetime="2020-12-08T13:12:00.000Z" title="发表于 2020-12-08 21:12:00">2020-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/03/gradle-transform-api/" title="Gradle Android Transform API 编译修改 class"><img src="https://pic4.zhimg.com/80/v2-99278df8a75a8ea34b0ad593639aa64f_720w.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Gradle Android Transform API 编译修改 class"/></a><div class="content"><a class="title" href="/2020/11/03/gradle-transform-api/" title="Gradle Android Transform API 编译修改 class">Gradle Android Transform API 编译修改 class</a><time datetime="2020-11-03T02:07:21.000Z" title="发表于 2020-11-03 10:07:21">2020-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/28/android-gradle-version-optimization/" title="Android Gradle 版本参数优化"><img src="https://pic1.zhimg.com/80/v2-ce97917245cff618aa5ed0f75d678d9b_720w.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android Gradle 版本参数优化"/></a><div class="content"><a class="title" href="/2020/10/28/android-gradle-version-optimization/" title="Android Gradle 版本参数优化">Android Gradle 版本参数优化</a><time datetime="2020-10-28T05:02:33.000Z" title="发表于 2020-10-28 13:02:33">2020-10-28</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By caoshen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="icp"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备18020323号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>